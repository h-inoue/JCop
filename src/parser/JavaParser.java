// Generated from src/parser/JavaParser.all
package parser;
 import AST.*;
import java.util.ArrayList;
import beaver.*;

/**
 * This class is a LALR parser generated by
 * <a href="http://beaver.sourceforge.net">Beaver</a> v0.9.6.1
 * from the grammar specification "JavaParser.beaver".
 */
public class JavaParser extends Parser {
	static public class Terminals {
		static public final short EOF = 0;
		static public final short DOT = 1;
		static public final short SUPER = 2;
		static public final short IDENTIFIER = 3;
		static public final short LPAREN = 4;
		static public final short RPAREN = 5;
		static public final short LT = 6;
		static public final short LBRACE = 7;
		static public final short RBRACE = 8;
		static public final short SEMICOLON = 9;
		static public final short DO = 10;
		static public final short WHILE = 11;
		static public final short FOR = 12;
		static public final short VOID = 13;
		static public final short IMPORT = 14;
		static public final short STATIC = 15;
		static public final short MULT = 16;
		static public final short THIS = 17;
		static public final short IF = 18;
		static public final short ELSE = 19;
		static public final short COLON = 20;
		static public final short NEW = 21;
		static public final short LAYER_ACTIVATION = 22;
		static public final short LAYER_DEACTIVATION = 23;
		static public final short CONTEXT = 24;
		static public final short UNLESS = 25;
		static public final short COMMA = 26;
		static public final short SWITCH = 27;
		static public final short BREAK = 28;
		static public final short CONTINUE = 29;
		static public final short SYNCHRONIZED = 30;
		static public final short CATCH = 31;
		static public final short ASSERT = 32;
		static public final short AT = 33;
		static public final short INTERFACE = 34;
		static public final short PC_CALL = 35;
		static public final short PC_EXECUTION = 36;
		static public final short PC_INITIALIZATION = 37;
		static public final short PC_PREINITIALIZATION = 38;
		static public final short PC_STATICINITIALIZATION = 39;
		static public final short PC_GET = 40;
		static public final short PC_SET = 41;
		static public final short PC_HANDLER = 42;
		static public final short PC_ADVICEEXECUTION = 43;
		static public final short PC_WITHIN = 44;
		static public final short PC_WITHINCODE = 45;
		static public final short PC_CFLOW = 46;
		static public final short PC_CFLOWBELOW = 47;
		static public final short PC_IF = 48;
		static public final short PC_THIS = 49;
		static public final short PC_TARGET = 50;
		static public final short PC_ARGS = 51;
		static public final short PC_PLUS = 52;
		static public final short PROCEED = 53;
		static public final short SUPER_PROCEED = 54;
		static public final short PACKAGE = 55;
		static public final short CLASS = 56;
		static public final short CASE = 57;
		static public final short DEFAULT = 58;
		static public final short RETURN = 59;
		static public final short THROW = 60;
		static public final short LBRACK = 61;
		static public final short RBRACK = 62;
		static public final short QUESTION = 63;
		static public final short EQ = 64;
		static public final short ENUM = 65;
		static public final short EXTENDS = 66;
		static public final short GT = 67;
		static public final short RSHIFT = 68;
		static public final short URSHIFT = 69;
		static public final short ELLIPSIS = 70;
		static public final short PC_DOTDOT = 71;
		static public final short LAYER = 72;
		static public final short INTEGER_LITERAL = 73;
		static public final short LONG_LITERAL = 74;
		static public final short FLOATING_POINT_LITERAL = 75;
		static public final short DOUBLE_LITERAL = 76;
		static public final short BOOLEAN_LITERAL = 77;
		static public final short CHARACTER_LITERAL = 78;
		static public final short STRING_LITERAL = 79;
		static public final short NULL_LITERAL = 80;
		static public final short BOOLEAN = 81;
		static public final short BYTE = 82;
		static public final short SHORT = 83;
		static public final short INT = 84;
		static public final short LONG = 85;
		static public final short CHAR = 86;
		static public final short FLOAT = 87;
		static public final short DOUBLE = 88;
		static public final short PUBLIC = 89;
		static public final short PROTECTED = 90;
		static public final short PRIVATE = 91;
		static public final short ABSTRACT = 92;
		static public final short FINAL = 93;
		static public final short NATIVE = 94;
		static public final short TRANSIENT = 95;
		static public final short VOLATILE = 96;
		static public final short STRICTFP = 97;
		static public final short IMPLEMENTS = 98;
		static public final short THROWS = 99;
		static public final short TRY = 100;
		static public final short FINALLY = 101;
		static public final short PLUSPLUS = 102;
		static public final short MINUSMINUS = 103;
		static public final short PLUS = 104;
		static public final short MINUS = 105;
		static public final short COMP = 106;
		static public final short NOT = 107;
		static public final short DIV = 108;
		static public final short MOD = 109;
		static public final short LSHIFT = 110;
		static public final short LTEQ = 111;
		static public final short GTEQ = 112;
		static public final short INSTANCEOF = 113;
		static public final short EQEQ = 114;
		static public final short NOTEQ = 115;
		static public final short AND = 116;
		static public final short XOR = 117;
		static public final short OR = 118;
		static public final short ANDAND = 119;
		static public final short OROR = 120;
		static public final short MULTEQ = 121;
		static public final short DIVEQ = 122;
		static public final short MODEQ = 123;
		static public final short PLUSEQ = 124;
		static public final short MINUSEQ = 125;
		static public final short LSHIFTEQ = 126;
		static public final short RSHIFTEQ = 127;
		static public final short URSHIFTEQ = 128;
		static public final short ANDEQ = 129;
		static public final short XOREQ = 130;
		static public final short OREQ = 131;
		static public final short IDENTIFIERPATTERN = 132;
		static public final short ASPECT = 133;
		static public final short PC_ERROR = 134;
		static public final short PC_PARENTS = 135;
		static public final short PC_PRECEDENCE = 136;
		static public final short PC_RETURNING = 137;
		static public final short PC_SOFT = 138;
		static public final short PC_THROWING = 139;
		static public final short PC_WARNING = 140;
		static public final short PC_ANDAND = 141;
		static public final short PC_OROR = 142;
		static public final short PC_MULT = 143;
		static public final short FORSUBJECT = 144;
		static public final short BEFORE = 145;
		static public final short AFTER = 146;
		static public final short ACTIVE = 147;
		static public final short THIS_LAYER = 148;

		static public final String[] NAMES = {
			"EOF",
			"DOT",
			"SUPER",
			"IDENTIFIER",
			"LPAREN",
			"RPAREN",
			"LT",
			"LBRACE",
			"RBRACE",
			"SEMICOLON",
			"DO",
			"WHILE",
			"FOR",
			"VOID",
			"IMPORT",
			"STATIC",
			"MULT",
			"THIS",
			"IF",
			"ELSE",
			"COLON",
			"NEW",
			"LAYER_ACTIVATION",
			"LAYER_DEACTIVATION",
			"CONTEXT",
			"UNLESS",
			"COMMA",
			"SWITCH",
			"BREAK",
			"CONTINUE",
			"SYNCHRONIZED",
			"CATCH",
			"ASSERT",
			"AT",
			"INTERFACE",
			"PC_CALL",
			"PC_EXECUTION",
			"PC_INITIALIZATION",
			"PC_PREINITIALIZATION",
			"PC_STATICINITIALIZATION",
			"PC_GET",
			"PC_SET",
			"PC_HANDLER",
			"PC_ADVICEEXECUTION",
			"PC_WITHIN",
			"PC_WITHINCODE",
			"PC_CFLOW",
			"PC_CFLOWBELOW",
			"PC_IF",
			"PC_THIS",
			"PC_TARGET",
			"PC_ARGS",
			"PC_PLUS",
			"PROCEED",
			"SUPER_PROCEED",
			"PACKAGE",
			"CLASS",
			"CASE",
			"DEFAULT",
			"RETURN",
			"THROW",
			"LBRACK",
			"RBRACK",
			"QUESTION",
			"EQ",
			"ENUM",
			"EXTENDS",
			"GT",
			"RSHIFT",
			"URSHIFT",
			"ELLIPSIS",
			"PC_DOTDOT",
			"LAYER",
			"INTEGER_LITERAL",
			"LONG_LITERAL",
			"FLOATING_POINT_LITERAL",
			"DOUBLE_LITERAL",
			"BOOLEAN_LITERAL",
			"CHARACTER_LITERAL",
			"STRING_LITERAL",
			"NULL_LITERAL",
			"BOOLEAN",
			"BYTE",
			"SHORT",
			"INT",
			"LONG",
			"CHAR",
			"FLOAT",
			"DOUBLE",
			"PUBLIC",
			"PROTECTED",
			"PRIVATE",
			"ABSTRACT",
			"FINAL",
			"NATIVE",
			"TRANSIENT",
			"VOLATILE",
			"STRICTFP",
			"IMPLEMENTS",
			"THROWS",
			"TRY",
			"FINALLY",
			"PLUSPLUS",
			"MINUSMINUS",
			"PLUS",
			"MINUS",
			"COMP",
			"NOT",
			"DIV",
			"MOD",
			"LSHIFT",
			"LTEQ",
			"GTEQ",
			"INSTANCEOF",
			"EQEQ",
			"NOTEQ",
			"AND",
			"XOR",
			"OR",
			"ANDAND",
			"OROR",
			"MULTEQ",
			"DIVEQ",
			"MODEQ",
			"PLUSEQ",
			"MINUSEQ",
			"LSHIFTEQ",
			"RSHIFTEQ",
			"URSHIFTEQ",
			"ANDEQ",
			"XOREQ",
			"OREQ",
			"IDENTIFIERPATTERN",
			"ASPECT",
			"PC_ERROR",
			"PC_PARENTS",
			"PC_PRECEDENCE",
			"PC_RETURNING",
			"PC_SOFT",
			"PC_THROWING",
			"PC_WARNING",
			"PC_ANDAND",
			"PC_OROR",
			"PC_MULT",
			"FORSUBJECT",
			"BEFORE",
			"AFTER",
			"ACTIVE",
			"THIS_LAYER"
		};
	}

	static final ParsingTables PARSING_TABLES = new ParsingTables(
		"U9piNGUS5CNIxvwmTyTn#OuaWc0ML0H4492eW80OC0SKCAAeY0Wgc51KG4N5733ZKp5$wjF" +
		"t52DYZZpCWXaH0#QRdU$VFJLvPdTskTDJT#xNrpqztTLLrLNLrTspFOnTs9$DL8zYzx6NsI" +
		"lQNkniRPYoZ3#WlAUyhtoWVCZEP6UnMUmQTftoZlAkEbRTdoqqJMKvxwhkepwe$f$w4Fk4V" +
		"QOkLQy3b3Rg1ce7jMDg43jRRSy#LVkbQxHUoiVgN6LFPO7wR#LkPQLobRANihUoZxAlif#o" +
		"ltA0Sg1oa396ELWPnhfgFTMRM3Vb9kLgvHhbMkKwvNhbHlKxrfvjmDhPiDbQhggpMOLQhAv" +
		"HR#6hrUkrFlhRR1lMIJbT6yVkPw#orzZhx0ts9dkBlStEKtzKVrNhLLDJrTyqhlwk$g3rrO" +
		"hKdzIVMLzzNqrJrxBQvFIpIdsQDaEV1FhNy2$vAdMn#Yz1lpPLFrQztSPHlOFDi#ZNzzTwc" +
		"VTQzBDvojrQzpZwrSi5$VppCFtgj#htwY#geQOrfYcQhgNKsUeATRwwHglGkwfVW$x$iMtq" +
		"IhqsJ7$gn0ZwpxFeLpTKLmlwjMQvzRzs8wjLbYiZrNVKXzL7hFxNhX6SiEdNZZMkjUXNxz1" +
		"wiUtS$jVEZgDVAnRqir4X#j#BfFyYDabTmwhuGLg5raTR3$r$8RydJB#w98B#kuZ#vzIhPV" +
		"zNU#ZVdftDncUWVnu$HF10MSvEu6tv8gsQpHNqinVPCbV#sLUs$AlNWlvoY$xqDg3$zZZws" +
		"Kco$xi6wMTVHj7Fbh1tUHtlm3lo3RK#aE1jajF0jcR3s13sD6YOp1OgbTeBQ5NGC5nTo6eT" +
		"6kOfdIqQb3gjbtgnHOFIKhcRTusZGTzUqA1q2jAWFQ4zpMQdQzHBsBDwFzAHsP1WMrzkqVg" +
		"e6x9jr68savrhKS6E5rIm6Um0TWexbLtBhdQfOCEKkMmSFrJO0bwbzbVdim$OHsm5cybRMR" +
		"Lv6$J0W1nuSY0xIFqlgmTFQlYcR9ZsBDjIolNZwkFW0U6f$CIUjNXIlnBzsiBjLtLrRBzk9" +
		"$lrk2YUQCFPuMoXNWN#I$pHhy#g$#55eb$PULeVFXBzUgNIZHt67b3#JnsgNwptOfsLESeP" +
		"oYNAyyhBx1Bj6xMQTMQNAO$eDU390jPTkK0hLXQpkSfCvIFb4wqt7wuE16ybV3w2RGKEtq0" +
		"ysXSycQa#9djzATy7Tu#onzayLYPmKxvGlWjPqoby41#jFSx#nUvWTxAxs29sDxk7tHlIkW" +
		"grKgrIQzHQjKvjgRPIMxDXl9UoLjcAxSFsW$IDKjzIJbTlKM$nznZVFdcFyLtGwv$mPa8Jr" +
		"VNKjkhwx7efnTloOhV7qbti7cCteSUU9IakLUvEryIEH3#B7jF#4#mnvHUfvLBcG8FTOwlO" +
		"xoHzQw69$NBHHAq7Bn5sKrckxSCMQWTgbrYQg3#Xtg4lThJZJQycsZI8qOJT72jr0w8r4V8" +
		"sayr6AyFKmMAK5dP4dQqVaDwQwDbHwmDvouM6MO0uaYrLbkk728XySpPSzeEbcxOr#JzsAF" +
		"N3irel$NAB1lr0zCCsiJGib9hJ8qJ39FPGkYS$Y7TDztHuDDl2Nv$9VkKTC28UZn5nag4Rk" +
		"gKvwUynidJMbhgQetHKgy47Q8xsF#qEItEWDOlP85jprDL2SxIsgUwyk$8lVJ8$H9$4jrGM" +
		"fRy7jA1cG7FqFLtDqPQBKk6$F3G7CgUinUW8pT4gs2fzOQfRQh1VRqGlvg0vGuNUy84Omt$" +
		"tQWxVZ7tgiV$3zLkensw4rCsZ7hiPOrYi$MSxIXzkTQZ7Rh6XsjPV$qQTpTlfEzZsdtLHVi" +
		"r5wdXx$NPZ6jz9MQw#hrMey$M5a1P1GrUl7wBlfXMxVWXy9ajpZe3cBCmYTU5nM6WAOEl$n" +
		"#Rfcw4Vze07Cbl8eNf7kgSnZPt7kfW$iMsqmKBUs4H0wAnrS#KDj5MdUshzb4UatRNaRRYo" +
		"MD$9bZTbdf0tFZ0aMs9ikesFDgR1#i$JwlWX65CWRtmmAqltX1s0lEb3#OFy8Vu8VvJ$Xp$" +
		"E5$Ed#3FyEVvyxlAcb#krobhOJSYRla2$NxyUz9RvvKsl0Bt9VQQFq3FrR2qizL4#I$qRv6" +
		"sKQwdLpws#IetNUcbBQ6pTMhaxTNYip$oPz1aF3Osjpsil6eQmGEn2hOAFr1Vo$M4XVfTwW" +
		"bpzITP5NPcJlEsXtg$UgrN0oYta8vJpvKW06fHjsN387D70UpWwCnTMZYorVbicUTEVbfRw" +
		"hD1eSxz#Yy1NwS#FXCTr3v$43uUbVf0Vmp$YA$Wdy3kxYD769syp$VAcTmp8soZOj#41#xP" +
		"fdBonkUf2xNrelfZpGTwKJrcPUgY#eP0tvVE6aZVfJPDzKmyrKaQAJzOt3jWtoxjEs5TA2o" +
		"5lIdV8ssa##xO5v6sXOz#4FbjzDK$hbJg2vYWzuD#Ep2nlwdPHja66uNPAQIFicxmRnKVeR" +
		"x4ksdzp6bKVHJzjWB1SsO4DXzqVhalxfcm9B$sPC0ry9EHjETctKHdbRPdKcHD3ywpLIdis" +
		"LVi$OVV1$H62vw01iYEaG5y4BxEB#hOjR#blfRmjTELDln6UwCb2tjGh8JjItlZFoc9jYID" +
		"lpqfFT41G9jBVfhyLyn7H8Zz9U8QG1Z6URipAbDdQSz8JFKEK2l$bAs$mMOIyxSFcfiR1Pz" +
		"anu8V#od$FOUvmcf0tzGh8so2llAaFGDxSDP4ZxJcXw2i#qhLl#acnOz4SQHjk2ybRPsLZz" +
		"Mrb2$L$mlFY8$X8FWBpgIVOTfWnh8MzWxonctEQ4yvMUbfU73zIwGiBDyXOAtLc13iFi8a6" +
		"urTLzSZRRsJVscMNDtrYIDuKPIZaUgssYUWHj3DNxw3ErggHTw6#K6#FUKWNTZveiFotDLe" +
		"vwrp$bT##iTd2VtFjc$eexDi5jhnfPKBUr4T3yhOclOQFWeo2Nepc5zds3HQrJ7q7b43UL2" +
		"vAXV$oyD$4J7iji1Sp7qcBQ1UqVEdI0gvMiry4BVAPDOjhhonMDPiM$MwfEq5BNMlBcxOtF" +
		"rBw8Ybu149tdc1b#cABbjJ9gHcfqzZ5SZH$IFh4efN3yl0DhZNtKzR2MtDeWIyo5tPWMmyj" +
		"#pgq29ssQAc07NZGiGFp8scPQTCYPn7lylVDxTYbWXR4PUXfgr#4zlvkRgUlqE$KgWKTsgx" +
		"cTYYHUxy8QL#hDWlsYxQTPtPTXpb2IihOztmjoPWA6Pll#6o$PgU5RQ3SeDoit2xxPHhwPH" +
		"BHKYgf#HOpuURwLFKTvKVbTFXQKtAdHVbDEHspwpjTMXGJi3fhE$XbZ6ZP3$wZvG$S0bfki" +
		"McfNvQT5dC3U0NbQgSWBPYngfYnxgVkhou0BNUfYzHTL3MrSHxzSfiw1lroWqiBC3y4j9pZ" +
		"qc92ndYje4MzHxtFdRkXRsmPspUA5lLmnpvFCZkgx$A3jDsKhOEqGAjMg6DIAL2mhpvLwik" +
		"yL5bgyppqvI2jHbbR$ufNNzGLeELSlxvOj82pNrgqrB$ffKKV4qMBrigcHN$2x07UppUtDN" +
		"j8VTaMTco5HOlPGskZZZ6trGvIgjY3PW$SxuXos#PE2to0E$rsJ3jIs6JjV0yjAspTrxfeu" +
		"qdtDuQCpNDiyXQHj9pezCk9PlVwhxLzjIlDxhOFaAeWMhfh9u57AxIknbXZhDdTxAwgsjNQ" +
		"HNdGOcXRGyPMU6HiZAJbNnxT$yMnO$EqtuYMSk$AcZOzYXQzgzClpVLQxKpjGktz#ZS5BMZ" +
		"FwHV8jAgNgYlqWNe9w9sgrMllmjFUC0z$PepG5s#$w8gavKuFBGRc0fgaPKUzc6Yv0JQvtA" +
		"7braXzMU6CB#Ne$sqnrtv0dI$xfIyhmzo0Q85#j6GFQlLwgVQkTWrxMD$As5vx91zQjFULj" +
		"NfFZqsUn$uDMXPv$CoDrMhmIj1IQzinVKlCe$TozENIA5fIGvr#6QIxgnoYN#P3zx$MUrYw" +
		"pnxJhz4gz6xwhteFVMzZUrQhzzPVo4FtxnIq6BrSMen33DWnTRvBI$rocnPZU$qwicF$XOm" +
		"zuTZa3mKjgNRw8soX$a7zH$f4$MVzSzsmQJ7666DIEmFBrQd#qeTv4cFbmjGcqYPVmpvFRS" +
		"5MwNDImrE3KoDJkwKEJUsf$vWxBQAkiZOrJD2IwWvCvh2lKxkcHgEb2Um4j1FKvzdwYQbZj" +
		"8lXvQJP9kYbxSoFzIxm5BRGBxByqTJHTag$ngP5RO4It#gRwctra$Kr#W#wcL9JHQdAL6sg" +
		"LMgzLFlKXgbDKvrIMwUsI$NMxmGdvgHEXNNe9bBfDcfrkZfr2ZFqJfZnCtqUBzN7enzR8bK" +
		"EpMh1MsDElbfxEq7FdQMVgv#TcgPUe5yYKdmz$GGsDxqUtqfFyQtvjdmRm9shBrIVultPBO" +
		"9MG1Qq6cmJFeJl38dfmXQoBVYkOTXyTujQqBeGvPBHUWlVa##DycLi5Ll53#C7yt6OZytcH" +
		"#cT#B5i8P$2J#7JeTajYPE3M3ysGB#BtvfWj9sfjdFdFSOr$7Rz1EEAO3tZAZRJk9BrKx$J" +
		"tnFUDh$Fk9g$Y9cSMAkUnLzNgzKrR11$IsaEBDuGCmJ#FwLCtSYcLQmcg1ig5U6zEANAsej" +
		"JgfNrn5wSKgkqTlU0bFzbcRNKAcqHsc7cjJ21bzH1sKJP2EKtbNi0csFc5RzhKwjihNHLkY" +
		"YN1cOjuRquy4JffMn7lAzLXCMOfVIHF9a92zbF6Qo$8RYc3CJJ7H66A8UgBPJXwgtWoTW8d" +
		"XnE#vFWckJ9aShHoNcYJ5IEKqvGfYhBbHCJyEHavLHb1ZpKioLFpW9FpepT5vcbdAUSgroe" +
		"F9o89$ELoooUA5SejoXNWYUF2vue2vMxbFkK1$Ktb7yhJoeFAOyfJojBbIsL5y6JvvHNm9F" +
		"N8dZo1id9M#gdaYUhbHKvyEGpvQlwpvKruCaF2NIYi$XJwX44Jz8PvMGUF1BuXyeJINW2Er" +
		"H6SZAFpUEjzLdgnfQSg9kgcwjRMdAYTbQtKdiZ356sL5lKlwJkZbdiw31FwbyZERdIaXFrO" +
		"FMWv3nH3n0ufAShozN34l1aNlfKimEVRkuaLycEoSGJzLZr1FLuzKHbILQUdAHEKqzHxLMw" +
		"vBXFLyzGhrBFWjw7zejZwvojpfBzkLovMprFdH23#nprGlZ$boh$2U0#YeaTXbhr6lL6zMP" +
		"u2RNAVw7RkogxARihUoYZSy3zClLkzKxrxYZSe$QwpI$Jd8tZHmZSZNhbRkENEDoD7zdQD5" +
		"CFKfu9uFwqkbHzNdrH$L3zc2rKFm7UpwhVv8ExLg8rX$$TCYdkMckj7N2VA6LcXNAtrZ4ET" +
		"sqZmDqSPGAsHUkiTTMsqhPH3#AdAAkr$jeWPPmsC2$SXsX3jPsr4ObntqKR1ToF5xXhkmFt" +
		"qR6uxybFqVRN3WZAZ3P66wiTeXsg7Q4ThXsb7QCThKv2l#U3#$7QP6sIDYKnxjEqKu7xYHB" +
		"tau7xQR7ola8xGpjBcnEqNze5uFiyzMvjldQLTfbshNQ5SfHsNLwuBz1kqXxJRacAEp2w3R" +
		"XFbRZV2zplZ#Nxmv3h5P2PWBmB6TVUq5xLdamlqfxHNjRUKgTg7VF2VPds3bkeVQWirrPfQ" +
		"xJlj6#r7xIVjLzrhlrUlyhlEx65wIjrNLVr8hsPN1Nj3njP6eUxNYryf$IOa8qKgwjBzTRQ" +
		"SVfw#lhw1lf6ol7vsHbzS#qxVGkzix9SBmtDKRSEugvlmsgrU$NkUX#vWr0Bt0V4uZvO#dq" +
		"xAY#5STU7G6OkLU$Mzz7t0vGf2FdW3lzB7wiV2jn3OvD#H7sz7$lwtrD3zEFqK$JZ9D#dmq" +
		"PsZxMHtJ3gYNsKj$suw#S9xDbS$OBKjle5#XNwrSff#bNvu6vqrM$GRz9locLiGla7xB59l" +
		"pEMx$$HdzAVqUUeUmRulgl#dBv4Vr5$INz5VrtzHdzDFT$euk8kPYZ6WMA6OXp0Dj5AKWED" +
		"$VGk#ZkOZRthpC8eDlRNFzG$ClRLFrDRw2lrBvBDK9pPT9d#ALjeRAEVeN#bhpAsrh$LE#d" +
		"VOxQqLf#d$sJDnlHtKdtr3rEAEZBLByKIp3qrQnQMAjOlb74pp52sChPCLQNgzFcfcbJhL8" +
		"zKcrHpPNggRMe3U5ddfqQaEgeZKjrJ6wKsItLETT5dfROINbQgQsXDeASzGqbjd#g3UVOEO" +
		"IyhjPFbPQLsIUqkl2o#NcgVvDAGsfUTW5do$ihoLBS4j1w6iaUn4r9on4oT3cau9yxBIard" +
		"yWffOPJdURueILwMlFHPk1UUPt2rrxamGnN$DqG8yOGnUeCMbto3Kbp9PstYMWZCbxC4$Uz" +
		"Y92qJoyGJf#JR$pYUnCzGRDo3LkFFu4cojpjtOxkpSMnljfnXz6NlyqviQ2uyiI$zp1pRs$" +
		"KlmXCcUV9CNZnPdMDxeyCySQYKF97hNqoCBiZQX5hfWdzR8APHnOF0J9j3OgQRw#WYtonW#" +
		"ao7cavekGBnF05PRsb1bojKOayuaIPPgtq2CZz1GZyXtnxXdTbJx7QXnUmSDftju4ZDki5Z" +
		"sdiItd7gDiI7FcgNvBw5OoaYB8k#YTqhFc$GAh#dSZh#duamAiwoG3kUHr7nBfUqNavFCNM" +
		"Dz6IBaIe1X5ryFgoh9ncqGztCjg9gLvy8vqDvhAO2Uj$WqoIKExL3sg7FSPvjecwXZ0EK22" +
		"yowsg5$SRvSfBqCnoet#d$aZB$AmjSi4W9UYtXo2NuTaH#kEilUoGkV0LaJR$NQIy9tyLxD" +
		"M4hBNntmO6D75X7vOUxHsQ2t0NV8#bfUBuVsz2uMtptlL6NCzzvip3VUGkBx#w5sMfUk6kp" +
		"9HSkLfRNEzgftIt6MH$utmESRo5mLpVCYFi3RA4w5AD2YQXH$pfLlOHWNqRt2m1XYXTtTmn" +
		"FDCwAlJTSl6MqZ3XNxkz3sAE8s4Ti25bOACPhXuFslhjTFgiiP1#l7LYdDOWSOrof$oYUeH" +
		"Yl4#Dkou9rPPI5YzNl$BAGwYvbWLdwJbVqk29aOM42VSzT5cpynJvijqpusrUgkyJObULuh" +
		"5rP85cEz$pa#BCm7rd6B9XP#ESmdjpYamUhrnU59S4lo$ez2JqOiYdw7JvOrMulws$W$lne" +
		"sz1u$htj$J7fJVARq5OI$puTpek$1FLHlMnHR$5JK1#ezSTJVtT2wd$v6rBVNxONH$q3oY5" +
		"aqJhhQVbcoIJb964Hv7MPCbx62wnRPGA2VBD4#Hem1qPuhpHZyyvtcJEwIHZYBHdx2lWKsI" +
		"o2LScPiS6da125vsEz9GDQ#FhmAJ2NZAV5MWyCqYBxVxwDc3xRqsNNk$CIYnRzQvSMtawhq" +
		"2hqN$M5WOvEG0jlpmB#h9yMgr#2jC2UkVqYvqxA17sHhr$8dqrjAzxsuHl8MlTOjFXm3FGB" +
		"sMMB0$T923mfBLP$va8BsMKVBQ0ZA6EI5gq2j2pqq46qfBR9HajApxrV96O1MZ1YPA45c2M" +
		"YHVIB$DyYG4klE5hiTChLgCIqvDulL2SaOz6qwArOy1Aq3CX6I#Xg0hIuypylBPxhBqIBTj" +
		"pVY9PBxKQS5S5ajApZ#2BNfRpZYtYZTALdVB5#IMBJyeX52uqlYpEEB$$DcPQy#iMXXUd$Z" +
		"g35so$vqxBqp#uNzMYC#$FTVb5FLcUujAWJlRIeapFIylwVJOjyo$$J1f6nUW$sZQlxlilV" +
		"Bp8hOxzOjr7z4dFzARGaqnUg5T4l1LeAj6IXfK7cke5z7ekMnkAI$$fZk1Iur3xu9osDtEV" +
		"9tzBuU$mFfa$TzkzfDGkq56Wfq5AWvQzEIy9Ph5KhOcMn2T4IzZAEoU9bz8xoCXp0VTZsH4" +
		"ilndZVHl5Y6iipIdJn7TQrVJuWM$lgrawgQqDGosy09BcUo7l6m6oONcUYrzdHKNpJdBqat" +
		"niu4oAA7lbdu1TpHU4thOdZzqWJn#y$JHo$nKqRFnvb0HiGlqYhtPJe7vQpJTmbqchdH1Fl" +
		"qwWqxTR4UJwcQUEdb3Tn$6gQE7wjcZX#KUyzDoNyDcpY#6tMnF7RfedZrwE9uzUxYUCte8d" +
		"ZjzC$swVIelediq$rmhhxLEg1ZKfJ8$VfEkCtiedZjqSJnw$nLgyQ1h#3cpX#X$q1#3dl0Q" +
		"NsidyBbXY$2VRx4DxVWY5jdRFCz3OeynhRd5dlmKNywiovDj9wojXvAxF#6tqNcTYORSesK" +
		"wipj5Iijb37exLDzRR8wkW2LPVPANqQmYJdGLks8IkJ#LFf#GJz6BqJQytQiFLO1wUSdpUv" +
		"$lvIOgmVhX#PbJUPEEFmndv7L#iaUJ$HvetyRia6yZtc46SGFqcy4EynTtH#4v2PDop86qI" +
		"PUMDVINbayUQe1Bm9j1RWa2qtDbNkUymMRpojoUSHhQaYNPHORdBcZM90YwyWx0zaP$ENnM" +
		"yV#2lyLRyMypGtbMOMjlnE$UZ4lB5mjdwRwRrikLd3WfUNDtRzJ6#tTtH$hvOtRnhGagNsq" +
		"uyCMx9ClysqBtuN$lK8ySDRuYV#7V#CVyZVuSluc$mr$a9ioOMAfkZSu7VmVxadR$EJy$Yb" +
		"LcRvt1jX73tVbMgigrztPAPnGLdLiEEEUaIkuwBxEq3bek0pPPgmPTfBbYrJzrftRYYd91d" +
		"5a$mYHRcruJX7jYo8Is99K#WNJlzaIVF2LuSbiBsu#9rERxugOUv6iFUoEPA$hYklvzG3EU" +
		"yiAb#6TXPVKXjvjmuyzbpeWPXBsjwCLzZsggTBcES4UY1WUnkJEksf89Pgr3aZ3TQY$XWxM" +
		"fn2Kl#ElrLn2eazbgCCiyhesqMLIVBRyoHbz4SZEYbufaIICkT4b0bS$ZBnlqNDLCRb2oXO" +
		"d8rtWVORcNVIFulaNS0$Y#5TfZRrSxpd2UJ7kyQKQOpc6VopmA#LMMhK7p4hJpAQ0vS6Ms5" +
		"nPYP#N7esCgsdDpBy1lHtek3piMmcFzK$sYPwksOQmH1V8WjVFuWlzJGgthVuslifIhQYBx" +
		"u9#qOcVcG$PoZbUj1h6fcIUnlPUzYvaU4tyXgQSamZmv$SoF3FQMJubpSo$CQMpmSQ6VwZZ" +
		"Gp$gKQ6$q8Zm$#caU5$txZmrK6D3B#Hzz3KHjvZKezhPFXJ6Xd#gOqC$zo6Wc$FV0BpsrUS" +
		"sL7cNGXvPPY5Y5q8QtOKiGkXLVdX99arHcCGW1CrUcNo3$VwOsS#c45isOZmZsqysFp$6X7" +
		"smuq8#z#D2FknHeJztqQ4$KGZmdwo4M4$tOYmdsr4s4iQ4VRIW9tEpVxjczEElVSAZWxUdL" +
		"TvJbqzdGFgx2uwlxTYrhx3WfXMExgjkhkBWKliBehVMpcjwdBLoBFpwkvf9lkz5UttYX7HQ" +
		"PL#h#oCYCwUfds5McsP#9nFzxTZVaxMnL0ihYZC1ITRnd2IgHWHrIBx56iVvfurKDnvMequ" +
		"NpMM9dMLimRwWQpxHHZfBArd7UN3hUldH9#SwhjyN8qyvqtW5LnTjV7Ae1NWg4WN9J$HDRR" +
		"r6AweNpK2LoAykHou8ixTNHF93#7DlUwkrpSULrZ3oqgaXnkxNXviFSCRI1PFyl17zq$aZ#" +
		"Rrwqc7wZxyjaQ0UNy3miJumIvdVPGHQZUrkzE6T$mGrmAdnxPddaiDsEZOo$czRiGvzTuhs" +
		"$WHFqyIuySUR4ysXXtYdkGKk1AElzQ9GPvwplX19mPX91IdKidBuXykteDl5pd#Yck13O7t" +
		"ys4K#UPJuABnLtT#ySnQwLUoy9jFJ7yulzyxoyl3F$Q0kWExlFv$mAcRfqGqJRupZYKTOPc" +
		"8FYz4oaI2CuvpfiavFzn7a#WdUTfeDzNrda8qYJEEmvPDtJ1asJBGbE3AGfDzHZVhNFyUsq" +
		"I$LTpHbnwyD0NfbXwIU1SppgvwuBvBNv0eixyWOTEaT$B2r5jwuSgiPEyPYdSylRhHsu5x2" +
		"S4DwaR2znS3vwKs6Cz3SDqh94SIZx#bRcIYwU#j6upajVuJvxxCmuVh1H#a32#Gz#XRFNm2" +
		"VUBpwnkXRu6Hv$nwNz$QD3cZRqJV9Znj$dhVw2cXwzzu#nQZxoKq#ePFIKzoeknPrkZhdZO" +
		"leVlxzk8GzGcX#$b5gUlZEUPSOOubFPtVhmqsTBysnFeBoMdoy2kAOz5NNYUMvimno#zQ4E" +
		"sz1myT$kCuvhkQACUyb$zCPD$Lg1oByTaRb6D#dpqraEN8CVBP5x3GvJz9rhaYECQSCIgre" +
		"mKzPNdhUSkOnsTd#gjHTWm#UvuSYy3$#W3q#1wthk1vh1vO4PoslbRXmhBUxmb#1q2ytvC4" +
		"$sXl82nFsM25t##nyG$oudhvVe$0NxpVGxpmdLSlxlinkQwcYpU1rsJbHP5S4mtoLLp5h1a" +
		"hJO2$omlXXpHV9rw4hrXUoAUDAHV1woyl5rpwnWMvACX5G2xac$5$l5oa3cGD81UfOn6SjS" +
		"NKGQangODJXuHWNU$EUyLLR#yzn8ymMWIDB2iilyJ4Nt#anCHVwyYbYB57NbAMhlUkddZQT" +
		"BdKz6HfQkF8KcgAZAAip$KP$CA$kFLXtx7l4tWhyjB7#M05UV6t79KAl2Zm8bzUX5huY$4Y" +
		"12kRvnPzPUD5TbX$xZYS4o#QZbmqp6Wh5ivI1zWWCeoswxvNFD1PNmXoXqLnEiiLn#c$YlT" +
		"NqC0m$WLU57WHXN#15mLUHE5Vu4M15r7u0vR254L9ASMim8k2N1Hu4SQ$m8i2BwBmB$2Ym8" +
		"ie$0kyAF0Y2ly2BmgyYCA$m8i2BwBmpyQB$DUPTo9U9BaQPhT#dTV4kNyNsrqPBwo95$Ibm" +
		"8iW$WLU57WHXN#15mLUHE5Vu4M15r7u$oFVz4XD#gFUzE1l5DxqYC2$e845NaJXN#15WHTH" +
		"#1TuKU155Fu5NXHu4OL$WHS5NaJXN#15WHTH#1TuKU155Fu5NXHu4OL$WHS5NaJXN#15uSt" +
		"pAFmBSb7WHHJ#$pnUB1I5zDqPg$zCexE3nLcJQdN4xejp1SvB3Lusp4drdsgVyOFuU3u1CC" +
		"lSxouBM7o6$npM29W1N2FEcYmBSbl0v8UmI$ZDylOoVW4$dy$nS3ixJ1SZzxnKS9lFvF9KS" +
		"duwFvEVoo$Y5$DB#MNy2duLluPVnnVm6vFqNEWCrZZ9iww$i#J5uzzex#7ng$zIx#4DZe2z" +
		"JdkW$Dfrglss9ZLMc#X5I7kJURwe7dLPcgsjrZBnB5ZdWc2ExllIhFfKwFp973IR9Jaf$Ui" +
		"4Q2xKFj5wwl9hvfPccn$Q$D0#rJxNnCa$9NRXr5YBJrv#fFQsdsfVkXPG#qheWkUh9pO$F7" +
		"P1ycC1dU0h#67poRQgIVW1NSZ49sq59HBfWZxQENlPuOVK1URz3d7SATJQoapVUz0#OfF4s" +
		"Sly87LdTJXLyOn8V0PAVf27T2yaox2yVhM#YmlFwYbnzZ964qQZ2QFH9CFub#7ivJ9lEJ6Q" +
		"oB4gqsYIlGVprURmA15nKK$bsyQLUTTyB##Q7mJrXgxeyJJ1D#bYBZ669B4W2VH6M908JA0" +
		"tZWN9TWbC5aeBuc2YVMLXebPhF#7Ez9LtzCPlcVMTFLzTybtwS7saFeBgPBVCmCI#anOaiM" +
		"NMFiwlvzdEilRAQEmjETQ7oPkSuUkZ0F#vFF7wC08TnqlJlD#FYPHGBUhxeKdQ$RZ1l9puD" +
		"vniR8MNio1HMydVbWg#dPKKMyQodSAVt3zDJdaSjkxrzwKyFqjzOGIswq9vvYj$Fppg6pis" +
		"jlb1l2JFUdbQHhuoptfHNqPEKk$RFEjDiqRkZ58dhWNoVoEEtEfosDtAR5BdVAE3rRzbWzR" +
		"kTjPDOhu2POstuM#agA#PxphfPPG8p1lKrzLNNHqHymRxHFcGDvfrl4rD4zwe$ojGtjKOSQ" +
		"AyvSlxJfItCRI#tHOxYblZRP9ljsd$Lj$mpXbassGLr5VKDRhdH4Tttc2TAA##HFdXxxMy4" +
		"FMLDk7B1ziAqXJ8o#7RXMvRVrGxVm9Dp$#TQAAwERGKRaUVawmbq9IRLJmumpmouvLpIsCR" +
		"w1k18$AgzNnUjTuBd9IS6uohs2UyMPXpl99zcWys$BoyQisEE2avzfBdj8jBd9GixgFF7dV" +
		"cYhmiBvpcoheREL2gkPuN7E31DsRfvFIXV4rEfPldXTTNUTNwEboBFw2yfxolVA1ywDPItb" +
		"6SCLnPdayTTTSiP2zKlmjcYJhIEt2jLS0tyleS2QoLz8t473$w2y08HTxLHgH7oYYdrLUg4" +
		"xh45u2LDoKkfVB#2tL4zc$lejnCxwgYEi83CgElvriRoUXJPbqRIU9JoalxCbSfvBbQkELy" +
		"bl0fFNnT5iIQyeLFAMWObdCBFqXQViovtezYfQh#rGXSt3q4Ag7LUfws42LipzatDbDfMyx" +
		"LbzKtB7WHdk4hjhIhBOIqXppnx5ASsov3zj8#RhXIJ3i5OS$6ygrRQ1sYvX51tiH$yJ6Htv" +
		"8ZzXxeqVj1WPxAK5gMj6brItjBHl363xUXUoh7aiJxXDBkxoc$j4V9IA14n1Ktryo9veRMX" +
		"upIdf3MVmmtj7i2DBYqhl5Gue7Y6mKZx9#hup7sBnTk9BdoXaAqXaTx#41n#cHRFjTBildX" +
		"Z0rhabY##182SkYxxrPB4L#K3rERV5uQoHEYAyBohV5I6xSBkMwjnxMTemVmKexb$zUGhVC" +
		"3SYn$MexbpyYn$5avblybn$A$vLY#FhVo2i#nl9fZ#Q8SovTOxvv5oArlX0az3OqmMKf4jT" +
		"14HnXtFa8sjP$5ZTHaKS2$JXtskEYi29TATuInpufWB7GUXUvxTqQkKxyPEYiYAoNc1mJDN" +
		"QSk0PGJn3Uuh3LnVRvzLeJ#iVTT6kPT4u$#ff#zAtow$hbrdphUzuQ6Akjtacj58GXSiRvJ" +
		"YnAd#RWJrHkXrIRzL7s6N6rAUYbHQqNrBqRxzzwr8lCTPwt8Xc3lAdnXlut4FEy640V5Txa" +
		"41m51S31cjObvrugGrbdW7HTnYLs5cA$hMhMuZDAqsXJ1mJJrcKV6G4Dwfdw6#qOLhu2CbU" +
		"XlMZGub7cam2yROhN9sY#nEUYHiG0D#dovCoBsIoxpvNUAeojCW$voLAxvNeWT9HueaWRlL" +
		"uDZvDjvJoUmxcF9jtUFnqUPsEEnzdpa7a$czGj6wpwvUO6nAog#hmP$QQtxM9TcsPulz8S5" +
		"HcIFuZ5AkWyONIu3pUegcsPjVOd95rbua$EEf8Vc3JEruC5aCuitMG0dmSI$fkPYicKYMXF" +
		"9Ii8h3fCJFBJ6bJcboM1xUW9ivpOPR2zFWEtrJGRRcptOoikskvuozoN2rdSbyLaoZLm#M8" +
		"I9#Rxsa8MjOtTBt9RedTBvTalwnyuk$fiissygF9VhisJVnRTRyjNt#2nH5jrqvbnEIoNwT" +
		"$eCgk5uqkPoA$QCIoKk5T8$ytb7efn$HaxK#iQbL0SzyCiGvuhqBkAeYBeYl8ipGuM4Tt5M" +
		"a5PxP9OqL7lzvB1tuL8MuPz5qn17MOJl6arhn5f3TT3prCUB$vRlcloTVC#gmWN1tF2Rdn6" +
		"NntVDsa$IysIXVSxCvzt5QodXxfd3k6Mbvqbp6EbvPhS7y#mvJBAotiklfQcJtFFkt3bCgZ" +
		"ogh0#Aez5sMPakZIeRVULIjgbSgPBiPPoorMm#kunTpgvWLxAhsDNi6dOjkuvTpnQm6zYDx" +
		"2PsCxk5tSfkmypuTiwX2s9eMCHIl8WVmO$aHx47s8EiYAq4b4VOlzcZx349vN7s15lCsh2d" +
		"KFuPzYnxZf$6deTDU86zo5wIykH$9x4V#nzRpbFiNVOUUvzzm3va7x6FsGhKBeBCbJYm1x7" +
		"1R3LQMymgsK1WqPwjPNNG6BJ0VfMh6dkmqMnFjXVRc#t3EDkGRSGsPfkmJTbcR7Es1Ul4cx" +
		"CjsLPiQpOLhNLbtG0$EVtjUJ5JOICMIJnsv9lmJINzPRoMTxPnvDkmlXRzV3lGNsJHZxpd#" +
		"SwnzBSHzBE94VJFX1qxXyrYvxBpsFbiDfi3#iUniQ1$2Puk9Ve5ZqBqyz4PwEy0xWZwjPpx" +
		"lmZqwxx#BvESiEdlp7IYVnlGtyRj$mpq3v7qLoQaVoLmhyH$3JnO2nxyXFj#4VItZwUVRsd" +
		"rF$xdqF#ih#J18jHH8455w5L1$z7ic2Zvb$rFyWy#PA9VbVI7vPz7qW$PW$HB6GJzHQ0$EG" +
		"tDqSeaTW9e47tvAoGd9McOYBZ8eQ4lgo8ThWCDAua63JgSoam3xnYYeHVRdlLaRS3fGGxyr" +
		"P1WEpqGD7G03OiJKf423U9jKqi7zmIaOzbnx7X$RNv8SfwmmzZXaWUBGAa22elbMVuFylwI" +
		"1xPSduyMBPxeu4cnsw$efSnwhKVoHF1VvR1YXFzgmF#P#fM39ol14ntydozBQgmxtuUieHY" +
		"3cyC7wiWga5F5glcXu4aTQy5QGfDQe$VMOstP#gmTnkaDm5i9dvUYhfydy$dMijUBvDssh0" +
		"TgzfIuzMPzGjPqFl5a6DkP3MSZs4Ys2nl5TWsLsvVjn$Pd1x03sK5i33kO7I8uoiP3rWIVK" +
		"z1SmRU1#FDZqoQ77liLlMxrs7msZrtCBc6NodlDssE0QFVOClJO8EgnNz5ZRU9w3F8aUkoY" +
		"O8z1deIMMphdzXX7ZrdfGUYnatBJH5udxIPf8kocfObBO3UNEb9tW4yJ1tb6am6nKZSbHXD" +
		"LODSJhQGWGm8xGOkmfcs8XbeQJNAn9lFP4Un8jWZQBSegi2E21ejFTZ$C1vyi6WQnftXF6X" +
		"7QP#e7ieX54HPHbTeWg72jYON$OgazQp5A$uHHMcY3fJdz8ND#pT6WEIcfEJMEvlI5vfneQ" +
		"mxQ4PgZGP#MCGqG#mBYhu0WP3WeyT0Ss7f7StXVDesTB7TTfhCPx3HsEZj3xhtahZb2viO3" +
		"1z7g4k2qb5qO6h45fvDhZYQrU02ahhrFSqJ$kFP$8ZDf3DiBKjUNUgm4FLOKssEJPO$nK8$" +
		"rTQ3QyMBqsCy##tzeJb9NnxgZdMMWGNW0Oy4LLTAG2lWXGpn#o3ZF6ARcF0xRtfu9QZfYAj" +
		"GPxQyMiWNOARGZxBKA6cnvImNaRJxahOsGDqcR9MyJMMjOVrlUfAL6lmHbmXwREAn$Ny3k2" +
		"pX2tlQ2l0t2dP2tGnjCtWJEuz42MkKdyYdy9CZzfI4xFIG7ULj6zW0#OqZUAZsMUXLP20uB" +
		"qTypjiRE6NY$Q7dZO$Z1qlABKNG9hDjIj2paJUW9ZQtym9paJPTsPGbeMCfB#OLIAwtHPgB" +
		"72XNPEeDUUGeIwkfClBnPVcz9IDwg0KlWgm7R5EmI5pG0bawMhY#DDXdaZTS4vAqIS2Q6x5" +
		"kSlFMLC2r$LtW6Aki9dr$A6zff87cJqCc#mPiMMEeXly3ohfFAc$HIy7yHA0ZAc#hqbU2js" +
		"rSL96$5wAkLMUIjJPHja66YdUAkl5N2wyfTtje3rgy8Y#J$9GXB9GtBs4I#PGGDArrvGozd" +
		"bxUmZUR0MPFoRC8hB9KyNotnX1H0xeeWRoNnyiRRW8Uwb3U1foDlq6JR4prFojkKI7aJyn7" +
		"HeYuf62BbRI3aJMYoaBST6bZUvfEyzPKKBbidUPCpGFZHY#0x1EKjQarafMS#9UoR7jjNos" +
		"Bc3aNegnAkmpE4vuM#MeaWvAqDu0wIS#Er64Toa3TmMhUyE247i70wO0cg8Bi8herU5fOtM" +
		"9diydPIY8PwjB44s2uLFO8s#i9$MeqUaJuEh0pi6$nNLzvMHOodFGFsRJBismwEl6bItYR7" +
		"sZT1hyaxElQjhx1lQ4t8czfWuwcGxF70NhHgqIBQzTEo3BJqaxI8Pv8MOD#QxUJt3KAj5Jd" +
		"ongLNhB5wwAMWPGbuizIYXL$Dh#7NiXreD1Ty4gtCpqDtBfE#mK0FBQAV$BIqSMWHb5lziW" +
		"IqB7Le6Hj9YpkB4$qfwkgWIT1I0bfw4YsYhzh3P#$9Ba1V2Jf#1UmsUVIBg3iUK3FrYnRk5" +
		"$HLQyYbJSkX2MWH44LDuRCLGyQQaOpLIsg45TY9ru8QEQlZhVEWHTGS3twvj8YSE1bR1dwv" +
		"yvs#MMJCJukEylNaVtffMGAeKfDXYsgbdmnRaHSjEm3#UCmbNLgM8STFIubD2x#Ht#IXPPb" +
		"3Ivj8Mkez#bA2Fqss4AIb23E5UYOiO1jUQy7cFVEYPQNK5zsdB#DYzQMlqoz5Nbh0YoXQbZ" +
		"cqB44BIw5L61CSVHb7j5J3yjJZlsYTIqtHyjIN8dP1m8uf8Piypg5b5VwxTgnlm2R7qy8b5" +
		"QBFInmVeAU75ej$6agrbgFHAlpbJilsl3Te6UUXfJv4YwlxVVdUr2#h4j2YEhG06jVGabXT" +
		"4xICy$JBClm9EHDheYNmdiu5DNq1BNTQweM##Ff52z6oFUO2UqjQ9lCTFFsoAWijunnQLia" +
		"T7WtbnafQLeAM8eUMli9MWuOYK07EWIOT9VEXfIYaBtg0be7EFBh8rXVGr1fUI6OxLklj5y" +
		"UZ4RIC1IsBqPQb#ngeNiBtXKPfNBQEj9u7BHU4QD4aBMCzjEWEBRgZ#qAojG0jugcA$pexY" +
		"RVWBJtpQ4tgYovjkg15boEbBcaP1rz0ZA5pfTPBVvoVmdlaGOkeEvvVAMaP0lXpqPx0HfNh" +
		"YUCYT423xs$F4617WKKP#hB2yKTBd9GhO#sa1Up0EeRtR5XdshFgmhQHUrONmAES2wWzsOK" +
		"orKPoiWHj3e0zR8FUIx5MI0r5IcXMEocb0dPsQhzWNxAlc5ZDirBBs0I9cGhO6j#A2R$rHy" +
		"0T2khwafGIhV9f4MXLWOyM0TlkkNPo5oqPhIQW2##kf$Jo1ETtm7oi9xoG0RXJfIrP1ZztA" +
		"C4#4HoPWlbORG9Q$JC4qQSJ48BrT9I3x4bQHRbQUJV5slb3N87UFX5$Ah2eapE4oIZvb4Eh" +
		"A2UaE4ohIhHgyEC4hRfiA#ciHMXh4Mei0fmajFugUyVoZdJCMYR4pbgAf1PfeLbBU2zEbRZ" +
		"R$MfXP6bs9LfKPQjrn5qRNmqygUNzm9FQ29xen1F1DS6JcbnsQ56xHjgQHH7z6EP9YRGUnS" +
		"IJaemy4RRmWiGyAKMmU2BenHW7l0HFIkYlJc9PAtjSarBTJcBU0S$2F2aXdkZWchLdNP83J" +
		"qg8paNudyJJAQAUoYudVQK5w9kG9tqTxq3KMqPUHgNKBc5DfPpmyPZj5YEKe8GO0MfZTASa" +
		"82UMDKxAa$uIXzg4kYDA2dng94zgC$94GwbakcFBgiMJN6IyX6yDV1RbLATMuhueuufBYRJ" +
		"BAqEuFo#vAvw8Fo4VN#F#6xQ6VIlVm4g#iZSRzSHOaXJtGIWjzhhjrQBu$R8sigmQzGODtn" +
		"8IfSEBizh#6YDO7hZBcSOugKV9wgn2MHltSS1Tos1RniaGn5tQI$ZGOfJJfDP$ZNBvu2xy9" +
		"2xjOh8wehoDkvP5PfR9qc7SIyZssV$pb1aQYrObnbtry5tBoFTnD2e5SHUslhUK#LLugahS" +
		"jJpvha7waikCcDybuxikPr1XcL79MwwbFpLlt5NCAbHepYBBBl2nIAlIKfU4nX#LnXWLin6" +
		"nAZemuqvfiRJQnI7SvHui#FMKV3Ea1ktdBpC2Ns5dYa9lHUqGmbsLKY1icxLoz3nmYzi56P" +
		"W1Ty6VfoJVLaeRMPGNxYkbfOt47Iq4ts4fvbUmgS1#gZDUPv8Pwtsj8ExMkdPVp2kUGj3uz" +
		"kjWPox0V6HkJcEJA6#FJHV4uYxsCfUWP7XiudBLV8d4UudKLI$krjmp9Nku17FRxeZBKBu2" +
		"$eQDeHsBtSOw2QUTh9LiXcBFfdjAtT35#r6086pM03bRqkGEh3KRutooMENX6$6f4NkFOSz" +
		"3ercO7Lip56klwaSPTyV$t$W8cIFsuqy1z3qmJzNep$R6m$wmvinGT4bhb9UbEpCKJTAwB2" +
		"SlgqZE0OG5kJ2HDovMwUOZ5jAWPlIoL5DUoJnFMLBIIhNA40HF0ZYPpiNQoVyT448yGPxaY" +
		"Im1diWuCKzaQM3F5Y5avOa78$04$pFmn2bPu4cJv4aEUcEV9QhIMQ8vyCJ1R4BExVqbU89w" +
		"VofF75YMxPGS4gCB$fTuEOH0BNdQdszpIBQUw#Y2aHjr5plG1Y0iGLWgTMse1Lr2HaYcIJI" +
		"g29$0WfuxXzmUkO$TBxNu$zX3x667G#i4ppGnqvNm73xyX$qtDyiYkH9XMVZMTgzueVaj2q" +
		"AiPQ6#j$Wcw2OCaQgqtXD0wYa4dm$haOOCsi6xs5QKR#kJu3meZzTKG1yVaf84b3kmmnPZh" +
		"WDv7h#OVOqo#NYHTbyledPScHVU7CbyGBSha$HQif5BflF4dRTq9Ivy1MMDJN2U994ueQTX" +
		"daFM98IdrXLtLsP2UDD8445H4#5xFEwDpNTFA$dAk$HcCOeiOiKEB1f5FD1$3hJMJlh97JB" +
		"oNR5wZjV96i4HgehkwqAuksDuab5aMzP3bET3esN4mJZdlJTd515xRmqkn$RUMt9Po3vUhw" +
		"ii#76NuugUWQCvoB4j2rG#eopuLbqW2vXFTg3dbGw4o765tfNDxldblWzB#4jPk30J$Ww6G" +
		"#H$HvRZiNPbmPRb39wV77$oakKBPVsSP9dvvC6wU4c49FXacRT9xi78ybrzi2eylPp9DZIc" +
		"Vo#zFzFr9XFvz#6y#4lw4X6zR55F$AmBrIfG$uTIB#COwbsBneemSt7UBA6dLQnQnaG5Qur" +
		"0RvOWjK74Y6xZwvdlkgERJFTcVPnqqAV8OX6ebZrZa$C6nEF98bXloSWLS66TusYX6Lk05l" +
		"diHmUptpmzTgaxBo7hlDYbXVqiLrMN1ltf9BG8doBGnpvQh7u9qiAyj5XpfzQynDSlZZyht" +
		"lQnV0hUngB5XsEWNxpp0ikUyHv9QGdtPpPQMB1VnFlY9I4PaxI0mqzPc5bqsBJmxjbeyTlb" +
		"PBIm25fuIJPQU9jaj9Wqp#1Taz9Yf$EX9VT#CIFw9KBtGtEct6W9rMgoj7Zk2hJyoRGuRII" +
		"YfMcFBxdHab#$k1QTTmlJag1V6eMMlrE$D6rQd7IZwdwWLeuoHlSHjCJ0Bz1IeENlI4i3pN" +
		"Mz#pmMBOt5fG0TVmYNWlcyYqcpMB7Fapzz$Xx$e#dZb$mj9Rf0Iu6M0Yq5MWgqD1rQSd#7Q" +
		"b7qYZh1TRsC9$7$wSRmOXhBCqfsyQtM#GsSKTdQ5ruCfRPjg5L$2oQVcn$CPBsEbEprIBvv" +
		"QFB8uJlXakoJFmE$wAk0Nm6$Vnv#Vp$wyx7QVffigzrqQ6hgF2$WLy2lW5y1lm9#1VmA#Ft" +
		"zw2$uL0Ny2lWLyCk4NzHlmNB0Zzw7C4tVEvVUtu8zOxsNdRabSMQiZ5KdfzXwtvrzoZvZdx" +
		"EAJ2snThAb3gmZ$XikLEv0uyK8pPox2bx9UifKBUMqugtP0BuURylNv#qS7FpSp$7tbnR6V" +
		"4U#KpRUPEu3XpVqZgxzsnc7D$9KBbEynnpJZhmNQzk6$Pk0pBoXb8St#9#HDqvkGXubvqsc" +
		"rbpUEFVEUymMRxojoLHyQmdb9dVUi1zoqM8BMxOeEM#epT3lrHovgJG3bvStJbw6jziXDyx" +
		"lVFBbJKDQCicRi2NByDjC1ylzeYsPfyG4VZG$Xa$an$BZ#F5y4ZyXjkJf$0n#9Z#Bp#Hdhz" +
		"iljPB89pr$dk9rv2PR$KVwmdoZNCT5ztU0uTxYmuKjuxjOjepllkxSu7sIZEA9Vf7oJiDnZ" +
		"dwHad$F4EV#sPAMc#tryuiFb$zteRlTS#M8GxCBiKykFP37ZAzF16zM$v5UBj$8ZBc4xSry" +
		"XMrlT0$aQtiRneS7ZnknHSOXi#ATui1lOEctH7ACPTmQxvdkjuvscII$FKzKPaYuZq8UNf8" +
		"o2NwdvoyJ$rlKJ6LSlg2N5cJZNG1Q8$DEjXd9Exz$5iUxZFxP1D$liFFZNMFAT4Kc$yp$Q#" +
		"M67KF3kDWQdMGqRqXSdDdR7xpg#C#3RygtQmY6CzhwUjNwKiyVDce4px78TF4oNYxZAbwTe" +
		"PJpbXhVkEdrG05#0Nu1VW5#0Nu1VW5#Ku7lp7o2yEsPJuATeFXPYFrL0ZDsNSC79y6iCHg3" +
		"G9s6EFFpBz9$KV0Bi0km2x3$qR1pRIc77Nll5JetmRFpIgSWq8gQlRle$jxAjFOqww9RPOR" +
		"RghkxwB$aZhquoSbfbRUI$vsTLtTFC#693hJVAt#9R9#jJhzNjaT4Tq$JmIFGAjy$wJcVdZ" +
		"CNVPpafqPJB4j6dNKaJYhQFvgJelym8ZuJTNQfTmqKU7jQZHWHuqVv7soQs2#oxkyHM6TiF" +
		"Vie7t7Yv8JearDzjVnw47NEMzGAhEtxP7gxP0B9P$8JNMDQZ#CA#w7XkHBbpINdYjJNocX#" +
		"a9L8i2wzRbnfU5c9UMSbPhqyn9MiblFFyaVDc3CK2Ti6$4Lcuy2ayKF0BFAV1opZq3cdp3c" +
		"7JTvrC1DTxkzrRRnZocKxvpHsdYH$hok#77qKv23op6upsRj8ufHZUMAGfvuxViWJW#HNrk" +
		"d48D#faCLHuw#Cu$WN#UQJ$xB7N#xe4s$5UuNVV4BEuFn#xomnyVBFyId4RxYT4f4qHRpx5" +
		"9A9wFD2B9b8y4s2d6boUYHCKwNLJ$4q2TiQWLE7q1vZ1fgoNrdbt3wZs$ggwmGRLrRXfIa4" +
		"bNRpMCTOk#g3AzCztRE$BPh4bnuyC8TwuSeuqNk6uXtFW6uCyFAS3GtgHkBt5ttdfJOWpmD" +
		"mFJL3ScJHv2dnjz6DJ3JzlNN33CobB1bsvFLIEPSQuErR5Zg1FldvzGtVjn8Zz$pwa2sNPU" +
		"pHCw9lavqsB$hMy#qH2$fYttaSI#33BlL3JzgtiWoDlfxJviNiqzUtR8Ty92VCBqfT6iynf" +
		"tIOOmbFvm#SN4BG$TgGmLz8J9DNviCSYxxoEx4qLuxHYQLrPgBrwJ#EOxvMcYZ7VC#JdbVR" +
		"m1oBzjaRbcD#drsSYPmZnwnJFaDdo9l9Jlcql$PWVrjaiWMTJysFOmuTdZamxnLbn$ZWV3a" +
		"Mnj$FiKmzJlVHS$8OJbjVg$3OFqj6#mNA2QrEOkKZlO6mF6MLpT3xFOxq1tZ1BXNlzmZynV" +
		"izZjVfiKZoVh7rVezu4vXld8qNrffefDJPCy74l61fjCWy47BcHGGMiRoGJnjHBaAO5EJ2A" +
		"bEG2t#vWbnOPVuakU2OaV8DRHXyCxuvtu9t2iBodeihxptVGv9nI6Buo32DL2O3BB$4n478" +
		"XKkXcWsWFN6mSkLIM9OeViOCdKJib76uz4#JfSXTbKlZ$S9$XlMX#1alh20lcgxrISeB#JG" +
		"7xIdmei2BJBm8jV0NuqKGLZRFBVhAneliiFxSSJWtNlpTv2BnQDiGUyMqlX3a3iKD8dN14J" +
		"i3XB#GrEN7Yx#d1XPuKU15WHS5NXHuKU15WHS5NXHuKU15WHS5NXHuKU15WHS5NXHuKU15W" +
		"HT$LLwiqphpfGtrTdY6cjwt2HjiJPnWkxyGAgo95$Ibm8i2BmgyAF2Ym8i2BmgyABpfiOwy" +
		"ABpfyLUGklnuyVVKm08l2hmeyAB0Ym8l2hmeyAB0Ym8l2hmeyAB0Ym8l2hmeyAB0Ym8l2hm" +
		"eyAB0Ym8l2hneohpmVE#zs7TEIUYiIU#EYV#yr10MzlcLN9vVANxNdWBzFJtVNHPdB5O6pc" +
		"4DmGpX6Zfh4Z03t9RdL$P5Q$taNHKRn0Qp7LrkPuVfWUL#xrtq77WXqqUpOzX4TYmxZXtF9" +
		"h4Js6Hs8fl2Jc9Ja$HSw6pN6CcZftzZoOl7l$0UddV7CW1x7VT0rx6sOoqy63cdAyVo8wEr" +
		"YAdJCvGJEBKvTFva3ffjvl2jyenOglAaTCaFEfcMsVnmzj9BdDBbT0grXn#ibVFKSFEv6Zp" +
		"Hn7jIhwKBraczDf$SatgTKwWJy4FQXGnyulGbhMIwm0$osX$tf5vvL#dF3$EIJpSpVE#1py" +
		"5e8iuCbgC9GVAEI83FhylZopYg8zt5Ra$P4YtjJr$JEGFI6aqoINI6ivTz4Ytjmu0ieqdsy" +
		"IzlRGxpFtnH3#PlCVwCcZ4d0L7i6mEJV9CkXZD2Rv9yQo79U2eiI0WJEOOuNntAWetudeeg" +
		"BOY32Io8zNsPYh0jyxpBxJ$ttlFLfK0B7aooMsRJyzK7OK6IMsPOa7Nu8hEm897OIpcsR5d" +
		"kyFauALdhzALe7pQEbyOlykH6IYY$8MzDQ20l9$uD9njRwUKqyDjIqUVhhuj$wa18FZDAJ7" +
		"aSjly4olFNYo2swq9vvcjT$F1OcFdxuOLwqVMoIfsCcyZ8xLqtyU9ghPkOCL#1iiVR45O6S" +
		"zwXTRuN69WtoAyakICtvWtsYV91RpI1txYT$7gDxojGtb5Sd2XFSt7FYVBEK#lRRR6ZEFcD" +
		"2RxTngVnauEzRfyepsUnIl4LA3zK#MIm$7yvvOVQuJT7VYDnWXdvHJWlJO6y7BvTwBRrHxL" +
		"Je6dTsygjfOXsvYPhgI6#t1UDPGZ7F#yRWNzUhRo$KklZdB3$VoGDePEIuoznKhACgtYrZ2" +
		"FzRUkSTfdQE3#SPDr13fIXV5Y#SFXX$F3azA7yZ9nAps#QCchZnnRbLUVvp5J3LeM#e2Zgo" +
		"DL6Ttqjk2xgyJcoMolwvadFJBwHQNg$2yOtaYLoMdsrwaHG#0EUZP2fN#J$t$aUsR#zA#fu" +
		"LnNv7Xw8YTTvC$kKsTP6ScZ7o6ELCX#vJVZbJHaFoQS5r1kNpuehSDF3k7Xs1wc4Lzg55CE" +
		"t9i$PEpOxfKdEXKzfmOlm36VPqixQIMaFUE89FEVSTXcom$DnmxFZQAq$XyTcoxTk9#j5Vf" +
		"lMnvluBpucyVfon3wgBtsvWPwABssLj6brItjBHl361xUXUohNaeHzGcdtzrH0sYDan5yYa" +
		"jinSyrSQ6vmVSWexSbe$UTm8pZQUsYjz6YF1ufNYgBidwlZqVOl5sx4Sx8Xe12jOHs73nId" +
		"JxRbS$bcyyDP8QbCv0F5bf2y3dptdLgA#A9yX7madfT6yiHU6GfpfT9BRLG9cRjEhSUsdQi" +
		"7a6FvFxVrGlc$MFaOJzS$meIUXaQOp2KYMsYg8upxBMFBfYucQscT5U5Rfuxmk0Bp7e#DyU" +
		"u9nvn7GNVsEhNlh8W4j59PTvrQh8bRPqLOQ#BiH#UiYDzCpxiqflThs37pEjeLRi5RMlTyf" +
		"7Tdcu#MPGR8lVNmxZnzfnRb$7jOKU$OX5QR#AvyDnT2zejV5RLMn6#9zk#zQqM2WzPQaGt1" +
		"tbNW6zXl8$6DFVYtSY6mTXA2U1ifTdVNNIj2UfWPysv0z5w85u9OAnAhJL4STAJ0bMFGm9Y" +
		"KOvk6mzWILaBVv6vbv$gam2SROhM9th#oFGHNnW8qi1yb3M95nBSN0jc8eIjCWv2nUCeyDS" +
		"Dl87c#6XmjtsRaUpfEhcUF9$06qeycxVb8tKcqVf6R5nY$ekB$Qh0frtseZhtkCrXgdaL3$" +
		"2vTmdt0cEzwPg2P$U3G$8l4vFVClCbzHz9BSwOMl9XOlCa2Dm4cWL4r8IOEhGtoxcGsJ5nQ" +
		"2zWMiFLAlLCkHsm3xINmMJADNBxIX0b69SBMjhjohAAMoAB$w9pMzLkcNVpuo$LPik$Ysot" +
		"vwdjybaYFnNqNWLfY9S9deHgk9ssFpEuxp2MU4RSYv1srCiCpyex1SKbwHxut2ftwiMyU9X" +
		"sNaex13cKLtbo7XWg$dnpqBZoKXVop60yfXhB8By96qXf1MKNGyxImj3pFvDBcyVXx1dF3R" +
		"tv6rFVuhjdwAMwVCyjvTx5QIbXwvZ1kMU5vsdCOwNdcC8T9LjQNvzDIxtbt$ZbCkAmFIgH6" +
		"ynPHPQElNCesbOkVaqjPnb9ddCx4TUhL#DUAiIcdCNRkneoTDr$anmN6#9q8QIlDfb9UbHK" +
		"FgsHCkOJIVQBhiw6Pu4VNKVvdnIKZa5vDwVl2vTInZ8t#B$2fOspFTX5jgyWVZ6Whn3SZFW" +
		"7nKiQqAiRssXVnFOZ11puByOU8lsTiRntnVCI7elp3Y6VZVbl4g$omzo4Ux7Ey9#zoYdycE" +
		"jPpd#sxFiNJtRpKGMZZUokj0xUTNqJUrbJtKie$4dLkelB0YGDl$fjrN$GBqezRwMA4uJqG" +
		"j$VZMVG4yi2d$S2BuffeVXTJc#nef9ztypb6WfBDYFyRKVo05JSRZj3QBRlVvi3vUSJdHRL" +
		"1y6jHvt64nGZBhRpXeAcqs2tJ$8ou#c5uPHtGXtjIUaF0UWNnCBe$4$Tfn8lf$cd6HXo1#2" +
		"FY2yhkTpTmtfsn$IlG3uyWHZyNduWO$QzkXlZHvBWSuEbh3Vm#O01WGTTAQf2#0NdN87uE$" +
		"RaB#d5HW8xFKEuiyFibnih18$LQnAsH$nFY8gjCUIUK#HBn4EjUFPZoXtdQtGXq0PQ#XfwD" +
		"0Pz7KHhjDdkG#i4d1#31sO3T3dXHNvUFHv#iH#azaIRReRJsr#DNulb3m6KFAjiD0JAeNu5" +
		"uD9gv7iy#pywxygaeQw1zrA#3lIc#2UakQ0zzM7uHmZpqtUM8BxRAbtvEz18lXdn6FDd2Ye" +
		"TDZcZZKl#zzWFo3aOOXxQkjV96OX0hHr#LBmZKlHNXDZm7JkMm6UMa0#Mm9Sr78duL0V9K$" +
		"WR2cu07FJfmKwlCP0trhaB#wzG6TAJyAYizxG8hJhsCzAS4yqOhtWNwb7gDiPDBYVVWoybZ" +
		"gSoxwEU1k3$NkY$kZ$I71EjSy1$jbS2EbPGXx0HSHbhF3hoBuZUi#23mExKbOjYKr2U8eGC" +
		"ben335fOSoDYOVeZ1$p7GqIBqwvXd41#0U1LYsAuMFImu1yCMg93FWuz7l0rYu5tI1$7Fm7" +
		"KYOuViZNWIufM8OUV6bY16sR6mRUNB45#86Fvb1V6xGa4eHG3#738zTWsUGt$6mSvNW9$Ze" +
		"ACLq9CK#chSrLQTSRzRyVWE59FCZh$DYWybFJfqIuhdKdo$5HzMGt4luZ5ay30XtxT0La1J" +
		"qNBGX76Z$7RamuQLtuMmYB73eLVbzo8yYFHab14y14s7GmxKIn3$XXYobeBjEM8$m85DFG9" +
		"D547kMZnXjSN0doC#GhsrZ1sPWfvM8puCyNg8vw0iwXxvDMBeLJF8nL5uNdGTOl2q26qLjq" +
		"Nw2WlMKRzOyOI8yN3238flzkSVhL6yXPjN0TjQiGda4F9GiHNbRO$G5tcmcnNzhJmTDaO1N" +
		"tPv2tcmUHLaZoiWKwDWJoj0SyNUb0UPqQOWVt#aZqCubl8X4wCUHIpwzKm$RYKV8m$ZSmNa" +
		"UfH8dqFjmbwcq3#xYZOX6nNN4QmRaNSuOept5Giexrye2rtT5VQt0drMGNfGWNxRTJNY#n3" +
		"k9XwSZpJq$UXxhFjsxmRvk2u1i24$xGTG#W76Ze4FLV4ayc1VAXvZR8CoUWPVu1ZeN0LetW" +
		"3ygO0yRK1ZPWLqzPZB4CFMT#X7UPyojXxiJWLaQ3V1ynyP6up#gu3yTRY5of1iL92kLC3c7" +
		"eCsAyiHg5qEdLNEG7Z5kYy3loeXRnCXOpfyhOvaZpf2VolR8soAPx15bLiWR9QPzcQtUT8O" +
		"6oixeoxwgnXzKqbwgSr5tX8y$m1vMxdbK$35ZiMON4c#oh7GkyekLheIEj5n6QMtmpE1So$" +
		"6DknBUHiWJJvKPKyy1oyh8SiRbL0Uz7iZaiLAsAtZkYE6d6$q5kL1njf2roft06#HLJaK$Z" +
		"DiJ#MkZ6tSsofJj3N6fQa1Uc5xIs6hIq5BSy1WeBToD$Tv4Vg#yd3tVZV8OkKHr2PiOoN6t" +
		"kFGbvMmePMdM$d7$HlfewaC#abx7#tqT65KdaanVFvPeANoF8IPLbu9yYh9RwY47Qg4tbIE" +
		"i#vdqHZHx6JadKHbe1ULfmRxCTS06DF3UIrtHZvivL3miF8nAlSVmW5#MoNPnahe$R0FmlM" +
		"7x4Gyd6x5G$$jQMzneFtp$VV7VGIR$9sLFhu$dZz9QTZSapfH#bdaOwmkHH#TsiO32tRgUD" +
		"ZYIkZdnYzJtki8WDciEUAFAG$zj3kDAPN$fHZZHkMNLdeMR65bFU33lbOAUGJDfT2fgcRGC" +
		"yXM5SR0Aenrcq3cgk3RJi9Sg0fZuIQmQrKO1pT5kIhezoJ8PHLaVbFOqoheuAPl8uPiJm9E" +
		"LNimjXbaeAetv5VSWzUxe$ag#BnJ8TzLn#0vzAyADdmIvX9Li3ER5rluLPrgnQV3TbR1rYg" +
		"$MlUSR50LoMCLncws4F55VXvNqVYgqTonr2u$ZsBovQgkyDHvm9F6#5RrVmZaiwQ0UvMdZr" +
		"jXV2w6RQiYsId#5cdFtALrUmyipE6gRg3q2mZmGwhGXmhDerWRUaPzivxW#LTM#jJZl7IvC" +
		"8jB0$Ul4N$W2vLEij8wTFTC#31Lt#06urxfnjGEvfbLxo6izSCe1QzdFUNUiz$HRxEYsc#C" +
		"WFztMF6Pc0jKG#whxlS$xmwSp#m8F6yc#Y1JPsAChyRuK0fPApt7BQjX73tpKZo3pQwYiUH" +
		"C#CxLyA7FX3zKBUJIzbdHZsT1dgi5tqb$geSX3#DBDUo4NabvvE$hr7wpLXJFSDkjnhYWxO" +
		"MOvZtDFg5y8ViOrwiX#zKZhBnIzCCUyBUgeGVLHr4vw802tQs6Bku1UrsDkL4rsTJIKv26F" +
		"xO7GZN6gUhBhFoIZs1FeDlD1#CPR6Orx6hrbLG7lcirnlRHu54rzAIQng7ccDzLexz7Opog" +
		"lWFXLceVVkLe#7dL6CEgRwSym6I2bvWVLcEkSDPCnB0$fU1ZyrOUsk43L7#5vvY$LiD7gAP" +
		"vHZLa$In1#w#eWxbtDNGzzHxXjpF5vEyqRq5rO9jcmWUlWGrglgkLLwDI3F#Tm$#kGP$LeC" +
		"nC#0Ori7tDmTlc#xhur43sQp2tdeavHWt6wEgLb8#vmioB4OE$pU4FrVI7$jHI#sHtcg#mu" +
		"hAXLZmJTge6u#vC#Dara8rgqjrYpDdE1fmQqUU$UzecFxHcFC8kLlg4VP0cNxH6f1rStNhQ" +
		"qVxx6kZm2JCGOmwqESRX4p7tgH6#ESQb6lXRDP2T6eonHId2Uo7LcqrjmhRNpA9qEjXUL41" +
		"vcjTD4RA8yQO6DhPcZfNN7VfGGxRrfD5K7lECvXZRQy3Jvj2Xceie7$FcdS6p6im7fy9$ge" +
		"5SD8Vjgrc06BQrXkPEDR2bpMbEMqE#OdEIKzrU#tk7dj$huhapR7GDrMkz5T8qPjV0pow3$" +
		"QY17rTCFbOP#OtDAIxRWSg#IEt0FjPyZl09vKEEosZDhEOBYZ56rc2UM2RwmzFNas63oWPQ" +
		"QGNpbZBC5sfvcA#r2hLDlbvjDSNh1yj61PJ3EDpyViGR0qPhWaLoMtOpbTd8Yal8TooZFgh" +
		"TX6B2Soxak1PzKmiViHRwMKioMWxOjV09ok4Vrs9UM0O$OJteUSsNy74ETN4PzeCLxupvGV" +
		"6$YJ#hg0tKgS2ShFOGkiTSirRCjwY$wyRwwHfy5fM3prmx1FVmGyl6ChQZq2lC1tQSwfPL5" +
		"lZhri2cj8OjguLDwWNxL0ivB8EVKWiVflKRICFcjRcGuAFSKCmTQp6ltRcl2sCApKTquj6f" +
		"eAa4zcqw$9pQjXx#TqCUnjTQsCnQ#EZJJ$FZKlOGO$r$yvIdDPTQMXDiFXfsxoJO2zYZCk1" +
		"nDdIb3FFwsW#Hdc2LsH4mok0lr0A7i$z5zJy2RIXJkmBFeFUriAsru54HO3213tmF1h#Y5d" +
		"ElMl2Z5d9S1xkqauhoiDTrEl8mrjJ1bcuhdXKnjlq4n1lWEUPVTHXJwugHDnqnU5U6EKCTy" +
		"QBkQuh5t0UoKRSvtQDlreUlNaVpflNHxdQOXnKB#D27dP0k0$$hu1lsXksj0y$QJKNSdUh3" +
		"Zao739QUJVSODrj01#jsi#vR8cmFNjHXN9yEsQi3x#fWOrjYNA$RX#f0FcTWZ2vhI$UmbNN" +
		"xKne#vGpKANk1xWy6$k1N7SqtwZ177mv$jOp6XBeZS8zvS1dfUXtcFvDXh#geN#gEWcs6lj" +
		"HDzFTv7VdhTO8sw6STZHzri15bho0#ZMG3jgZjhHvPGV#rHT$LdUV9WtzJzZQbQNofkm1um" +
		"0QNrz4zRF69aD$o5cuz3JQ#3kDp7SROLdXMjz2BOp10Rk2pfw3tPP2ZkaVT$3hGN$SCOBT1" +
		"eBbj7Qtlpw6rctCnBva3sPo3#Nqv#kOyoCLvq8kvw8kvqDawq5bkzy6owFPdLLZnhfYxxmc" +
		"PtAKY4xuYcAOvnQh3fbanf$5XqCukt27Dii596j3UDTIUi#y2Fe#CfcTR6hDwXso#bT#Izb" +
		"ZQjRJYFM#suicKVp3jDxMutegddc$5CyXFx4oujF3n4t39llP$pSqRHFgpas#jtCgR$XF1x" +
		"UJFLtgxwIrYzj46T7JJAOo3NFVKFyrJVqvKVUjPxstYdhbbYY1NnLj4Foi#89nNCiLDRmlz" +
		"QxO1wBiv7hvoYBNNebpjmUkGR7XbnbcznaF$U$vddJe7xa$rtxSaUpgLnj0PXrlnDhI#SFQ" +
		"uv7YSVOh$ViQPRdegsPLfv7DqU2XSV#Izi0dmgNcvy6SGGdjfcCCK1$F2PVG0ZRFkTzDpg#" +
		"BhAGlzzpEkzS1uCxvUcmFTT1dv66KFMt6xnFDNwFTWAquz4FsyqujkUXTQAogZzRBD1$ZBT" +
		"cuRh1$H7kPsHJJ7AgCrhyway$nBVzdYP#Zv$rcnFiTzDkfvArQEyDSvc$Pook2pRfboytlF" +
		"SzFy7ZTTHMD#sIDK3dErSinFgsPwoj2ygANORuBFKDtVVLPzdPik9x#xl1dXGl9zDlb4PzF" +
		"wnkdrLdm6ZMypY9OPdrZnQRJsR#yzdKpqs$jD7SbtF8dsNKwYlS39P3DFf7t4GmZE5YJ$wv" +
		"F$t9lsztVQtiOzAg0yxM$qsPtAZtUV3Q3vwG0Q8mVSIJ7DMGRIcjP0sgyQE9vYMeCQ#0J5t" +
		"rZn88$FsRDVD3w7NUccJzpUJK#vtKsVT1p5SzsyaydNFON6eevVkizE8zfEexsCqqWEJkb6" +
		"yIYtx1badyuOw#QTG$ERSsWzwvokORpFeVd#EO4vm3adKtnnkCwMUqNaUNofrEjY7nfvDBw" +
		"bRdQVRKLufcWUMVu1mYd8fxMJeZSzPMaVj#ZjO7jkcQrxUDfzozgNtPhsX8eCJpcojyN4am" +
		"hCFSenv#r2EbQikMMxa6zJJFBHXzPxTgBzsLQ3u$39Dm3cOZVTvpuhjjOi4NlU4Ub3#jxwN" +
		"IjkqyjzrfTqgStbRbuFce$s83jMI#ivwqNACS6XEMavhLFe9U3jDx1Dj2UWqTvO3$AjrwFz" +
		"ylBxF30cvSC7Wlj6E6#xaFz4xTpeIR$kVrRHnqtlGFrUkSZp$5dFywvMNDNSpQlSrVESx5s" +
		"Twi69vf7RqTxoQMzI6Oz#LnoLA$q1kkyDv#r0Tgg4zkzsUD9zLcAWd#0pA5tTl6QU$OhkJr" +
		"FUXcvUyGv##CMqxjrgWWVkunvuwtdBvqTNnIVXl78QkrkrYQapparlVdpu#SRb$llDhmwMY" +
		"STdX#$TT3#FRxsTs6F#qKgVuk57vH9$$NvagrkqjFCmPo7Ty$AwoxEKDvpYqUwpRfWlfief" +
		"Fx1tMEbP7wcYjUb#P9UgbbXnDTcoVcG$gcTIJ3QZ7yKr$Qsu9$a2FMaEVXgDTpKqtlGdUr9" +
		"JxyUbEuq$ZEmafx6yakPTbJG7BpeXG8F42toXFUfcWoYVthcejD#ZSVnLb3t93wEPugPB7l" +
		"K$A$hQDDCFUEe#u7$EN$7U#v#bQ6yuHMiyZDRVAf#subCylk$fpqN3K0Bq5frEi6ez#CzbR" +
		"32zbwJlWxuZlqodjSsAbbuOLjxWj$ptLLddRGqLq1QD6wTJdnOVxd$UVmh#NUQXxmV6pgDt" +
		"dKfLr0$uuUUH3rHCUb0ycV9fFwxKyyx9URJNLxgD9uzyWb9QBwwIVYhwcjQ55DgtqCzswnI" +
		"TY7AdkFVwvswwoqzXchSvE9nNSYWzkoVupChl6kJRyy1bAJtRDQREWfZyRyDvtVfxxq5lFV" +
		"JICuSud$gdz4Yq$KMu$laatwKUt#1yUn$hTe99wyKgwNsAvbH5dhtJy#azrD8JYCvNhLYvG" +
		"kojUChHld3f9DWVn$vvdbDRfJ#vURDfZQlKi696VQgIZ1IH7IwcFPiI6Yzcax$It9dB8ezy" +
		"b#QRk7dLj5#LsjFDw#dp6Q82x4PetGnoJssslOMn7GyKOwYzTkgMKUczZ6hofLikiE8JhtV" +
		"BdFH4jlRzC7Vy7BuVwKer#InJFMi$fzFxryKpW0$P#z9UVXYRa#yu$5dmS3IUqvfhwTN#Sg" +
		"KqPwy#qeerylUgYUyyuZsEGHwzsw0tojByl#HHz0NjtHKt9pWqdz59LgffJjho9Qflq#cyh" +
		"m4O7RrbFVbT87yTtFjUfMvQEmlFU#1vHsyTV$tgj#AUPGg0tP#n3aM89o8#Xd2XlUOQyhLh" +
		"x7TqoSOtepbr3TcK6bfZucUvSBjvtYFlPbfnTzhdgru2NQMvY7g8MqwbTSgIkw9ndJKWd7S" +
		"kwN7Bo$pvPRJsMKFZOJlQ8tFsjIPuouVXgXJlHEiADSIJOfgJQnuxL4JpSStZU#lEVDAwRq" +
		"jp#h9NmssrUzXJxyNmymxN1$F2PMf99clBF7cq9j7Her#rdlUwHpnDjDqHWDMEugsy#GGhn" +
		"3Vq5wsLd49h7pMlkC$EfNMLcc$Tl9qzQmgp0phR$0attReI$N2pfstFkhH6lzrezv2$Vlks" +
		"$lkvDtdeEXookw#LBctfAVD80CQHGHezpmBlSyv#rN$VBF0kUhDf$ll#t$llsvV4jKNFZ$N" +
		"VrpmLU1xmhKQCyTytFzbJzsitlVs9$dBR1tpHMizyQTkiyoNem2TMN1TufxwOtccfYrYx6K" +
		"LhQOV#ojZkXo70$pMlP6otaUWJyRuAnjuzVW6CqS6wVZYfCvZdCjyqbvhFcqlIjwTFCRZC#" +
		"JV2mmWFoBj527UQTvZ$Ccyt5pAMlYjzP$eEOptpDlDMynRpPlEcz6tfQUPCyqdpR5bU$7vm" +
		"Z7cGUQ1vWDD6KVhkz7$IZwKVH$qd49v4U1e18r9w2S8B2AyXl8NmFuJtqb#dLo7#2k7Bz1V" +
		"uZt4m$Ldwq$GtwTL8VOAmChqY$JtYtysFHHlfdz5ESVfJf1vDBqv$XxkFPFwlzFp7zBVfDU" +
		"cdp39vzuFPt2mrLvehqiyONueSumkpcNm2JyiGhHaoznDZfKL3#cFZG#C3uttZlVeragQKg" +
		"QTD#IHjVfn#paoRXbbl$cx#Plvg$cB#RAurVv1FVwFsVxBW6CqeBad3PqmlHNWLuKs4PGZl" +
		"cj#RtvdVcclCRypLvjVcAbFmu9tq##dbYDz8lut$ho2yZF2I#QNvHHeZNNfRXEqGkgUxfLi" +
		"JlgqGIX6gqfMKiwKiQr7P0g4aNP4kfsTRo6V5CbsBK9GkIpUdPvk2sa$JFSrFv5tdzERfJT" +
		"9RfJkbDqktJDUvafH#FVsYayPS9zqLzHG4s14JycgEDyUQLvjN8NMeEKwmpjHCp1bCANNrA" +
		"z8RrtzibjWGSB#HIrkwfuJwaUXNnB$8$skDZz8VojG7uEUdr79A$jVfJfF$LUFHz7S2VnEb" +
		"3F3E0AO6U6yyX$0C0YJIW6GQ$qLu1E4XX0SHxaUu1m5QODo100qmu0CQDo9Sxz9kVEn9NyS" +
		"yLnhQb0R4D3Gg3QZf$qC0v3IqAmtewViGxaMunrY0kZSOxnhl6CkDcv2#sRWL$sypRiV$Vn" +
		"btul$T27SPA6q0YW48ndt6O$Y$606wPVm70UqP3njFuJ#qotZQW7uPBo50nupdZLUC$ncGC" +
		"mDoPBnbl6cyWVXrXDUCLnsCztPI#tfwexsJQkV9NTz9jJK#CrPuwDxFKsf39zNHazl1IMr0" +
		"TGJtYysTp1tDmUOWSs3wT7DtSpTpLtEKkOivqXnX3ZTtDeUPGyqXGgVCFbu#c$syT$NVE$c" +
		"RiC1b0XiJ$hlPsydfHd5NixETPnJvwcnixcFkRUvbxccEDlS0flzAUwoeeJafrL080ocfzT" +
		"zAJFiwS0R8$$qTFDVA$pyuppSDORkHMGRPtTxiPVOK5WmMICgykRxPLiRhcMratDfJfwNyt" +
		"qh#Rs7MckBKcqhdQHLQ$C2SK$##Y0tOMVDPcJDRtdzbFcC#RJu5UxxOVC9ytFol#H$pCVFH" +
		"z1L6cT7SA3L$CdzCNvw#B3qVN9WbuAKlHJX7fYwM$#UbBqfVcBu0gRa8Sn3EJv#B$xFJvwK" +
		"lCJysdpFhp1g9IONy3nkK$ixuoC6ldTdUJgTFStAlDw5NvhN0yneHp0N4GQIfn3wcHmjplT" +
		"AOGPdx4oJegmbTDU#d#xlDpqnO0LFexI04z68QVPg6p9dtcMAqK0pJAckavV$VZT$eNjfzu" +
		"mS34cbyPtnhVeRuPxjLOmC4K6j8FJBGXqPBeuLHPzGQu91HRSuomLanokF$ZVKVoFWAyp8J" +
		"d3RFHpZNFC#yLEREDI#GCAORfnWd6zECgSP9nXJZH6EoSO8noJZUECuurfXe76CSRKmmZZA" +
		"ED8um3ZSECmurnXlZKEjKoSitZQhwDumPHFKDrDxbvdnpdda9yVjD0v9aJBFIveLERhdDVV" +
		"DCXDCHq7UcuEgfHWVHmv2aWt4ttHvHpLDiBfWdfnrznTqqJwySO5byUZBLysH$J$eW9tMWh" +
		"q$tJE#H7fNUpRwlVpCzqYiZwU48mn1sH1ZYu8$ve#dpaT9xfKUdTqtlxe6pYm$E28IT4NP2" +
		"6EhXpaKEToeCQAC1oscqDRUGhMmk$szcRcDkQNP2gekvjRcLjrMB#xBK58J929Fa7NmzyrX" +
		"pedcCURGvmJmglJ1zidaayevmyBb5$hyPuKONJlg6CEpq0ld$98GJ4T16#WG4j90#9Zr1jd" +
		"QN#6#qiUkOA6kAih2#wUsHFe4WtIh$euVIKsJggFGHwV7fmsHwBCAHwSFJuzA7fWzEmqDC7" +
		"ui0QjAOHwUFIn#TlZvzNVhQz3NfgzDNfMzow3uEJs6bqxsG5kFcO8I12B3UwVuUQamltupB" +
		"42ur8A#6j4V6FEDoOpuzenunWBsnXz7R68ruTsCtOrVAnzXdx6diOemqHXXx6QECVLZeChO" +
		"pu9SOi076K6C8$kzax6WCfcSx6yECGGRaojZM0AP6FwE$8NqNevE1VZSsDpOpEbiQPaotzS" +
		"uus85zaA#baKvgX9CQ5SR8UGQ#63JM6AIPnWKnPUTIF8VYsQ4IvrDydln$BjtDelWSYi#cU" +
		"2R5Pr5yfh6niP6neK4Zla4QPIts6PiODD8PfzLBIrcFMKqzsSLwyfNhVwp$nVByP4bclcs#" +
		"PRvilcIiCRwnSyqNJCVhD30tCBv6th8eYatuEkOhvklcQoPy7RKRluLnbYqyHU4o2fTJk28" +
		"YN4dXSIlmVWXR8$q4KsIu2caHvYDSpLIED892GTmpohFoHo8UYRW3uWw8HwFCrKYBS0t2jR" +
		"ZV4B48co6zETDP6h3jy8mC2bkCE6dud$n#fqP1zyGYf7Xxu952c8qsPwFiIhIxFzBx8wyLO" +
		"czOBnpGYIg2nejmNuIw7357hA3#AAH5g4HQPJf2YaAH9nQXsBvdlmFcxu3vWmmQMuMw1mB6" +
		"WO1v068HraTUMyGLW5c1UbOeuhsHtnlbhA3ndV7S2aKYi4y1yrF0j8BE#w9yNvIjGPW3U7D" +
		"mVn3YO1Y2C1tFjf91fQ3nkSYV2vZFuhuvqitHDsk1lnr#mlrg6LJsBkwZmWivXgyZmWVeom" +
		"z1tng45t7$Fjhx1k4bjFqyxkF2o#311Q3Z0k1l1OLV23ekH7mmmXYano3kZsVz0UiZjFCjm" +
		"YjevsDMmhvZ9Vp$QpkFq2g2C03FlxCl9i#6eWbw414BMC2k9y6A1SI2ehbfxDr8OWDxFzaE" +
		"NZJw8fPdIx74YeYWUB9Br9E8xQY81K6$#MVVooQAvU3Xu$ldtvdPEhCxWIGJgEEO21qLQ#u" +
		"gWRc7x#7x#24yeEqZx0bb1$LtqFyqZcCIzHwJVqmTna86wG2DYPygrXnMmgpBFJAPUfFfQp" +
		"3v9$Jr11$9aZ27g7V8v4JacgEK7GVeDquPRG$2IM9F427c63uE9uXFg7sSffyq#yZu53dtN" +
		"rSpdA5yHcrD1N65sbD9kL9TdohoLMfhgechyNby7b$05t0Dhi5NyLLy3LzZ$pUmupIvV#4c" +
		"r$2WZdKtzWEUwu1dD71pZuu3DzvVSOwlk5$JUIPsajj9tIB6Nn5Zh8ZohzWMpLaNOroYZzr" +
		"isqq$Cw0dSOP#zDcFd2UKFUJsS7oNwUSAxUhcLqUeuyYDWnSyb#yvZh7anvAF7$Thshycvq" +
		"d88FeOH3rF6BCZ8NjfjvVSJ3oJkXuRioEKgNWATQQG7mAZkHQUN0VFMgCOUR7vpf4NioEPB" +
		"JTNaX6DOtOqQJYFn#neb9dZ8dBCEQx1EUAp#2pNuZgvwzJvmZ6tuFXRS1wEbfHRggsC8Xwb" +
		"jhA6U8tQcXHjK#mZnVcbc0SyoOPbwKI$dMZJ7hV7i$5ipFiIh3J5ZcOHGoDcUSmdxlSdwhL" +
		"ctwtnICffzfrctsdsbUOQ3M1RBxRreartnKfdt9bybuYKOgKSb#CvU0vrvkAvU1vU2vbtRr" +
		"VkNpVsuzu$7xXc#paMtiqGDd0cRsFbBB8XniOiGOJ8UYM849cls5#oW6qBr7Ki9BTG$JEBs" +
		"BP8$MSMKtUnkeubv9QehImbNggsKanShBQoZ7YPsaeXSQ7QoYRYJOmXnsPYnpfeerXfXLlX" +
		"N9pBkIU9auobt$CtTK9pXsj$XtlXk4tydv61YeKmSa8Ao1KG5v3pJfYlrF$ACNt47$4R$8R" +
		"d#HtskDYQjyIUG7hJJs$QjyLjSHxEezvtjdzNMoaXLu9BSIdEn$cqzLXXHGU1yAqBLfRZvP" +
		"J7OSTuvgFnFE$zbOHieSuMjWzZsp3YFhWFPUSLYfM#k8w0#KPCBTU#blFqvCZswFkn7VLx0" +
		"D$O4CXA76ShkLNKNyLnHAxt$UhVso7VKmdbERdd#ksK4s5rdZSSkw7zS69Fe8o0VUoVxtYm" +
		"iffx0lM#cPxfEoJKCSkQ6aHODu986Ix3h2z1v01stmdkP#SlARk$BvR0hBH1p3UtpA7CEX1" +
		"4MEc2o2wy2xE61v4GXtYC$ewv6FSJyC#KMHU2c5i$019Kbze=");
 // Generated from src/parser/JavaParser.all
class Events extends Parser.Events {
    public void scannerError(Scanner.Exception e) {
      errors.add(new Problem(null, e.getMessage(), e.line, e.column, Problem.Severity.ERROR, Problem.Kind.LEXICAL));
    }
    public void syntaxError(Symbol token) {
      int line = token.getLine(token.getStart());
      int column = token.getColumn(token.getStart());
      int endLine = token.getLine(token.getEnd());
      int endColumn = token.getColumn(token.getEnd());
      String value = token.value != null ? token.value.toString() : Terminals.NAMES[token.getId()];
      errors.add(new Problem(null, "unexpected token \"" + value + "\"", line, column, endLine, endColumn, Problem.Severity.ERROR, Problem.Kind.SYNTACTIC));
    }
    public void unexpectedTokenRemoved(Symbol token) {
    }
    public void missingTokenInserted(Symbol token) {
    }
    public void misspelledTokenReplaced(Symbol token) {
    }
    public void errorPhraseRemoved(Symbol error) {
    }
  }

        {
            report = new Events(); // Use error handler in parser
        }

   public CompilationUnit parse(java.io.InputStream is, String fileName) throws java.io.IOException, beaver.Parser.Exception {
     CompilationUnit cu;
     errors = new ArrayList();
     try {
       scanner.JavaScanner scanner = new scanner.JavaScanner(new scanner.Unicode(is));
       cu = (CompilationUnit)parse(scanner);
     } catch(Parser.Exception e) {
       // build empty compilation unit for failed error recovery
       cu = new CompilationUnit();
     } catch(Error e) {
       cu = new CompilationUnit();
       errors.add(new Problem(null, e.getMessage(), 0, 0, Problem.Severity.ERROR, Problem.Kind.LEXICAL));
     }
     for(java.util.Iterator iter = errors.iterator(); iter.hasNext(); ) {
       Problem p = (Problem)iter.next();
       p.setFileName(fileName);
       cu.addParseError(p);
     }
     return cu;
   }
   protected java.util.Collection errors = new ArrayList();

	public JavaParser() {
		super(PARSING_TABLES);
	}

	protected Symbol invokeReduceAction(int rule_num, int offset) {
		switch(rule_num) {
			case 0: // goal = compilation_unit.cu
			{
					final Symbol _symbol_cu = _symbols[offset + 1];
					final CompilationUnit cu = (CompilationUnit) _symbol_cu.value;
					 return cu;
			}
			case 1: // literal = INTEGER_LITERAL.i
			{
					final Symbol i = _symbols[offset + 1];
					 return new IntegerLiteral(((String)i.value));
			}
			case 2: // literal = LONG_LITERAL.l
			{
					final Symbol l = _symbols[offset + 1];
					 return new LongLiteral(((String)l.value));
			}
			case 3: // literal = FLOATING_POINT_LITERAL.f
			{
					final Symbol f = _symbols[offset + 1];
					 return new FloatingPointLiteral(((String)f.value));
			}
			case 4: // literal = DOUBLE_LITERAL.d
			{
					final Symbol d = _symbols[offset + 1];
					 return new DoubleLiteral(((String)d.value));
			}
			case 5: // literal = BOOLEAN_LITERAL.b
			{
					final Symbol b = _symbols[offset + 1];
					 return new BooleanLiteral(((String)b.value));
			}
			case 6: // literal = CHARACTER_LITERAL.c
			{
					final Symbol c = _symbols[offset + 1];
					 return new CharacterLiteral(((String)c.value));
			}
			case 7: // literal = STRING_LITERAL.s
			{
					final Symbol s = _symbols[offset + 1];
					 return new StringLiteral(((String)s.value));
			}
			case 8: // literal = NULL_LITERAL.NULL_LITERAL
			{
					final Symbol NULL_LITERAL = _symbols[offset + 1];
					 return new NullLiteral("null");
			}
			case 9: // type = primitive_type.t
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final Access t = (Access) _symbol_t.value;
					 return t;
			}
			case 10: // type = reference_type.t
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final Access t = (Access) _symbol_t.value;
					 return t;
			}
			case 11: // primitive_type = numeric_type.t
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final Access t = (Access) _symbol_t.value;
					 return t;
			}
			case 12: // primitive_type = BOOLEAN.BOOLEAN
			{
					final Symbol BOOLEAN = _symbols[offset + 1];
					 return new PrimitiveTypeAccess("boolean");
			}
			case 13: // numeric_type = integral_type.t
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final Access t = (Access) _symbol_t.value;
					 return t;
			}
			case 14: // numeric_type = floating_point_type.t
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final Access t = (Access) _symbol_t.value;
					 return t;
			}
			case 15: // integral_type = BYTE.BYTE
			{
					final Symbol BYTE = _symbols[offset + 1];
					 return new PrimitiveTypeAccess("byte");
			}
			case 16: // integral_type = SHORT.SHORT
			{
					final Symbol SHORT = _symbols[offset + 1];
					 return new PrimitiveTypeAccess("short");
			}
			case 17: // integral_type = INT.INT
			{
					final Symbol INT = _symbols[offset + 1];
					 return new PrimitiveTypeAccess("int");
			}
			case 18: // integral_type = LONG.LONG
			{
					final Symbol LONG = _symbols[offset + 1];
					 return new PrimitiveTypeAccess("long");
			}
			case 19: // integral_type = CHAR.CHAR
			{
					final Symbol CHAR = _symbols[offset + 1];
					 return new PrimitiveTypeAccess("char");
			}
			case 20: // floating_point_type = FLOAT.FLOAT
			{
					final Symbol FLOAT = _symbols[offset + 1];
					 return new PrimitiveTypeAccess("float");
			}
			case 21: // floating_point_type = DOUBLE.DOUBLE
			{
					final Symbol DOUBLE = _symbols[offset + 1];
					 return new PrimitiveTypeAccess("double");
			}
			case 22: // reference_type = class_or_interface_type.t
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final Access t = (Access) _symbol_t.value;
					 return t;
			}
			case 23: // reference_type = array_type.t
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final Access t = (Access) _symbol_t.value;
					 return t;
			}
			case 24: // class_type = class_or_interface_type.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Access n = (Access) _symbol_n.value;
					 return n;
			}
			case 25: // interface_type = class_or_interface_type.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Access n = (Access) _symbol_n.value;
					 return n;
			}
			case 26: // array_type = primitive_type.t dims.d
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final Access t = (Access) _symbol_t.value;
					final Symbol _symbol_d = _symbols[offset + 2];
					final List d = (List) _symbol_d.value;
					 return t.addArrayDims(d);
			}
			case 27: // array_type = name.n dims.d
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Access n = (Access) _symbol_n.value;
					final Symbol _symbol_d = _symbols[offset + 2];
					final List d = (List) _symbol_d.value;
					 return n.addArrayDims(d);
			}
			case 28: // name = simple_name.s
			{
					final Symbol _symbol_s = _symbols[offset + 1];
					final Access s = (Access) _symbol_s.value;
					 return s;
			}
			case 29: // name = qualified_name.q
			{
					final Symbol _symbol_q = _symbols[offset + 1];
					final Access q = (Access) _symbol_q.value;
					 return q;
			}
			case 30: // simple_name = IDENTIFIER.IDENTIFIER
			{
					final Symbol IDENTIFIER = _symbols[offset + 1];
					 return new ParseName(IDENTIFIER);
			}
			case 31: // qualified_name = name.n DOT.DOT simple_name.i
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Access n = (Access) _symbol_n.value;
					final Symbol DOT = _symbols[offset + 2];
					final Symbol _symbol_i = _symbols[offset + 3];
					final Access i = (Access) _symbol_i.value;
					 return n.qualifiesAccess(i);
			}
			case 32: // compilation_unit = package_declaration.p
			{
					final Symbol _symbol_p = _symbols[offset + 1];
					final IdUse p = (IdUse) _symbol_p.value;
					 return new CompilationUnit(p.getID(), new List(), new List());
			}
			case 33: // compilation_unit = package_declaration.p import_declarations.i
			{
					final Symbol _symbol_p = _symbols[offset + 1];
					final IdUse p = (IdUse) _symbol_p.value;
					final Symbol _symbol_i = _symbols[offset + 2];
					final List i = (List) _symbol_i.value;
					 return new CompilationUnit(p.getID(), i, new List());
			}
			case 34: // compilation_unit = package_declaration.p type_declarations.t
			{
					final Symbol _symbol_p = _symbols[offset + 1];
					final IdUse p = (IdUse) _symbol_p.value;
					final Symbol _symbol_t = _symbols[offset + 2];
					final List t = (List) _symbol_t.value;
					 return new CompilationUnit(p.getID(), new List(), t);
			}
			case 35: // compilation_unit = package_declaration.p import_declarations.i type_declarations.t
			{
					final Symbol _symbol_p = _symbols[offset + 1];
					final IdUse p = (IdUse) _symbol_p.value;
					final Symbol _symbol_i = _symbols[offset + 2];
					final List i = (List) _symbol_i.value;
					final Symbol _symbol_t = _symbols[offset + 3];
					final List t = (List) _symbol_t.value;
					 return new CompilationUnit(p.getID(), i, t);
			}
			case 36: // compilation_unit = 
			{
					 return new CompilationUnit("", new List(), new List());
			}
			case 37: // compilation_unit = import_declarations.i
			{
					final Symbol _symbol_i = _symbols[offset + 1];
					final List i = (List) _symbol_i.value;
					 return new CompilationUnit("", i, new List());
			}
			case 38: // compilation_unit = type_declarations.t
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final List t = (List) _symbol_t.value;
					 return new CompilationUnit("", new List(), t);
			}
			case 39: // compilation_unit = import_declarations.i type_declarations.t
			{
					final Symbol _symbol_i = _symbols[offset + 1];
					final List i = (List) _symbol_i.value;
					final Symbol _symbol_t = _symbols[offset + 2];
					final List t = (List) _symbol_t.value;
					 return new CompilationUnit("", i, t);
			}
			case 40: // import_declarations = import_declaration.i
			{
					final Symbol _symbol_i = _symbols[offset + 1];
					final ImportDecl i = (ImportDecl) _symbol_i.value;
					 return new List().add(i);
			}
			case 41: // import_declarations = import_declarations.l import_declaration.i
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol _symbol_i = _symbols[offset + 2];
					final ImportDecl i = (ImportDecl) _symbol_i.value;
					 return l.add(i);
			}
			case 42: // type_declarations = type_declaration.t
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final TypeDecl t = (TypeDecl) _symbol_t.value;
					 return !(t instanceof EmptyType) ? new List().add(t) : new List() ;
			}
			case 43: // type_declarations = type_declarations.l type_declaration.t
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol _symbol_t = _symbols[offset + 2];
					final TypeDecl t = (TypeDecl) _symbol_t.value;
					 return !(t instanceof EmptyType) ? l.add(t) : l;
			}
			case 44: // package_declaration = PACKAGE.PACKAGE name_decl.n SEMICOLON.SEMICOLON
			{
					final Symbol PACKAGE = _symbols[offset + 1];
					final Symbol _symbol_n = _symbols[offset + 2];
					final IdUse n = (IdUse) _symbol_n.value;
					final Symbol SEMICOLON = _symbols[offset + 3];
					 return n;
			}
			case 45: // name_decl = simple_name_decl.s
			{
					final Symbol _symbol_s = _symbols[offset + 1];
					final IdUse s = (IdUse) _symbol_s.value;
					 return s;
			}
			case 46: // name_decl = qualified_name_decl.q
			{
					final Symbol _symbol_q = _symbols[offset + 1];
					final IdUse q = (IdUse) _symbol_q.value;
					 return q;
			}
			case 47: // simple_name_decl = IDENTIFIER.IDENTIFIER
			{
					final Symbol IDENTIFIER = _symbols[offset + 1];
					 return new IdUse(IDENTIFIER);
			}
			case 48: // qualified_name_decl = name_decl.n DOT.DOT IDENTIFIER.i
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final IdUse n = (IdUse) _symbol_n.value;
					final Symbol DOT = _symbols[offset + 2];
					final Symbol i = _symbols[offset + 3];
					 return new IdUse(n.getID() + "." + ((String)i.value));
			}
			case 49: // import_declaration = single_type_import_declaration.s
			{
					final Symbol _symbol_s = _symbols[offset + 1];
					final ImportDecl s = (ImportDecl) _symbol_s.value;
					 return s;
			}
			case 50: // import_declaration = type_import_on_demand_declaration.t
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final ImportDecl t = (ImportDecl) _symbol_t.value;
					 return t;
			}
			case 51: // single_type_import_declaration = IMPORT.IMPORT name.n SEMICOLON.SEMICOLON
			{
					final Symbol IMPORT = _symbols[offset + 1];
					final Symbol _symbol_n = _symbols[offset + 2];
					final Access n = (Access) _symbol_n.value;
					final Symbol SEMICOLON = _symbols[offset + 3];
					 return new SingleTypeImportDecl(n);
			}
			case 52: // type_import_on_demand_declaration = IMPORT.IMPORT name.n DOT.DOT MULT.MULT SEMICOLON.SEMICOLON
			{
					final Symbol IMPORT = _symbols[offset + 1];
					final Symbol _symbol_n = _symbols[offset + 2];
					final Access n = (Access) _symbol_n.value;
					final Symbol DOT = _symbols[offset + 3];
					final Symbol MULT = _symbols[offset + 4];
					final Symbol SEMICOLON = _symbols[offset + 5];
					 return new TypeImportOnDemandDecl(n);
			}
			case 53: // type_declaration = class_declaration.c
			{
					final Symbol _symbol_c = _symbols[offset + 1];
					final ClassDecl c = (ClassDecl) _symbol_c.value;
					 return c;
			}
			case 54: // type_declaration = interface_declaration.i
			{
					final Symbol _symbol_i = _symbols[offset + 1];
					final InterfaceDecl i = (InterfaceDecl) _symbol_i.value;
					 return i;
			}
			case 55: // type_declaration = SEMICOLON.SEMICOLON
			{
					final Symbol SEMICOLON = _symbols[offset + 1];
					 return new EmptyType(new Modifiers(), "EmptyType", new Opt(), new List());
			}
			case 56: // modifiers = modifier.m
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final Modifier m = (Modifier) _symbol_m.value;
					 return new List().add(m);
			}
			case 57: // modifiers = modifiers.l modifier.m
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol _symbol_m = _symbols[offset + 2];
					final Modifier m = (Modifier) _symbol_m.value;
					 return l.add(m);
			}
			case 58: // modifier = PUBLIC.PUBLIC
			{
					final Symbol PUBLIC = _symbols[offset + 1];
					 return new Modifier("public");
			}
			case 59: // modifier = PROTECTED.PROTECTED
			{
					final Symbol PROTECTED = _symbols[offset + 1];
					 return new Modifier("protected");
			}
			case 60: // modifier = PRIVATE.PRIVATE
			{
					final Symbol PRIVATE = _symbols[offset + 1];
					 return new Modifier("private");
			}
			case 61: // modifier = STATIC.STATIC
			{
					final Symbol STATIC = _symbols[offset + 1];
					 return new Modifier("static");
			}
			case 62: // modifier = ABSTRACT.ABSTRACT
			{
					final Symbol ABSTRACT = _symbols[offset + 1];
					 return new Modifier("abstract");
			}
			case 63: // modifier = FINAL.FINAL
			{
					final Symbol FINAL = _symbols[offset + 1];
					 return new Modifier("final");
			}
			case 64: // modifier = NATIVE.NATIVE
			{
					final Symbol NATIVE = _symbols[offset + 1];
					 return new Modifier("native");
			}
			case 65: // modifier = SYNCHRONIZED.SYNCHRONIZED
			{
					final Symbol SYNCHRONIZED = _symbols[offset + 1];
					 return new Modifier("synchronized");
			}
			case 66: // modifier = TRANSIENT.TRANSIENT
			{
					final Symbol TRANSIENT = _symbols[offset + 1];
					 return new Modifier("transient");
			}
			case 67: // modifier = VOLATILE.VOLATILE
			{
					final Symbol VOLATILE = _symbols[offset + 1];
					 return new Modifier("volatile");
			}
			case 68: // modifier = STRICTFP.STRICTFP
			{
					final Symbol STRICTFP = _symbols[offset + 1];
					 return new Modifier("strictfp");
			}
			case 69: // class_declaration = CLASS.CLASS IDENTIFIER.IDENTIFIER class_body.b
			{
					final Symbol CLASS = _symbols[offset + 1];
					final Symbol IDENTIFIER = _symbols[offset + 2];
					final Symbol _symbol_b = _symbols[offset + 3];
					final List b = (List) _symbol_b.value;
					 return new ClassDecl(new Modifiers(new List()), IDENTIFIER, new Opt(), new List(), b);
			}
			case 70: // class_declaration = modifiers.m CLASS.CLASS IDENTIFIER.IDENTIFIER class_body.b
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final List m = (List) _symbol_m.value;
					final Symbol CLASS = _symbols[offset + 2];
					final Symbol IDENTIFIER = _symbols[offset + 3];
					final Symbol _symbol_b = _symbols[offset + 4];
					final List b = (List) _symbol_b.value;
					 return new ClassDecl(new Modifiers(m), IDENTIFIER, new Opt(), new List(), b);
			}
			case 71: // class_declaration = CLASS.CLASS IDENTIFIER.IDENTIFIER super.s class_body.b
			{
					final Symbol CLASS = _symbols[offset + 1];
					final Symbol IDENTIFIER = _symbols[offset + 2];
					final Symbol _symbol_s = _symbols[offset + 3];
					final Opt s = (Opt) _symbol_s.value;
					final Symbol _symbol_b = _symbols[offset + 4];
					final List b = (List) _symbol_b.value;
					 return new ClassDecl(new Modifiers(new List()), IDENTIFIER, s, new List(), b);
			}
			case 72: // class_declaration = modifiers.m CLASS.CLASS IDENTIFIER.IDENTIFIER super.s class_body.b
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final List m = (List) _symbol_m.value;
					final Symbol CLASS = _symbols[offset + 2];
					final Symbol IDENTIFIER = _symbols[offset + 3];
					final Symbol _symbol_s = _symbols[offset + 4];
					final Opt s = (Opt) _symbol_s.value;
					final Symbol _symbol_b = _symbols[offset + 5];
					final List b = (List) _symbol_b.value;
					 return new ClassDecl(new Modifiers(m), IDENTIFIER, s, new List(), b);
			}
			case 73: // class_declaration = CLASS.CLASS IDENTIFIER.IDENTIFIER interfaces.i class_body.b
			{
					final Symbol CLASS = _symbols[offset + 1];
					final Symbol IDENTIFIER = _symbols[offset + 2];
					final Symbol _symbol_i = _symbols[offset + 3];
					final List i = (List) _symbol_i.value;
					final Symbol _symbol_b = _symbols[offset + 4];
					final List b = (List) _symbol_b.value;
					 return new ClassDecl(new Modifiers(new List()), IDENTIFIER, new Opt(), i, b);
			}
			case 74: // class_declaration = modifiers.m CLASS.CLASS IDENTIFIER.IDENTIFIER interfaces.i class_body.b
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final List m = (List) _symbol_m.value;
					final Symbol CLASS = _symbols[offset + 2];
					final Symbol IDENTIFIER = _symbols[offset + 3];
					final Symbol _symbol_i = _symbols[offset + 4];
					final List i = (List) _symbol_i.value;
					final Symbol _symbol_b = _symbols[offset + 5];
					final List b = (List) _symbol_b.value;
					 return new ClassDecl(new Modifiers(m), IDENTIFIER, new Opt(), i, b);
			}
			case 75: // class_declaration = CLASS.CLASS IDENTIFIER.IDENTIFIER super.s interfaces.i class_body.b
			{
					final Symbol CLASS = _symbols[offset + 1];
					final Symbol IDENTIFIER = _symbols[offset + 2];
					final Symbol _symbol_s = _symbols[offset + 3];
					final Opt s = (Opt) _symbol_s.value;
					final Symbol _symbol_i = _symbols[offset + 4];
					final List i = (List) _symbol_i.value;
					final Symbol _symbol_b = _symbols[offset + 5];
					final List b = (List) _symbol_b.value;
					 return new ClassDecl(new Modifiers(new List()), IDENTIFIER, s, i, b);
			}
			case 76: // class_declaration = modifiers.m CLASS.CLASS IDENTIFIER.IDENTIFIER super.s interfaces.i class_body.b
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final List m = (List) _symbol_m.value;
					final Symbol CLASS = _symbols[offset + 2];
					final Symbol IDENTIFIER = _symbols[offset + 3];
					final Symbol _symbol_s = _symbols[offset + 4];
					final Opt s = (Opt) _symbol_s.value;
					final Symbol _symbol_i = _symbols[offset + 5];
					final List i = (List) _symbol_i.value;
					final Symbol _symbol_b = _symbols[offset + 6];
					final List b = (List) _symbol_b.value;
					 return new ClassDecl(new Modifiers(m), IDENTIFIER, s, i, b);
			}
			case 77: // super = EXTENDS.EXTENDS class_type.c
			{
					final Symbol EXTENDS = _symbols[offset + 1];
					final Symbol _symbol_c = _symbols[offset + 2];
					final Access c = (Access) _symbol_c.value;
					 return new Opt(c);
			}
			case 78: // interfaces = IMPLEMENTS.IMPLEMENTS interface_type_list.i
			{
					final Symbol IMPLEMENTS = _symbols[offset + 1];
					final Symbol _symbol_i = _symbols[offset + 2];
					final List i = (List) _symbol_i.value;
					 return i;
			}
			case 79: // interface_type_list = interface_type.i
			{
					final Symbol _symbol_i = _symbols[offset + 1];
					final Access i = (Access) _symbol_i.value;
					 return new List().add(i);
			}
			case 80: // interface_type_list = interface_type_list.l COMMA.COMMA interface_type.i
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol COMMA = _symbols[offset + 2];
					final Symbol _symbol_i = _symbols[offset + 3];
					final Access i = (Access) _symbol_i.value;
					 return l.add(i);
			}
			case 81: // class_body = LBRACE.LBRACE class_body_declarations_opt.c RBRACE.RBRACE
			{
					final Symbol LBRACE = _symbols[offset + 1];
					final Symbol _symbol_c = _symbols[offset + 2];
					final List c = (List) _symbol_c.value;
					final Symbol RBRACE = _symbols[offset + 3];
					 return c;
			}
			case 82: // class_body_declarations = class_body_declaration.c
			{
					final Symbol _symbol_c = _symbols[offset + 1];
					final BodyDecl c = (BodyDecl) _symbol_c.value;
					 return new List().add(c);
			}
			case 83: // class_body_declarations = class_body_declarations.l class_body_declaration.c
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol _symbol_c = _symbols[offset + 2];
					final BodyDecl c = (BodyDecl) _symbol_c.value;
					 return l.add(c);
			}
			case 84: // class_body_declaration = class_member_declaration.c
			{
					final Symbol _symbol_c = _symbols[offset + 1];
					final BodyDecl c = (BodyDecl) _symbol_c.value;
					 return c;
			}
			case 85: // class_body_declaration = instance_initializer.i
			{
					final Symbol _symbol_i = _symbols[offset + 1];
					final InstanceInitializer i = (InstanceInitializer) _symbol_i.value;
					 return i;
			}
			case 86: // class_body_declaration = static_initializer.si
			{
					final Symbol _symbol_si = _symbols[offset + 1];
					final StaticInitializer si = (StaticInitializer) _symbol_si.value;
					 return si;
			}
			case 87: // class_body_declaration = constructor_declaration.c
			{
					final Symbol _symbol_c = _symbols[offset + 1];
					final ConstructorDecl c = (ConstructorDecl) _symbol_c.value;
					 return c;
			}
			case 88: // class_member_declaration = field_declaration.f
			{
					final Symbol _symbol_f = _symbols[offset + 1];
					final BodyDecl f = (BodyDecl) _symbol_f.value;
					 return f;
			}
			case 89: // class_member_declaration = method_declaration.m
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final MethodDecl m = (MethodDecl) _symbol_m.value;
					 return m;
			}
			case 90: // class_member_declaration = class_declaration.c
			{
					final Symbol _symbol_c = _symbols[offset + 1];
					final ClassDecl c = (ClassDecl) _symbol_c.value;
					 return new MemberClassDecl(c);
			}
			case 91: // class_member_declaration = interface_declaration.i
			{
					final Symbol _symbol_i = _symbols[offset + 1];
					final InterfaceDecl i = (InterfaceDecl) _symbol_i.value;
					 return new MemberInterfaceDecl(i);
			}
			case 92: // class_member_declaration = SEMICOLON.SEMICOLON
			{
					final Symbol SEMICOLON = _symbols[offset + 1];
					 return new InstanceInitializer(new Block());
			}
			case 93: // field_declaration = type.t variable_declarators.v SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final Access t = (Access) _symbol_t.value;
					final Symbol _symbol_v = _symbols[offset + 2];
					final List v = (List) _symbol_v.value;
					final Symbol SEMICOLON = _symbols[offset + 3];
					 return new FieldDecl(new Modifiers(new List()), t, v);
			}
			case 94: // field_declaration = modifiers.m type.t variable_declarators.v SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final List m = (List) _symbol_m.value;
					final Symbol _symbol_t = _symbols[offset + 2];
					final Access t = (Access) _symbol_t.value;
					final Symbol _symbol_v = _symbols[offset + 3];
					final List v = (List) _symbol_v.value;
					final Symbol SEMICOLON = _symbols[offset + 4];
					 return new FieldDecl(new Modifiers(m), t, v);
			}
			case 95: // variable_declarators = variable_declarator.v
			{
					final Symbol _symbol_v = _symbols[offset + 1];
					final VariableDecl v = (VariableDecl) _symbol_v.value;
					 return new List().add(v);
			}
			case 96: // variable_declarators = variable_declarators.l COMMA.COMMA variable_declarator.v
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol COMMA = _symbols[offset + 2];
					final Symbol _symbol_v = _symbols[offset + 3];
					final VariableDecl v = (VariableDecl) _symbol_v.value;
					 return l.add(v);
			}
			case 97: // variable_declarator = variable_declarator_id.v
			{
					final Symbol _symbol_v = _symbols[offset + 1];
					final VariableDecl v = (VariableDecl) _symbol_v.value;
					 return v;
			}
			case 98: // variable_declarator = variable_declarator_id.v EQ.EQ variable_initializer.i
			{
					final Symbol _symbol_v = _symbols[offset + 1];
					final VariableDecl v = (VariableDecl) _symbol_v.value;
					final Symbol EQ = _symbols[offset + 2];
					final Symbol _symbol_i = _symbols[offset + 3];
					final Expr i = (Expr) _symbol_i.value;
					 v.setInit(i); return v;
			}
			case 99: // variable_declarator_id = IDENTIFIER.IDENTIFIER dims_opt.d
			{
					final Symbol IDENTIFIER = _symbols[offset + 1];
					final Symbol _symbol_d = _symbols[offset + 2];
					final List d = (List) _symbol_d.value;
					 return new VariableDecl(IDENTIFIER, d, new Opt());
			}
			case 100: // variable_initializer = expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 101: // variable_initializer = array_initializer.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final ArrayInit a = (ArrayInit) _symbol_a.value;
					 return a;
			}
			case 102: // method_declaration = method_header.m method_body.b
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final MethodDecl m = (MethodDecl) _symbol_m.value;
					final Symbol _symbol_b = _symbols[offset + 2];
					final Opt b = (Opt) _symbol_b.value;
					 m.setBlockOpt(b); return m;
			}
			case 103: // method_header = type.t IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.l RPAREN.RPAREN
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final Access t = (Access) _symbol_t.value;
					final Symbol IDENTIFIER = _symbols[offset + 2];
					final Symbol LPAREN = _symbols[offset + 3];
					final Symbol _symbol_l = _symbols[offset + 4];
					final List l = (List) _symbol_l.value;
					final Symbol RPAREN = _symbols[offset + 5];
					 return new MethodDecl(new Modifiers(new List()), t.addArrayDims(new List()), IDENTIFIER, l, new List(), new Opt());
			}
			case 104: // method_header = modifiers.m type.t IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.l RPAREN.RPAREN
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final List m = (List) _symbol_m.value;
					final Symbol _symbol_t = _symbols[offset + 2];
					final Access t = (Access) _symbol_t.value;
					final Symbol IDENTIFIER = _symbols[offset + 3];
					final Symbol LPAREN = _symbols[offset + 4];
					final Symbol _symbol_l = _symbols[offset + 5];
					final List l = (List) _symbol_l.value;
					final Symbol RPAREN = _symbols[offset + 6];
					 return new MethodDecl(new Modifiers(m), t.addArrayDims(new List()), IDENTIFIER, l, new List(), new Opt());
			}
			case 105: // method_header = type.t IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.l RPAREN.RPAREN dims.d
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final Access t = (Access) _symbol_t.value;
					final Symbol IDENTIFIER = _symbols[offset + 2];
					final Symbol LPAREN = _symbols[offset + 3];
					final Symbol _symbol_l = _symbols[offset + 4];
					final List l = (List) _symbol_l.value;
					final Symbol RPAREN = _symbols[offset + 5];
					final Symbol _symbol_d = _symbols[offset + 6];
					final List d = (List) _symbol_d.value;
					 return new MethodDecl(new Modifiers(new List()), t.addArrayDims(d), IDENTIFIER, l, new List(), new Opt());
			}
			case 106: // method_header = modifiers.m type.t IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.l RPAREN.RPAREN dims.d
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final List m = (List) _symbol_m.value;
					final Symbol _symbol_t = _symbols[offset + 2];
					final Access t = (Access) _symbol_t.value;
					final Symbol IDENTIFIER = _symbols[offset + 3];
					final Symbol LPAREN = _symbols[offset + 4];
					final Symbol _symbol_l = _symbols[offset + 5];
					final List l = (List) _symbol_l.value;
					final Symbol RPAREN = _symbols[offset + 6];
					final Symbol _symbol_d = _symbols[offset + 7];
					final List d = (List) _symbol_d.value;
					 return new MethodDecl(new Modifiers(m), t.addArrayDims(d), IDENTIFIER, l, new List(), new Opt());
			}
			case 107: // method_header = type.t IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.l RPAREN.RPAREN throws.tl
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final Access t = (Access) _symbol_t.value;
					final Symbol IDENTIFIER = _symbols[offset + 2];
					final Symbol LPAREN = _symbols[offset + 3];
					final Symbol _symbol_l = _symbols[offset + 4];
					final List l = (List) _symbol_l.value;
					final Symbol RPAREN = _symbols[offset + 5];
					final Symbol _symbol_tl = _symbols[offset + 6];
					final List tl = (List) _symbol_tl.value;
					 return new MethodDecl(new Modifiers(new List()), t.addArrayDims(new List()), IDENTIFIER, l, tl, new Opt());
			}
			case 108: // method_header = modifiers.m type.t IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.l RPAREN.RPAREN throws.tl
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final List m = (List) _symbol_m.value;
					final Symbol _symbol_t = _symbols[offset + 2];
					final Access t = (Access) _symbol_t.value;
					final Symbol IDENTIFIER = _symbols[offset + 3];
					final Symbol LPAREN = _symbols[offset + 4];
					final Symbol _symbol_l = _symbols[offset + 5];
					final List l = (List) _symbol_l.value;
					final Symbol RPAREN = _symbols[offset + 6];
					final Symbol _symbol_tl = _symbols[offset + 7];
					final List tl = (List) _symbol_tl.value;
					 return new MethodDecl(new Modifiers(m), t.addArrayDims(new List()), IDENTIFIER, l, tl, new Opt());
			}
			case 109: // method_header = type.t IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.l RPAREN.RPAREN dims.d throws.tl
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final Access t = (Access) _symbol_t.value;
					final Symbol IDENTIFIER = _symbols[offset + 2];
					final Symbol LPAREN = _symbols[offset + 3];
					final Symbol _symbol_l = _symbols[offset + 4];
					final List l = (List) _symbol_l.value;
					final Symbol RPAREN = _symbols[offset + 5];
					final Symbol _symbol_d = _symbols[offset + 6];
					final List d = (List) _symbol_d.value;
					final Symbol _symbol_tl = _symbols[offset + 7];
					final List tl = (List) _symbol_tl.value;
					 return new MethodDecl(new Modifiers(new List()), t.addArrayDims(d), IDENTIFIER, l, tl, new Opt());
			}
			case 110: // method_header = modifiers.m type.t IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.l RPAREN.RPAREN dims.d throws.tl
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final List m = (List) _symbol_m.value;
					final Symbol _symbol_t = _symbols[offset + 2];
					final Access t = (Access) _symbol_t.value;
					final Symbol IDENTIFIER = _symbols[offset + 3];
					final Symbol LPAREN = _symbols[offset + 4];
					final Symbol _symbol_l = _symbols[offset + 5];
					final List l = (List) _symbol_l.value;
					final Symbol RPAREN = _symbols[offset + 6];
					final Symbol _symbol_d = _symbols[offset + 7];
					final List d = (List) _symbol_d.value;
					final Symbol _symbol_tl = _symbols[offset + 8];
					final List tl = (List) _symbol_tl.value;
					 return new MethodDecl(new Modifiers(m), t.addArrayDims(d), IDENTIFIER, l, tl, new Opt());
			}
			case 111: // method_header = VOID.VOID IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.l RPAREN.RPAREN throws_opt.tl
			{
					final Symbol VOID = _symbols[offset + 1];
					final Symbol IDENTIFIER = _symbols[offset + 2];
					final Symbol LPAREN = _symbols[offset + 3];
					final Symbol _symbol_l = _symbols[offset + 4];
					final List l = (List) _symbol_l.value;
					final Symbol RPAREN = _symbols[offset + 5];
					final Symbol _symbol_tl = _symbols[offset + 6];
					final List tl = (List) _symbol_tl.value;
					 return new MethodDecl(new Modifiers(new List()), new PrimitiveTypeAccess("void"), IDENTIFIER, l, tl, new Opt());
			}
			case 112: // method_header = modifiers.m VOID.VOID IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.l RPAREN.RPAREN throws_opt.tl
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final List m = (List) _symbol_m.value;
					final Symbol VOID = _symbols[offset + 2];
					final Symbol IDENTIFIER = _symbols[offset + 3];
					final Symbol LPAREN = _symbols[offset + 4];
					final Symbol _symbol_l = _symbols[offset + 5];
					final List l = (List) _symbol_l.value;
					final Symbol RPAREN = _symbols[offset + 6];
					final Symbol _symbol_tl = _symbols[offset + 7];
					final List tl = (List) _symbol_tl.value;
					 return new MethodDecl(new Modifiers(m), new PrimitiveTypeAccess("void"), IDENTIFIER, l, tl, new Opt());
			}
			case 113: // formal_parameter_list = formal_parameter.f
			{
					final Symbol _symbol_f = _symbols[offset + 1];
					final ParameterDeclaration f = (ParameterDeclaration) _symbol_f.value;
					 return new List().add(f);
			}
			case 114: // formal_parameter_list = formal_parameter_list.l COMMA.COMMA formal_parameter.f
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol COMMA = _symbols[offset + 2];
					final Symbol _symbol_f = _symbols[offset + 3];
					final ParameterDeclaration f = (ParameterDeclaration) _symbol_f.value;
					 return l.add(f);
			}
			case 115: // formal_parameter = type.t IDENTIFIER.IDENTIFIER dims_opt.d
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final Access t = (Access) _symbol_t.value;
					final Symbol IDENTIFIER = _symbols[offset + 2];
					final Symbol _symbol_d = _symbols[offset + 3];
					final List d = (List) _symbol_d.value;
					 return new ParameterDeclaration(new Modifiers(new List()), t.addArrayDims(d), IDENTIFIER);
			}
			case 116: // formal_parameter = modifiers.m type.t IDENTIFIER.IDENTIFIER dims_opt.d
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final List m = (List) _symbol_m.value;
					final Symbol _symbol_t = _symbols[offset + 2];
					final Access t = (Access) _symbol_t.value;
					final Symbol IDENTIFIER = _symbols[offset + 3];
					final Symbol _symbol_d = _symbols[offset + 4];
					final List d = (List) _symbol_d.value;
					 return new ParameterDeclaration(new Modifiers(m), t.addArrayDims(d), IDENTIFIER);
			}
			case 117: // throws = THROWS.THROWS class_type_list.l
			{
					final Symbol THROWS = _symbols[offset + 1];
					final Symbol _symbol_l = _symbols[offset + 2];
					final List l = (List) _symbol_l.value;
					 return l;
			}
			case 118: // class_type_list = class_type.c
			{
					final Symbol _symbol_c = _symbols[offset + 1];
					final Access c = (Access) _symbol_c.value;
					 return new List().add(c);
			}
			case 119: // class_type_list = class_type_list.l COMMA.COMMA class_type.c
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol COMMA = _symbols[offset + 2];
					final Symbol _symbol_c = _symbols[offset + 3];
					final Access c = (Access) _symbol_c.value;
					 return l.add(c);
			}
			case 120: // method_body = block.b
			{
					final Symbol _symbol_b = _symbols[offset + 1];
					final Block b = (Block) _symbol_b.value;
					 return new Opt(b);
			}
			case 121: // method_body = SEMICOLON.SEMICOLON
			{
					final Symbol SEMICOLON = _symbols[offset + 1];
					 return new Opt();
			}
			case 122: // static_initializer = STATIC.STATIC block.b
			{
					final Symbol STATIC = _symbols[offset + 1];
					final Symbol _symbol_b = _symbols[offset + 2];
					final Block b = (Block) _symbol_b.value;
					 return new StaticInitializer(b);
			}
			case 123: // instance_initializer = block.b
			{
					final Symbol _symbol_b = _symbols[offset + 1];
					final Block b = (Block) _symbol_b.value;
					 return new InstanceInitializer(b);
			}
			case 124: // constructor_declaration = IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.pl RPAREN.RPAREN constructor_body.b
			{
					final Symbol IDENTIFIER = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_pl = _symbols[offset + 3];
					final List pl = (List) _symbol_pl.value;
					final Symbol RPAREN = _symbols[offset + 4];
					final Symbol _symbol_b = _symbols[offset + 5];
					final ConstructorDecl b = (ConstructorDecl) _symbol_b.value;
					 b.setModifiers(new Modifiers(new List())); b.setID(IDENTIFIER); b.setParameterList(pl); b.setExceptionList(new List()); return b;
			}
			case 125: // constructor_declaration = modifiers.m IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.pl RPAREN.RPAREN constructor_body.b
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final List m = (List) _symbol_m.value;
					final Symbol IDENTIFIER = _symbols[offset + 2];
					final Symbol LPAREN = _symbols[offset + 3];
					final Symbol _symbol_pl = _symbols[offset + 4];
					final List pl = (List) _symbol_pl.value;
					final Symbol RPAREN = _symbols[offset + 5];
					final Symbol _symbol_b = _symbols[offset + 6];
					final ConstructorDecl b = (ConstructorDecl) _symbol_b.value;
					 b.setModifiers(new Modifiers(m)); b.setID(IDENTIFIER); b.setParameterList(pl); b.setExceptionList(new List()); return b;
			}
			case 126: // constructor_declaration = IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.pl RPAREN.RPAREN throws.tl constructor_body.b
			{
					final Symbol IDENTIFIER = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_pl = _symbols[offset + 3];
					final List pl = (List) _symbol_pl.value;
					final Symbol RPAREN = _symbols[offset + 4];
					final Symbol _symbol_tl = _symbols[offset + 5];
					final List tl = (List) _symbol_tl.value;
					final Symbol _symbol_b = _symbols[offset + 6];
					final ConstructorDecl b = (ConstructorDecl) _symbol_b.value;
					 b.setModifiers(new Modifiers(new List())); b.setID(IDENTIFIER); b.setParameterList(pl); b.setExceptionList(tl); return b;
			}
			case 127: // constructor_declaration = modifiers.m IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.pl RPAREN.RPAREN throws.tl constructor_body.b
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final List m = (List) _symbol_m.value;
					final Symbol IDENTIFIER = _symbols[offset + 2];
					final Symbol LPAREN = _symbols[offset + 3];
					final Symbol _symbol_pl = _symbols[offset + 4];
					final List pl = (List) _symbol_pl.value;
					final Symbol RPAREN = _symbols[offset + 5];
					final Symbol _symbol_tl = _symbols[offset + 6];
					final List tl = (List) _symbol_tl.value;
					final Symbol _symbol_b = _symbols[offset + 7];
					final ConstructorDecl b = (ConstructorDecl) _symbol_b.value;
					 b.setModifiers(new Modifiers(m)); b.setID(IDENTIFIER); b.setParameterList(pl); b.setExceptionList(tl); return b;
			}
			case 128: // constructor_body = LBRACE.LBRACE RBRACE.RBRACE
			{
					final Symbol LBRACE = _symbols[offset + 1];
					final Symbol RBRACE = _symbols[offset + 2];
					 return new ConstructorDecl(new Modifiers(), "", new List(), new List(), new Opt(), new Block(new List()));
			}
			case 129: // constructor_body = LBRACE.LBRACE explicit_constructor_invocation.c RBRACE.RBRACE
			{
					final Symbol LBRACE = _symbols[offset + 1];
					final Symbol _symbol_c = _symbols[offset + 2];
					final ExprStmt c = (ExprStmt) _symbol_c.value;
					final Symbol RBRACE = _symbols[offset + 3];
					 return new ConstructorDecl(new Modifiers(), "", new List(), new List(), new Opt(c), new Block(new List()));
			}
			case 130: // constructor_body = LBRACE.LBRACE block_statements.l RBRACE.RBRACE
			{
					final Symbol LBRACE = _symbols[offset + 1];
					final Symbol _symbol_l = _symbols[offset + 2];
					final List l = (List) _symbol_l.value;
					final Symbol RBRACE = _symbols[offset + 3];
					 return new ConstructorDecl(new Modifiers(), "", new List(), new List(), new Opt(), new Block(l));
			}
			case 131: // constructor_body = LBRACE.LBRACE explicit_constructor_invocation.c block_statements.l RBRACE.RBRACE
			{
					final Symbol LBRACE = _symbols[offset + 1];
					final Symbol _symbol_c = _symbols[offset + 2];
					final ExprStmt c = (ExprStmt) _symbol_c.value;
					final Symbol _symbol_l = _symbols[offset + 3];
					final List l = (List) _symbol_l.value;
					final Symbol RBRACE = _symbols[offset + 4];
					 return new ConstructorDecl(new Modifiers(), "", new List(), new List(), new Opt(c), new Block(l));
			}
			case 132: // explicit_constructor_invocation = THIS.THIS LPAREN.LPAREN argument_list_opt.l RPAREN.RPAREN SEMICOLON.SEMICOLON
			{
					final Symbol THIS = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_l = _symbols[offset + 3];
					final List l = (List) _symbol_l.value;
					final Symbol RPAREN = _symbols[offset + 4];
					final Symbol SEMICOLON = _symbols[offset + 5];
					 ConstructorAccess c = new ConstructorAccess("this", l);
       c.setStart(THIS.getStart());
       c.setEnd(RPAREN.getEnd());
       return new ExprStmt(c);
			}
			case 133: // explicit_constructor_invocation = SUPER.SUPER LPAREN.LPAREN argument_list_opt.l RPAREN.RPAREN SEMICOLON.SEMICOLON
			{
					final Symbol SUPER = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_l = _symbols[offset + 3];
					final List l = (List) _symbol_l.value;
					final Symbol RPAREN = _symbols[offset + 4];
					final Symbol SEMICOLON = _symbols[offset + 5];
					 SuperConstructorAccess c = new SuperConstructorAccess("super", l);
       c.setStart(SUPER.getStart());
       c.setEnd(RPAREN.getEnd());
       return new ExprStmt(c);
			}
			case 134: // explicit_constructor_invocation = primary.p DOT.DOT SUPER.SUPER LPAREN.LPAREN argument_list_opt.l RPAREN.RPAREN SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_p = _symbols[offset + 1];
					final Expr p = (Expr) _symbol_p.value;
					final Symbol DOT = _symbols[offset + 2];
					final Symbol SUPER = _symbols[offset + 3];
					final Symbol LPAREN = _symbols[offset + 4];
					final Symbol _symbol_l = _symbols[offset + 5];
					final List l = (List) _symbol_l.value;
					final Symbol RPAREN = _symbols[offset + 6];
					final Symbol SEMICOLON = _symbols[offset + 7];
					 SuperConstructorAccess c = new SuperConstructorAccess("super", l);
       c.setStart(SUPER.getStart());
       c.setEnd(RPAREN.getEnd());
       return new ExprStmt(p.qualifiesAccess(c));
			}
			case 135: // explicit_constructor_invocation = name.n DOT.DOT SUPER.SUPER LPAREN.LPAREN argument_list_opt.l RPAREN.RPAREN SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Access n = (Access) _symbol_n.value;
					final Symbol DOT = _symbols[offset + 2];
					final Symbol SUPER = _symbols[offset + 3];
					final Symbol LPAREN = _symbols[offset + 4];
					final Symbol _symbol_l = _symbols[offset + 5];
					final List l = (List) _symbol_l.value;
					final Symbol RPAREN = _symbols[offset + 6];
					final Symbol SEMICOLON = _symbols[offset + 7];
					 SuperConstructorAccess c = new SuperConstructorAccess("super", l);
       c.setStart(SUPER.getStart());
       c.setEnd(RPAREN.getEnd());
       return new ExprStmt(n.qualifiesAccess(c));
			}
			case 136: // interface_declaration = INTERFACE.INTERFACE IDENTIFIER.IDENTIFIER interface_body.b
			{
					final Symbol INTERFACE = _symbols[offset + 1];
					final Symbol IDENTIFIER = _symbols[offset + 2];
					final Symbol _symbol_b = _symbols[offset + 3];
					final List b = (List) _symbol_b.value;
					 return new InterfaceDecl(new Modifiers(new List()), IDENTIFIER, new List(), b);
			}
			case 137: // interface_declaration = modifiers.m INTERFACE.INTERFACE IDENTIFIER.IDENTIFIER interface_body.b
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final List m = (List) _symbol_m.value;
					final Symbol INTERFACE = _symbols[offset + 2];
					final Symbol IDENTIFIER = _symbols[offset + 3];
					final Symbol _symbol_b = _symbols[offset + 4];
					final List b = (List) _symbol_b.value;
					 return new InterfaceDecl(new Modifiers(m), IDENTIFIER, new List(), b);
			}
			case 138: // interface_declaration = INTERFACE.INTERFACE IDENTIFIER.IDENTIFIER extends_interfaces.i interface_body.b
			{
					final Symbol INTERFACE = _symbols[offset + 1];
					final Symbol IDENTIFIER = _symbols[offset + 2];
					final Symbol _symbol_i = _symbols[offset + 3];
					final List i = (List) _symbol_i.value;
					final Symbol _symbol_b = _symbols[offset + 4];
					final List b = (List) _symbol_b.value;
					 return new InterfaceDecl(new Modifiers(new List()), IDENTIFIER, i, b);
			}
			case 139: // interface_declaration = modifiers.m INTERFACE.INTERFACE IDENTIFIER.IDENTIFIER extends_interfaces.i interface_body.b
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final List m = (List) _symbol_m.value;
					final Symbol INTERFACE = _symbols[offset + 2];
					final Symbol IDENTIFIER = _symbols[offset + 3];
					final Symbol _symbol_i = _symbols[offset + 4];
					final List i = (List) _symbol_i.value;
					final Symbol _symbol_b = _symbols[offset + 5];
					final List b = (List) _symbol_b.value;
					 return new InterfaceDecl(new Modifiers(m), IDENTIFIER, i, b);
			}
			case 140: // extends_interfaces = EXTENDS.EXTENDS interface_type.i
			{
					final Symbol EXTENDS = _symbols[offset + 1];
					final Symbol _symbol_i = _symbols[offset + 2];
					final Access i = (Access) _symbol_i.value;
					 return new List().add(i);
			}
			case 141: // extends_interfaces = extends_interfaces.l COMMA.COMMA interface_type.i
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol COMMA = _symbols[offset + 2];
					final Symbol _symbol_i = _symbols[offset + 3];
					final Access i = (Access) _symbol_i.value;
					 return l.add(i);
			}
			case 142: // interface_body = LBRACE.LBRACE interface_member_declarations_opt.i RBRACE.RBRACE
			{
					final Symbol LBRACE = _symbols[offset + 1];
					final Symbol _symbol_i = _symbols[offset + 2];
					final List i = (List) _symbol_i.value;
					final Symbol RBRACE = _symbols[offset + 3];
					 return i;
			}
			case 143: // interface_member_declarations = interface_member_declaration.i
			{
					final Symbol _symbol_i = _symbols[offset + 1];
					final BodyDecl i = (BodyDecl) _symbol_i.value;
					 return new List().add(i);
			}
			case 144: // interface_member_declarations = interface_member_declarations.l interface_member_declaration.i
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol _symbol_i = _symbols[offset + 2];
					final BodyDecl i = (BodyDecl) _symbol_i.value;
					 return l.add(i);
			}
			case 145: // interface_member_declaration = constant_declaration.c
			{
					final Symbol _symbol_c = _symbols[offset + 1];
					final BodyDecl c = (BodyDecl) _symbol_c.value;
					 return c;
			}
			case 146: // interface_member_declaration = abstract_method_declaration.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final BodyDecl a = (BodyDecl) _symbol_a.value;
					 return a;
			}
			case 147: // interface_member_declaration = class_declaration.c
			{
					final Symbol _symbol_c = _symbols[offset + 1];
					final ClassDecl c = (ClassDecl) _symbol_c.value;
					 return new MemberClassDecl(c);
			}
			case 148: // interface_member_declaration = interface_declaration.i
			{
					final Symbol _symbol_i = _symbols[offset + 1];
					final InterfaceDecl i = (InterfaceDecl) _symbol_i.value;
					 return new MemberInterfaceDecl(i);
			}
			case 149: // interface_member_declaration = SEMICOLON.SEMICOLON
			{
					final Symbol SEMICOLON = _symbols[offset + 1];
					 return new StaticInitializer(new Block());
			}
			case 150: // constant_declaration = field_declaration.f
			{
					final Symbol _symbol_f = _symbols[offset + 1];
					final BodyDecl f = (BodyDecl) _symbol_f.value;
					 return f;
			}
			case 151: // abstract_method_declaration = method_header.m SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final MethodDecl m = (MethodDecl) _symbol_m.value;
					final Symbol SEMICOLON = _symbols[offset + 2];
					 return m;
			}
			case 152: // array_initializer = LBRACE.LBRACE RBRACE.RBRACE
			{
					final Symbol LBRACE = _symbols[offset + 1];
					final Symbol RBRACE = _symbols[offset + 2];
					 return new ArrayInit(new List());
			}
			case 153: // array_initializer = LBRACE.LBRACE variable_initializers.v RBRACE.RBRACE
			{
					final Symbol LBRACE = _symbols[offset + 1];
					final Symbol _symbol_v = _symbols[offset + 2];
					final List v = (List) _symbol_v.value;
					final Symbol RBRACE = _symbols[offset + 3];
					 return new ArrayInit(v);
			}
			case 154: // array_initializer = LBRACE.LBRACE COMMA.COMMA RBRACE.RBRACE
			{
					final Symbol LBRACE = _symbols[offset + 1];
					final Symbol COMMA = _symbols[offset + 2];
					final Symbol RBRACE = _symbols[offset + 3];
					 return new ArrayInit(new List());
			}
			case 155: // array_initializer = LBRACE.LBRACE variable_initializers.v COMMA.COMMA RBRACE.RBRACE
			{
					final Symbol LBRACE = _symbols[offset + 1];
					final Symbol _symbol_v = _symbols[offset + 2];
					final List v = (List) _symbol_v.value;
					final Symbol COMMA = _symbols[offset + 3];
					final Symbol RBRACE = _symbols[offset + 4];
					 return new ArrayInit(v);
			}
			case 156: // variable_initializers = variable_initializer.v
			{
					final Symbol _symbol_v = _symbols[offset + 1];
					final Expr v = (Expr) _symbol_v.value;
					 return new List().add(v);
			}
			case 157: // variable_initializers = variable_initializers.l COMMA.COMMA variable_initializer.v
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol COMMA = _symbols[offset + 2];
					final Symbol _symbol_v = _symbols[offset + 3];
					final Expr v = (Expr) _symbol_v.value;
					 return l.add(v);
			}
			case 158: // block = LBRACE.LBRACE block_statements_opt.l RBRACE.RBRACE
			{
					final Symbol LBRACE = _symbols[offset + 1];
					final Symbol _symbol_l = _symbols[offset + 2];
					final List l = (List) _symbol_l.value;
					final Symbol RBRACE = _symbols[offset + 3];
					 return new Block(l);
			}
			case 159: // block_statements = block_statement.b
			{
					final Symbol _symbol_b = _symbols[offset + 1];
					final Stmt b = (Stmt) _symbol_b.value;
					 return new List().add(b);
			}
			case 160: // block_statements = block_statements.l block_statement.b
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol _symbol_b = _symbols[offset + 2];
					final Stmt b = (Stmt) _symbol_b.value;
					 return l.add(b);
			}
			case 161: // block_statement = local_variable_declaration_statement.l
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final VarDeclStmt l = (VarDeclStmt) _symbol_l.value;
					 return l;
			}
			case 162: // block_statement = class_declaration.c
			{
					final Symbol _symbol_c = _symbols[offset + 1];
					final ClassDecl c = (ClassDecl) _symbol_c.value;
					 return new LocalClassDeclStmt(c);
			}
			case 163: // block_statement = statement.s
			{
					final Symbol _symbol_s = _symbols[offset + 1];
					final Stmt s = (Stmt) _symbol_s.value;
					 return s;
			}
			case 164: // local_variable_declaration_statement = local_variable_declaration.l SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final VarDeclStmt l = (VarDeclStmt) _symbol_l.value;
					final Symbol SEMICOLON = _symbols[offset + 2];
					 return l;
			}
			case 165: // local_variable_declaration = type.t variable_declarators.l
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final Access t = (Access) _symbol_t.value;
					final Symbol _symbol_l = _symbols[offset + 2];
					final List l = (List) _symbol_l.value;
					 return new VarDeclStmt(new Modifiers(new List()), t, l);
			}
			case 166: // local_variable_declaration = modifiers.m type.t variable_declarators.l
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final List m = (List) _symbol_m.value;
					final Symbol _symbol_t = _symbols[offset + 2];
					final Access t = (Access) _symbol_t.value;
					final Symbol _symbol_l = _symbols[offset + 3];
					final List l = (List) _symbol_l.value;
					 return new VarDeclStmt(new Modifiers(m), t, l);
			}
			case 167: // statement = statement_without_trailing_substatement.s
			{
					final Symbol _symbol_s = _symbols[offset + 1];
					final Stmt s = (Stmt) _symbol_s.value;
					 return s;
			}
			case 168: // statement = labeled_statement.l
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final LabeledStmt l = (LabeledStmt) _symbol_l.value;
					 return l;
			}
			case 169: // statement = if_then_statement.i
			{
					final Symbol _symbol_i = _symbols[offset + 1];
					final IfStmt i = (IfStmt) _symbol_i.value;
					 return i;
			}
			case 170: // statement = if_then_else_statement.i
			{
					final Symbol _symbol_i = _symbols[offset + 1];
					final IfStmt i = (IfStmt) _symbol_i.value;
					 return i;
			}
			case 171: // statement = while_statement.w
			{
					final Symbol _symbol_w = _symbols[offset + 1];
					final WhileStmt w = (WhileStmt) _symbol_w.value;
					 return w;
			}
			case 172: // statement = for_statement.f
			{
					final Symbol _symbol_f = _symbols[offset + 1];
					final ForStmt f = (ForStmt) _symbol_f.value;
					 return f;
			}
			case 173: // statement_without_trailing_substatement = block.b
			{
					final Symbol _symbol_b = _symbols[offset + 1];
					final Block b = (Block) _symbol_b.value;
					 return b;
			}
			case 174: // statement_without_trailing_substatement = empty_statement.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final EmptyStmt e = (EmptyStmt) _symbol_e.value;
					 return e;
			}
			case 175: // statement_without_trailing_substatement = expression_statement.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final ExprStmt e = (ExprStmt) _symbol_e.value;
					 return e;
			}
			case 176: // statement_without_trailing_substatement = switch_statement.s
			{
					final Symbol _symbol_s = _symbols[offset + 1];
					final SwitchStmt s = (SwitchStmt) _symbol_s.value;
					 return s;
			}
			case 177: // statement_without_trailing_substatement = do_statement.d
			{
					final Symbol _symbol_d = _symbols[offset + 1];
					final DoStmt d = (DoStmt) _symbol_d.value;
					 return d;
			}
			case 178: // statement_without_trailing_substatement = break_statement.b
			{
					final Symbol _symbol_b = _symbols[offset + 1];
					final BreakStmt b = (BreakStmt) _symbol_b.value;
					 return b;
			}
			case 179: // statement_without_trailing_substatement = continue_statement.c
			{
					final Symbol _symbol_c = _symbols[offset + 1];
					final ContinueStmt c = (ContinueStmt) _symbol_c.value;
					 return c;
			}
			case 180: // statement_without_trailing_substatement = return_statement.r
			{
					final Symbol _symbol_r = _symbols[offset + 1];
					final ReturnStmt r = (ReturnStmt) _symbol_r.value;
					 return r;
			}
			case 181: // statement_without_trailing_substatement = synchronized_statement.s
			{
					final Symbol _symbol_s = _symbols[offset + 1];
					final SynchronizedStmt s = (SynchronizedStmt) _symbol_s.value;
					 return s;
			}
			case 182: // statement_without_trailing_substatement = throw_statement.t
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final ThrowStmt t = (ThrowStmt) _symbol_t.value;
					 return t;
			}
			case 183: // statement_without_trailing_substatement = try_statement.t
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final TryStmt t = (TryStmt) _symbol_t.value;
					 return t;
			}
			case 184: // statement_without_trailing_substatement = assert_statement.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final AssertStmt a = (AssertStmt) _symbol_a.value;
					 return a;
			}
			case 185: // statement_no_short_if = statement_without_trailing_substatement.s
			{
					final Symbol _symbol_s = _symbols[offset + 1];
					final Stmt s = (Stmt) _symbol_s.value;
					 return s;
			}
			case 186: // statement_no_short_if = labeled_statement_no_short_if.l
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final LabeledStmt l = (LabeledStmt) _symbol_l.value;
					 return l;
			}
			case 187: // statement_no_short_if = if_then_else_statement_no_short_if.i
			{
					final Symbol _symbol_i = _symbols[offset + 1];
					final IfStmt i = (IfStmt) _symbol_i.value;
					 return i;
			}
			case 188: // statement_no_short_if = while_statement_no_short_if.w
			{
					final Symbol _symbol_w = _symbols[offset + 1];
					final WhileStmt w = (WhileStmt) _symbol_w.value;
					 return w;
			}
			case 189: // statement_no_short_if = for_statement_no_short_if.f
			{
					final Symbol _symbol_f = _symbols[offset + 1];
					final ForStmt f = (ForStmt) _symbol_f.value;
					 return f;
			}
			case 190: // if_then_statement = IF.IF LPAREN.LPAREN expression.e RPAREN.RPAREN statement.s
			{
					final Symbol IF = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_e = _symbols[offset + 3];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol RPAREN = _symbols[offset + 4];
					final Symbol _symbol_s = _symbols[offset + 5];
					final Stmt s = (Stmt) _symbol_s.value;
					 return new IfStmt(e, s, new Opt());
			}
			case 191: // if_then_else_statement = IF.IF LPAREN.LPAREN expression.e RPAREN.RPAREN statement_no_short_if.t ELSE.ELSE statement.els
			{
					final Symbol IF = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_e = _symbols[offset + 3];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol RPAREN = _symbols[offset + 4];
					final Symbol _symbol_t = _symbols[offset + 5];
					final Stmt t = (Stmt) _symbol_t.value;
					final Symbol ELSE = _symbols[offset + 6];
					final Symbol _symbol_els = _symbols[offset + 7];
					final Stmt els = (Stmt) _symbol_els.value;
					 return new IfStmt(e, t, new Opt(els));
			}
			case 192: // if_then_else_statement_no_short_if = IF.IF LPAREN.LPAREN expression.e RPAREN.RPAREN statement_no_short_if.t ELSE.ELSE statement_no_short_if.els
			{
					final Symbol IF = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_e = _symbols[offset + 3];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol RPAREN = _symbols[offset + 4];
					final Symbol _symbol_t = _symbols[offset + 5];
					final Stmt t = (Stmt) _symbol_t.value;
					final Symbol ELSE = _symbols[offset + 6];
					final Symbol _symbol_els = _symbols[offset + 7];
					final Stmt els = (Stmt) _symbol_els.value;
					 return new IfStmt(e, t, new Opt(els));
			}
			case 193: // empty_statement = SEMICOLON.SEMICOLON
			{
					final Symbol SEMICOLON = _symbols[offset + 1];
					 return new EmptyStmt();
			}
			case 194: // labeled_statement = IDENTIFIER.id COLON.COLON statement.s
			{
					final Symbol id = _symbols[offset + 1];
					final Symbol COLON = _symbols[offset + 2];
					final Symbol _symbol_s = _symbols[offset + 3];
					final Stmt s = (Stmt) _symbol_s.value;
					 return new LabeledStmt(((String)id.value), s);
			}
			case 195: // labeled_statement_no_short_if = IDENTIFIER.id COLON.COLON statement_no_short_if.s
			{
					final Symbol id = _symbols[offset + 1];
					final Symbol COLON = _symbols[offset + 2];
					final Symbol _symbol_s = _symbols[offset + 3];
					final Stmt s = (Stmt) _symbol_s.value;
					 return new LabeledStmt(((String)id.value), s);
			}
			case 196: // expression_statement = statement_expression.e SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final ExprStmt e = (ExprStmt) _symbol_e.value;
					final Symbol SEMICOLON = _symbols[offset + 2];
					 return e;
			}
			case 197: // statement_expression = assignment.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					 return new ExprStmt(a);
			}
			case 198: // statement_expression = preincrement_expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return new ExprStmt(e);
			}
			case 199: // statement_expression = predecrement_expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return new ExprStmt(e);
			}
			case 200: // statement_expression = postincrement_expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return new ExprStmt(e);
			}
			case 201: // statement_expression = postdecrement_expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return new ExprStmt(e);
			}
			case 202: // statement_expression = method_invocation.i
			{
					final Symbol _symbol_i = _symbols[offset + 1];
					final Access i = (Access) _symbol_i.value;
					 return new ExprStmt(i);
			}
			case 203: // statement_expression = class_instance_creation_expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return new ExprStmt(e);
			}
			case 204: // switch_statement = SWITCH.SWITCH LPAREN.LPAREN expression.e RPAREN.RPAREN switch_block.l
			{
					final Symbol SWITCH = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_e = _symbols[offset + 3];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol RPAREN = _symbols[offset + 4];
					final Symbol _symbol_l = _symbols[offset + 5];
					final Block l = (Block) _symbol_l.value;
					 return new SwitchStmt(e, l);
			}
			case 205: // switch_block = LBRACE.LBRACE switch_block_statement_groups.l switch_labels.s RBRACE.RBRACE
			{
					final Symbol LBRACE = _symbols[offset + 1];
					final Symbol _symbol_l = _symbols[offset + 2];
					final List l = (List) _symbol_l.value;
					final Symbol _symbol_s = _symbols[offset + 3];
					final List s = (List) _symbol_s.value;
					final Symbol RBRACE = _symbols[offset + 4];
					 for(int ii = 0; ii < s.getNumChildNoTransform(); ii++) l.add(s.getChildNoTransform(ii)); return new Block(l);
			}
			case 206: // switch_block = LBRACE.LBRACE switch_block_statement_groups.l RBRACE.RBRACE
			{
					final Symbol LBRACE = _symbols[offset + 1];
					final Symbol _symbol_l = _symbols[offset + 2];
					final List l = (List) _symbol_l.value;
					final Symbol RBRACE = _symbols[offset + 3];
					 return new Block(l);
			}
			case 207: // switch_block = LBRACE.LBRACE switch_labels.l RBRACE.RBRACE
			{
					final Symbol LBRACE = _symbols[offset + 1];
					final Symbol _symbol_l = _symbols[offset + 2];
					final List l = (List) _symbol_l.value;
					final Symbol RBRACE = _symbols[offset + 3];
					 return new Block(l);
			}
			case 208: // switch_block = LBRACE.LBRACE RBRACE.RBRACE
			{
					final Symbol LBRACE = _symbols[offset + 1];
					final Symbol RBRACE = _symbols[offset + 2];
					 return new Block(new List());
			}
			case 209: // switch_block_statement_groups = switch_block_statement_group.g
			{
					final Symbol _symbol_g = _symbols[offset + 1];
					final List g = (List) _symbol_g.value;
					 return g;
			}
			case 210: // switch_block_statement_groups = switch_block_statement_groups.l switch_block_statement_group.g
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol _symbol_g = _symbols[offset + 2];
					final List g = (List) _symbol_g.value;
					 for(int ii = 0; ii < g.getNumChildNoTransform(); ii++)
           l.add(g.getChildNoTransform(ii));
         return l;
			}
			case 211: // switch_block_statement_group = switch_labels.l block_statements.bl
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol _symbol_bl = _symbols[offset + 2];
					final List bl = (List) _symbol_bl.value;
					 for(int ii = 0; ii < bl.getNumChildNoTransform(); ii++)
          l.add(bl.getChildNoTransform(ii));
          return l;
			}
			case 212: // switch_labels = switch_label.s
			{
					final Symbol _symbol_s = _symbols[offset + 1];
					final Case s = (Case) _symbol_s.value;
					 return new List().add(s);
			}
			case 213: // switch_labels = switch_labels.l switch_label.s
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol _symbol_s = _symbols[offset + 2];
					final Case s = (Case) _symbol_s.value;
					 return l.add(s);
			}
			case 214: // switch_label = CASE.CASE constant_expression.e COLON.COLON
			{
					final Symbol CASE = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol COLON = _symbols[offset + 3];
					 return new ConstCase(e);
			}
			case 215: // switch_label = DEFAULT.DEFAULT COLON.COLON
			{
					final Symbol DEFAULT = _symbols[offset + 1];
					final Symbol COLON = _symbols[offset + 2];
					 return new DefaultCase();
			}
			case 216: // while_statement = WHILE.WHILE LPAREN.LPAREN expression.e RPAREN.RPAREN statement.s
			{
					final Symbol WHILE = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_e = _symbols[offset + 3];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol RPAREN = _symbols[offset + 4];
					final Symbol _symbol_s = _symbols[offset + 5];
					final Stmt s = (Stmt) _symbol_s.value;
					 return new WhileStmt(e, s);
			}
			case 217: // while_statement_no_short_if = WHILE.WHILE LPAREN.LPAREN expression.e RPAREN.RPAREN statement_no_short_if.s
			{
					final Symbol WHILE = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_e = _symbols[offset + 3];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol RPAREN = _symbols[offset + 4];
					final Symbol _symbol_s = _symbols[offset + 5];
					final Stmt s = (Stmt) _symbol_s.value;
					 return new WhileStmt(e, s);
			}
			case 218: // do_statement = DO.DO statement.s WHILE.WHILE LPAREN.LPAREN expression.e RPAREN.RPAREN SEMICOLON.SEMICOLON
			{
					final Symbol DO = _symbols[offset + 1];
					final Symbol _symbol_s = _symbols[offset + 2];
					final Stmt s = (Stmt) _symbol_s.value;
					final Symbol WHILE = _symbols[offset + 3];
					final Symbol LPAREN = _symbols[offset + 4];
					final Symbol _symbol_e = _symbols[offset + 5];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol RPAREN = _symbols[offset + 6];
					final Symbol SEMICOLON = _symbols[offset + 7];
					 return new DoStmt(s, e);
			}
			case 219: // for_statement = FOR.FOR LPAREN.LPAREN for_init_opt.i SEMICOLON.SEMICOLON expression_opt.e SEMICOLON.SEMICOLON_ for_update_opt.u RPAREN.RPAREN statement.s
			{
					final Symbol FOR = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_i = _symbols[offset + 3];
					final List i = (List) _symbol_i.value;
					final Symbol SEMICOLON = _symbols[offset + 4];
					final Symbol _symbol_e = _symbols[offset + 5];
					final Opt e = (Opt) _symbol_e.value;
					final Symbol SEMICOLON_ = _symbols[offset + 6];
					final Symbol _symbol_u = _symbols[offset + 7];
					final List u = (List) _symbol_u.value;
					final Symbol RPAREN = _symbols[offset + 8];
					final Symbol _symbol_s = _symbols[offset + 9];
					final Stmt s = (Stmt) _symbol_s.value;
					 return new ForStmt(i, e, u, s);
			}
			case 220: // for_statement_no_short_if = FOR.FOR LPAREN.LPAREN for_init_opt.i SEMICOLON.SEMICOLON expression_opt.e SEMICOLON.SEMICOLON_ for_update_opt.u RPAREN.RPAREN statement_no_short_if.s
			{
					final Symbol FOR = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_i = _symbols[offset + 3];
					final List i = (List) _symbol_i.value;
					final Symbol SEMICOLON = _symbols[offset + 4];
					final Symbol _symbol_e = _symbols[offset + 5];
					final Opt e = (Opt) _symbol_e.value;
					final Symbol SEMICOLON_ = _symbols[offset + 6];
					final Symbol _symbol_u = _symbols[offset + 7];
					final List u = (List) _symbol_u.value;
					final Symbol RPAREN = _symbols[offset + 8];
					final Symbol _symbol_s = _symbols[offset + 9];
					final Stmt s = (Stmt) _symbol_s.value;
					 return new ForStmt(i, e, u, s);
			}
			case 221: // for_init = statement_expression_list.l
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					 return l;
			}
			case 222: // for_init = local_variable_declaration.d
			{
					final Symbol _symbol_d = _symbols[offset + 1];
					final VarDeclStmt d = (VarDeclStmt) _symbol_d.value;
					 return new List().add(d);
			}
			case 223: // for_update = statement_expression_list.l
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					 return l;
			}
			case 224: // statement_expression_list = statement_expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final ExprStmt e = (ExprStmt) _symbol_e.value;
					 return new List().add(e);
			}
			case 225: // statement_expression_list = statement_expression_list.l COMMA.COMMA statement_expression.e
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol COMMA = _symbols[offset + 2];
					final Symbol _symbol_e = _symbols[offset + 3];
					final ExprStmt e = (ExprStmt) _symbol_e.value;
					 return l.add(e);
			}
			case 226: // break_statement = BREAK.BREAK IDENTIFIER.id SEMICOLON.SEMICOLON
			{
					final Symbol BREAK = _symbols[offset + 1];
					final Symbol id = _symbols[offset + 2];
					final Symbol SEMICOLON = _symbols[offset + 3];
					 return new BreakStmt(((String)id.value));
			}
			case 227: // break_statement = BREAK.BREAK SEMICOLON.SEMICOLON
			{
					final Symbol BREAK = _symbols[offset + 1];
					final Symbol SEMICOLON = _symbols[offset + 2];
					 return new BreakStmt("");
			}
			case 228: // continue_statement = CONTINUE.CONTINUE IDENTIFIER.id SEMICOLON.SEMICOLON
			{
					final Symbol CONTINUE = _symbols[offset + 1];
					final Symbol id = _symbols[offset + 2];
					final Symbol SEMICOLON = _symbols[offset + 3];
					 return new ContinueStmt(((String)id.value));
			}
			case 229: // continue_statement = CONTINUE.CONTINUE SEMICOLON.SEMICOLON
			{
					final Symbol CONTINUE = _symbols[offset + 1];
					final Symbol SEMICOLON = _symbols[offset + 2];
					 return new ContinueStmt("");
			}
			case 230: // return_statement = RETURN.RETURN expression_opt.e SEMICOLON.SEMICOLON
			{
					final Symbol RETURN = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final Opt e = (Opt) _symbol_e.value;
					final Symbol SEMICOLON = _symbols[offset + 3];
					 return new ReturnStmt(e);
			}
			case 231: // throw_statement = THROW.THROW expression.e SEMICOLON.SEMICOLON
			{
					final Symbol THROW = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol SEMICOLON = _symbols[offset + 3];
					 return new ThrowStmt(e);
			}
			case 232: // synchronized_statement = SYNCHRONIZED.SYNCHRONIZED LPAREN.LPAREN expression.e RPAREN.RPAREN block.b
			{
					final Symbol SYNCHRONIZED = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_e = _symbols[offset + 3];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol RPAREN = _symbols[offset + 4];
					final Symbol _symbol_b = _symbols[offset + 5];
					final Block b = (Block) _symbol_b.value;
					 return new SynchronizedStmt(e, b);
			}
			case 233: // try_statement = TRY.TRY block.b catches.c
			{
					final Symbol TRY = _symbols[offset + 1];
					final Symbol _symbol_b = _symbols[offset + 2];
					final Block b = (Block) _symbol_b.value;
					final Symbol _symbol_c = _symbols[offset + 3];
					final List c = (List) _symbol_c.value;
					 return new TryStmt(b, c, new Opt());
			}
			case 234: // try_statement = TRY.TRY block.b finally.f
			{
					final Symbol TRY = _symbols[offset + 1];
					final Symbol _symbol_b = _symbols[offset + 2];
					final Block b = (Block) _symbol_b.value;
					final Symbol _symbol_f = _symbols[offset + 3];
					final Block f = (Block) _symbol_f.value;
					 return new TryStmt(b, new List(), new Opt(f));
			}
			case 235: // try_statement = TRY.TRY block.b catches.c finally.f
			{
					final Symbol TRY = _symbols[offset + 1];
					final Symbol _symbol_b = _symbols[offset + 2];
					final Block b = (Block) _symbol_b.value;
					final Symbol _symbol_c = _symbols[offset + 3];
					final List c = (List) _symbol_c.value;
					final Symbol _symbol_f = _symbols[offset + 4];
					final Block f = (Block) _symbol_f.value;
					 return new TryStmt(b, c, new Opt(f));
			}
			case 236: // catches = catch_clause.c
			{
					final Symbol _symbol_c = _symbols[offset + 1];
					final CatchClause c = (CatchClause) _symbol_c.value;
					 return new List().add(c);
			}
			case 237: // catches = catches.l catch_clause.c
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol _symbol_c = _symbols[offset + 2];
					final CatchClause c = (CatchClause) _symbol_c.value;
					 return l.add(c);
			}
			case 238: // catch_clause = CATCH.CATCH LPAREN.LPAREN formal_parameter.p RPAREN.RPAREN block.b
			{
					final Symbol CATCH = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_p = _symbols[offset + 3];
					final ParameterDeclaration p = (ParameterDeclaration) _symbol_p.value;
					final Symbol RPAREN = _symbols[offset + 4];
					final Symbol _symbol_b = _symbols[offset + 5];
					final Block b = (Block) _symbol_b.value;
					 return new CatchClause(p, b);
			}
			case 239: // finally = FINALLY.FINALLY block.b
			{
					final Symbol FINALLY = _symbols[offset + 1];
					final Symbol _symbol_b = _symbols[offset + 2];
					final Block b = (Block) _symbol_b.value;
					 return b;
			}
			case 240: // assert_statement = ASSERT.ASSERT expression.e SEMICOLON.SEMICOLON
			{
					final Symbol ASSERT = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol SEMICOLON = _symbols[offset + 3];
					 return new AssertStmt(e, new Opt());
			}
			case 241: // assert_statement = ASSERT.ASSERT expression.e COLON.COLON expression.s SEMICOLON.SEMICOLON
			{
					final Symbol ASSERT = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol COLON = _symbols[offset + 3];
					final Symbol _symbol_s = _symbols[offset + 4];
					final Expr s = (Expr) _symbol_s.value;
					final Symbol SEMICOLON = _symbols[offset + 5];
					 return new AssertStmt(e, new Opt(s));
			}
			case 242: // primary = primary_no_new_array.p
			{
					final Symbol _symbol_p = _symbols[offset + 1];
					final Expr p = (Expr) _symbol_p.value;
					 return p;
			}
			case 243: // primary = array_creation_init.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					 return a;
			}
			case 244: // primary = array_creation_uninit.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					 return a;
			}
			case 245: // class_literal = CLASS.CLASS
			{
					final Symbol CLASS = _symbols[offset + 1];
					 return new ClassAccess();
			}
			case 246: // subclass_body = class_body.b
			{
					final Symbol _symbol_b = _symbols[offset + 1];
					final List b = (List) _symbol_b.value;
					 return new Opt(new AnonymousDecl(new Modifiers(), "Anonymous", b));
			}
			case 247: // argument_list = expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return new List().add(e);
			}
			case 248: // argument_list = argument_list.l COMMA.COMMA expression.e
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol COMMA = _symbols[offset + 2];
					final Symbol _symbol_e = _symbols[offset + 3];
					final Expr e = (Expr) _symbol_e.value;
					 return l.add(e);
			}
			case 249: // array_creation_uninit = NEW.NEW primitive_type.t dim_exprs.d
			{
					final Symbol NEW = _symbols[offset + 1];
					final Symbol _symbol_t = _symbols[offset + 2];
					final Access t = (Access) _symbol_t.value;
					final Symbol _symbol_d = _symbols[offset + 3];
					final List d = (List) _symbol_d.value;
					 return new ArrayCreationExpr(t.addArrayDims(d), new Opt());
			}
			case 250: // array_creation_uninit = NEW.NEW primitive_type.t dim_exprs.d dims.e
			{
					final Symbol NEW = _symbols[offset + 1];
					final Symbol _symbol_t = _symbols[offset + 2];
					final Access t = (Access) _symbol_t.value;
					final Symbol _symbol_d = _symbols[offset + 3];
					final List d = (List) _symbol_d.value;
					final Symbol _symbol_e = _symbols[offset + 4];
					final List e = (List) _symbol_e.value;
					 return new ArrayCreationExpr(t.addArrayDims(d).addArrayDims(e), new Opt());
			}
			case 251: // array_creation_uninit = NEW.NEW class_or_interface_type.t dim_exprs.d
			{
					final Symbol NEW = _symbols[offset + 1];
					final Symbol _symbol_t = _symbols[offset + 2];
					final Access t = (Access) _symbol_t.value;
					final Symbol _symbol_d = _symbols[offset + 3];
					final List d = (List) _symbol_d.value;
					 return new ArrayCreationExpr(t.addArrayDims(d), new Opt());
			}
			case 252: // array_creation_uninit = NEW.NEW class_or_interface_type.t dim_exprs.d dims.e
			{
					final Symbol NEW = _symbols[offset + 1];
					final Symbol _symbol_t = _symbols[offset + 2];
					final Access t = (Access) _symbol_t.value;
					final Symbol _symbol_d = _symbols[offset + 3];
					final List d = (List) _symbol_d.value;
					final Symbol _symbol_e = _symbols[offset + 4];
					final List e = (List) _symbol_e.value;
					 return new ArrayCreationExpr(t.addArrayDims(d).addArrayDims(e), new Opt());
			}
			case 253: // array_creation_init = NEW.NEW primitive_type.t dims.d array_initializer.i
			{
					final Symbol NEW = _symbols[offset + 1];
					final Symbol _symbol_t = _symbols[offset + 2];
					final Access t = (Access) _symbol_t.value;
					final Symbol _symbol_d = _symbols[offset + 3];
					final List d = (List) _symbol_d.value;
					final Symbol _symbol_i = _symbols[offset + 4];
					final ArrayInit i = (ArrayInit) _symbol_i.value;
					 return new ArrayCreationExpr(t.addArrayDims(d), new Opt(i));
			}
			case 254: // array_creation_init = NEW.NEW class_or_interface_type.t dims.d array_initializer.i
			{
					final Symbol NEW = _symbols[offset + 1];
					final Symbol _symbol_t = _symbols[offset + 2];
					final Access t = (Access) _symbol_t.value;
					final Symbol _symbol_d = _symbols[offset + 3];
					final List d = (List) _symbol_d.value;
					final Symbol _symbol_i = _symbols[offset + 4];
					final ArrayInit i = (ArrayInit) _symbol_i.value;
					 return new ArrayCreationExpr(t.addArrayDims(d), new Opt(i));
			}
			case 255: // dim_exprs = dim_expr.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Dims e = (Dims) _symbol_e.value;
					 return new List().add(e);
			}
			case 256: // dim_exprs = dim_exprs.l dim_expr.e
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol _symbol_e = _symbols[offset + 2];
					final Dims e = (Dims) _symbol_e.value;
					 return l.add(e);
			}
			case 257: // dim_expr = LBRACK.LBRACK expression.e RBRACK.RBRACK
			{
					final Symbol LBRACK = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol RBRACK = _symbols[offset + 3];
					 return new Dims(new Opt(e));
			}
			case 258: // dims = LBRACK.LBRACK RBRACK.RBRACK
			{
					final Symbol LBRACK = _symbols[offset + 1];
					final Symbol RBRACK = _symbols[offset + 2];
					 return new List().add(new Dims(new Opt()));
			}
			case 259: // dims = dims.l LBRACK.LBRACK RBRACK.RBRACK
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol LBRACK = _symbols[offset + 2];
					final Symbol RBRACK = _symbols[offset + 3];
					 return l.add(new Dims(new Opt()));
			}
			case 260: // field_access = primary.p DOT.DOT simple_name.id
			{
					final Symbol _symbol_p = _symbols[offset + 1];
					final Expr p = (Expr) _symbol_p.value;
					final Symbol DOT = _symbols[offset + 2];
					final Symbol _symbol_id = _symbols[offset + 3];
					final Access id = (Access) _symbol_id.value;
					 return p.qualifiesAccess(id);
			}
			case 261: // field_access = SUPER.SUPER DOT.DOT simple_name.id
			{
					final Symbol SUPER = _symbols[offset + 1];
					final Symbol DOT = _symbols[offset + 2];
					final Symbol _symbol_id = _symbols[offset + 3];
					final Access id = (Access) _symbol_id.value;
					 SuperAccess s = new SuperAccess("super");
       s.setStart(SUPER.getStart());
       s.setEnd(SUPER.getEnd());
       return s.qualifiesAccess(id);
			}
			case 262: // field_access = name.n DOT.DOT SUPER.SUPER DOT.DOT_ simple_name.id
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Access n = (Access) _symbol_n.value;
					final Symbol DOT = _symbols[offset + 2];
					final Symbol SUPER = _symbols[offset + 3];
					final Symbol DOT_ = _symbols[offset + 4];
					final Symbol _symbol_id = _symbols[offset + 5];
					final Access id = (Access) _symbol_id.value;
					 SuperAccess s = new SuperAccess("super");
       s.setStart(SUPER.getStart());
       s.setEnd(SUPER.getEnd());
       return n.qualifiesAccess(s).qualifiesAccess(id);
			}
			case 263: // method_invocation = name.n LPAREN.LPAREN argument_list_opt.l RPAREN.RPAREN
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Access n = (Access) _symbol_n.value;
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_l = _symbols[offset + 3];
					final List l = (List) _symbol_l.value;
					final Symbol RPAREN = _symbols[offset + 4];
					 if(n instanceof AbstractDot) {    
                                                               AbstractDot d = (AbstractDot)n; 
                                                               ParseName pn = (ParseName)d.extractLast();
                                                               MethodAccess m = new MethodAccess(pn.getID(), l);
                                                               m.setStart(n.getStart()); // add location information
                                                               m.setEnd(RPAREN.getEnd()); // add location information
                                                               d.replaceLast(m);
                                                               return d;
                                                             }
                                                             else {
                                                               ParseName pn = (ParseName)n;
                                                               return new MethodAccess(pn.getID(), l);
                                                             }
			}
			case 264: // method_invocation = primary.p DOT.DOT IDENTIFIER.IDENTIFIER LPAREN.LPAREN argument_list_opt.l RPAREN.RPAREN
			{
					final Symbol _symbol_p = _symbols[offset + 1];
					final Expr p = (Expr) _symbol_p.value;
					final Symbol DOT = _symbols[offset + 2];
					final Symbol IDENTIFIER = _symbols[offset + 3];
					final Symbol LPAREN = _symbols[offset + 4];
					final Symbol _symbol_l = _symbols[offset + 5];
					final List l = (List) _symbol_l.value;
					final Symbol RPAREN = _symbols[offset + 6];
					 MethodAccess m = new MethodAccess(IDENTIFIER, l);
        m.setStart(IDENTIFIER.getStart()); // add location information
        m.setEnd(RPAREN.getEnd()); // add location information
        return p.qualifiesAccess(m);
			}
			case 265: // method_invocation = SUPER.SUPER DOT.DOT IDENTIFIER.IDENTIFIER LPAREN.LPAREN argument_list_opt.l RPAREN.RPAREN
			{
					final Symbol SUPER = _symbols[offset + 1];
					final Symbol DOT = _symbols[offset + 2];
					final Symbol IDENTIFIER = _symbols[offset + 3];
					final Symbol LPAREN = _symbols[offset + 4];
					final Symbol _symbol_l = _symbols[offset + 5];
					final List l = (List) _symbol_l.value;
					final Symbol RPAREN = _symbols[offset + 6];
					 SuperAccess s = new SuperAccess("super");
        s.setStart(SUPER.getStart());
        s.setEnd(SUPER.getEnd());
        MethodAccess m = new MethodAccess(IDENTIFIER, l);
        m.setStart(IDENTIFIER.getStart());
        m.setEnd(RPAREN.getEnd());
        return s.qualifiesAccess(m);
			}
			case 266: // method_invocation = name.n DOT.DOT SUPER.SUPER DOT.DOT_ IDENTIFIER.IDENTIFIER LPAREN.LPAREN argument_list_opt.l RPAREN.RPAREN
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Access n = (Access) _symbol_n.value;
					final Symbol DOT = _symbols[offset + 2];
					final Symbol SUPER = _symbols[offset + 3];
					final Symbol DOT_ = _symbols[offset + 4];
					final Symbol IDENTIFIER = _symbols[offset + 5];
					final Symbol LPAREN = _symbols[offset + 6];
					final Symbol _symbol_l = _symbols[offset + 7];
					final List l = (List) _symbol_l.value;
					final Symbol RPAREN = _symbols[offset + 8];
					 SuperAccess s = new SuperAccess("super");
        s.setStart(SUPER.getStart());
        s.setEnd(SUPER.getEnd());
        MethodAccess m = new MethodAccess(IDENTIFIER, l);
        m.setStart(IDENTIFIER.getStart());
        m.setEnd(RPAREN.getEnd());
        return n.qualifiesAccess(s).qualifiesAccess(m);
			}
			case 267: // array_access = name.n LBRACK.LBRACK expression.e RBRACK.RBRACK
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Access n = (Access) _symbol_n.value;
					final Symbol LBRACK = _symbols[offset + 2];
					final Symbol _symbol_e = _symbols[offset + 3];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol RBRACK = _symbols[offset + 4];
					 ArrayAccess a = new ArrayAccess(e);
                                                         a.setStart(LBRACK.getStart());
                                                         a.setEnd(RBRACK.getEnd());
                                                         return n.qualifiesAccess(a);
			}
			case 268: // array_access = primary_no_new_array.p LBRACK.LBRACK expression.e RBRACK.RBRACK
			{
					final Symbol _symbol_p = _symbols[offset + 1];
					final Expr p = (Expr) _symbol_p.value;
					final Symbol LBRACK = _symbols[offset + 2];
					final Symbol _symbol_e = _symbols[offset + 3];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol RBRACK = _symbols[offset + 4];
					 ArrayAccess a = new ArrayAccess(e);
                                                         a.setStart(LBRACK.getStart());
                                                         a.setEnd(RBRACK.getEnd());
                                                         return p.qualifiesAccess(a);
			}
			case 269: // postfix_expression = primary.p
			{
					final Symbol _symbol_p = _symbols[offset + 1];
					final Expr p = (Expr) _symbol_p.value;
					 return p;
			}
			case 270: // postfix_expression = name.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Access n = (Access) _symbol_n.value;
					 return n;
			}
			case 271: // postfix_expression = postincrement_expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 272: // postfix_expression = postdecrement_expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 273: // postincrement_expression = postfix_expression.e PLUSPLUS.PLUSPLUS
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol PLUSPLUS = _symbols[offset + 2];
					 return new PostIncExpr(e);
			}
			case 274: // postdecrement_expression = postfix_expression.e MINUSMINUS.MINUSMINUS
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol MINUSMINUS = _symbols[offset + 2];
					 return new PostDecExpr(e);
			}
			case 275: // unary_expression = preincrement_expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 276: // unary_expression = predecrement_expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 277: // unary_expression = PLUS.PLUS unary_expression.e
			{
					final Symbol PLUS = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expr e = (Expr) _symbol_e.value;
					 return new PlusExpr(e);
			}
			case 278: // unary_expression = MINUS.MINUS unary_expression.e
			{
					final Symbol MINUS = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expr e = (Expr) _symbol_e.value;
					 return new MinusExpr(e);
			}
			case 279: // unary_expression = unary_expression_not_plus_minus.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 280: // preincrement_expression = PLUSPLUS.PLUSPLUS unary_expression.e
			{
					final Symbol PLUSPLUS = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expr e = (Expr) _symbol_e.value;
					 return new PreIncExpr(e);
			}
			case 281: // predecrement_expression = MINUSMINUS.MINUSMINUS unary_expression.e
			{
					final Symbol MINUSMINUS = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expr e = (Expr) _symbol_e.value;
					 return new PreDecExpr(e);
			}
			case 282: // unary_expression_not_plus_minus = postfix_expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 283: // unary_expression_not_plus_minus = COMP.COMP unary_expression.e
			{
					final Symbol COMP = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expr e = (Expr) _symbol_e.value;
					 return new BitNotExpr(e);
			}
			case 284: // unary_expression_not_plus_minus = NOT.NOT unary_expression.e
			{
					final Symbol NOT = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expr e = (Expr) _symbol_e.value;
					 return new LogNotExpr(e);
			}
			case 285: // unary_expression_not_plus_minus = cast_expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 286: // cast_expression = LPAREN.LPAREN primitive_type.t RPAREN.RPAREN unary_expression.e
			{
					final Symbol LPAREN = _symbols[offset + 1];
					final Symbol _symbol_t = _symbols[offset + 2];
					final Access t = (Access) _symbol_t.value;
					final Symbol RPAREN = _symbols[offset + 3];
					final Symbol _symbol_e = _symbols[offset + 4];
					final Expr e = (Expr) _symbol_e.value;
					 return new CastExpr(t.addArrayDims(new List()), e);
			}
			case 287: // cast_expression = LPAREN.LPAREN primitive_type.t dims.d RPAREN.RPAREN unary_expression.e
			{
					final Symbol LPAREN = _symbols[offset + 1];
					final Symbol _symbol_t = _symbols[offset + 2];
					final Access t = (Access) _symbol_t.value;
					final Symbol _symbol_d = _symbols[offset + 3];
					final List d = (List) _symbol_d.value;
					final Symbol RPAREN = _symbols[offset + 4];
					final Symbol _symbol_e = _symbols[offset + 5];
					final Expr e = (Expr) _symbol_e.value;
					 return new CastExpr(t.addArrayDims(d), e);
			}
			case 288: // cast_expression = LPAREN.LPAREN name.n RPAREN.RPAREN unary_expression_not_plus_minus.e
			{
					final Symbol LPAREN = _symbols[offset + 1];
					final Symbol _symbol_n = _symbols[offset + 2];
					final Access n = (Access) _symbol_n.value;
					final Symbol RPAREN = _symbols[offset + 3];
					final Symbol _symbol_e = _symbols[offset + 4];
					final Expr e = (Expr) _symbol_e.value;
					 return new CastExpr(n.addArrayDims(new List()), e);
			}
			case 289: // cast_expression = LPAREN.LPAREN name.n dims.d RPAREN.RPAREN unary_expression_not_plus_minus.e
			{
					final Symbol LPAREN = _symbols[offset + 1];
					final Symbol _symbol_n = _symbols[offset + 2];
					final Access n = (Access) _symbol_n.value;
					final Symbol _symbol_d = _symbols[offset + 3];
					final List d = (List) _symbol_d.value;
					final Symbol RPAREN = _symbols[offset + 4];
					final Symbol _symbol_e = _symbols[offset + 5];
					final Expr e = (Expr) _symbol_e.value;
					 return new CastExpr(n.addArrayDims(d), e);
			}
			case 290: // multiplicative_expression = unary_expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 291: // multiplicative_expression = multiplicative_expression.e1 MULT.MULT unary_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol MULT = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new MulExpr(e1, e2);
			}
			case 292: // multiplicative_expression = multiplicative_expression.e1 DIV.DIV unary_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol DIV = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new DivExpr(e1, e2);
			}
			case 293: // multiplicative_expression = multiplicative_expression.e1 MOD.MOD unary_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol MOD = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new ModExpr(e1, e2);
			}
			case 294: // additive_expression = multiplicative_expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 295: // additive_expression = additive_expression.e1 PLUS.PLUS multiplicative_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol PLUS = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new AddExpr(e1, e2);
			}
			case 296: // additive_expression = additive_expression.e1 MINUS.MINUS multiplicative_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol MINUS = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new SubExpr(e1, e2);
			}
			case 297: // shift_expression = additive_expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 298: // shift_expression = shift_expression.e1 LSHIFT.LSHIFT additive_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol LSHIFT = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new LShiftExpr(e1, e2);
			}
			case 299: // shift_expression = shift_expression.e1 RSHIFT.RSHIFT additive_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol RSHIFT = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new RShiftExpr(e1, e2);
			}
			case 300: // shift_expression = shift_expression.e1 URSHIFT.URSHIFT additive_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol URSHIFT = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new URShiftExpr(e1, e2);
			}
			case 301: // relational_expression = shift_expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 302: // relational_expression = relational_expression.e1 LT.LT shift_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol LT = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new LTExpr(e1, e2);
			}
			case 303: // relational_expression = relational_expression.e1 GT.GT shift_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol GT = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new GTExpr(e1, e2);
			}
			case 304: // relational_expression = relational_expression.e1 LTEQ.LTEQ shift_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol LTEQ = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new LEExpr(e1, e2);
			}
			case 305: // relational_expression = relational_expression.e1 GTEQ.GTEQ shift_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol GTEQ = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new GEExpr(e1, e2);
			}
			case 306: // relational_expression = relational_expression.e INSTANCEOF.INSTANCEOF reference_type.t
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol INSTANCEOF = _symbols[offset + 2];
					final Symbol _symbol_t = _symbols[offset + 3];
					final Access t = (Access) _symbol_t.value;
					 return new InstanceOfExpr(e, t);
			}
			case 307: // equality_expression = relational_expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 308: // equality_expression = equality_expression.e1 EQEQ.EQEQ relational_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol EQEQ = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new EQExpr(e1, e2);
			}
			case 309: // equality_expression = equality_expression.e1 NOTEQ.NOTEQ relational_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol NOTEQ = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new NEExpr(e1, e2);
			}
			case 310: // and_expression = equality_expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 311: // and_expression = and_expression.e1 AND.AND equality_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol AND = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new AndBitwiseExpr(e1, e2);
			}
			case 312: // exclusive_or_expression = and_expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 313: // exclusive_or_expression = exclusive_or_expression.e1 XOR.XOR and_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol XOR = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new XorBitwiseExpr(e1, e2);
			}
			case 314: // inclusive_or_expression = exclusive_or_expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 315: // inclusive_or_expression = inclusive_or_expression.e1 OR.OR exclusive_or_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol OR = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new OrBitwiseExpr(e1, e2);
			}
			case 316: // conditional_and_expression = inclusive_or_expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 317: // conditional_and_expression = conditional_and_expression.e1 ANDAND.ANDAND inclusive_or_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol ANDAND = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new AndLogicalExpr(e1, e2);
			}
			case 318: // conditional_or_expression = conditional_and_expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 319: // conditional_or_expression = conditional_or_expression.e1 OROR.OROR conditional_and_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol OROR = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new OrLogicalExpr(e1, e2);
			}
			case 320: // conditional_expression = conditional_or_expression.c
			{
					final Symbol _symbol_c = _symbols[offset + 1];
					final Expr c = (Expr) _symbol_c.value;
					 return c;
			}
			case 321: // conditional_expression = conditional_or_expression.c QUESTION.QUESTION expression.e1 COLON.COLON conditional_expression.e2
			{
					final Symbol _symbol_c = _symbols[offset + 1];
					final Expr c = (Expr) _symbol_c.value;
					final Symbol QUESTION = _symbols[offset + 2];
					final Symbol _symbol_e1 = _symbols[offset + 3];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol COLON = _symbols[offset + 4];
					final Symbol _symbol_e2 = _symbols[offset + 5];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new ConditionalExpr(c, e1, e2);
			}
			case 322: // assignment_expression = conditional_expression.c
			{
					final Symbol _symbol_c = _symbols[offset + 1];
					final Expr c = (Expr) _symbol_c.value;
					 return c;
			}
			case 323: // assignment_expression = assignment.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					 return a;
			}
			case 324: // assignment = postfix_expression.dest EQ.EQ assignment_expression.source
			{
					final Symbol _symbol_dest = _symbols[offset + 1];
					final Expr dest = (Expr) _symbol_dest.value;
					final Symbol EQ = _symbols[offset + 2];
					final Symbol _symbol_source = _symbols[offset + 3];
					final Expr source = (Expr) _symbol_source.value;
					 return new AssignSimpleExpr(dest, source);
			}
			case 325: // assignment = postfix_expression.dest MULTEQ.MULTEQ assignment_expression.source
			{
					final Symbol _symbol_dest = _symbols[offset + 1];
					final Expr dest = (Expr) _symbol_dest.value;
					final Symbol MULTEQ = _symbols[offset + 2];
					final Symbol _symbol_source = _symbols[offset + 3];
					final Expr source = (Expr) _symbol_source.value;
					 return new AssignMulExpr(dest, source);
			}
			case 326: // assignment = postfix_expression.dest DIVEQ.DIVEQ assignment_expression.source
			{
					final Symbol _symbol_dest = _symbols[offset + 1];
					final Expr dest = (Expr) _symbol_dest.value;
					final Symbol DIVEQ = _symbols[offset + 2];
					final Symbol _symbol_source = _symbols[offset + 3];
					final Expr source = (Expr) _symbol_source.value;
					 return new AssignDivExpr(dest, source);
			}
			case 327: // assignment = postfix_expression.dest MODEQ.MODEQ assignment_expression.source
			{
					final Symbol _symbol_dest = _symbols[offset + 1];
					final Expr dest = (Expr) _symbol_dest.value;
					final Symbol MODEQ = _symbols[offset + 2];
					final Symbol _symbol_source = _symbols[offset + 3];
					final Expr source = (Expr) _symbol_source.value;
					 return new AssignModExpr(dest, source);
			}
			case 328: // assignment = postfix_expression.dest PLUSEQ.PLUSEQ assignment_expression.source
			{
					final Symbol _symbol_dest = _symbols[offset + 1];
					final Expr dest = (Expr) _symbol_dest.value;
					final Symbol PLUSEQ = _symbols[offset + 2];
					final Symbol _symbol_source = _symbols[offset + 3];
					final Expr source = (Expr) _symbol_source.value;
					 return new AssignPlusExpr(dest, source);
			}
			case 329: // assignment = postfix_expression.dest MINUSEQ.MINUSEQ assignment_expression.source
			{
					final Symbol _symbol_dest = _symbols[offset + 1];
					final Expr dest = (Expr) _symbol_dest.value;
					final Symbol MINUSEQ = _symbols[offset + 2];
					final Symbol _symbol_source = _symbols[offset + 3];
					final Expr source = (Expr) _symbol_source.value;
					 return new AssignMinusExpr(dest, source);
			}
			case 330: // assignment = postfix_expression.dest LSHIFTEQ.LSHIFTEQ assignment_expression.source
			{
					final Symbol _symbol_dest = _symbols[offset + 1];
					final Expr dest = (Expr) _symbol_dest.value;
					final Symbol LSHIFTEQ = _symbols[offset + 2];
					final Symbol _symbol_source = _symbols[offset + 3];
					final Expr source = (Expr) _symbol_source.value;
					 return new AssignLShiftExpr(dest, source);
			}
			case 331: // assignment = postfix_expression.dest RSHIFTEQ.RSHIFTEQ assignment_expression.source
			{
					final Symbol _symbol_dest = _symbols[offset + 1];
					final Expr dest = (Expr) _symbol_dest.value;
					final Symbol RSHIFTEQ = _symbols[offset + 2];
					final Symbol _symbol_source = _symbols[offset + 3];
					final Expr source = (Expr) _symbol_source.value;
					 return new AssignRShiftExpr(dest, source);
			}
			case 332: // assignment = postfix_expression.dest URSHIFTEQ.URSHIFTEQ assignment_expression.source
			{
					final Symbol _symbol_dest = _symbols[offset + 1];
					final Expr dest = (Expr) _symbol_dest.value;
					final Symbol URSHIFTEQ = _symbols[offset + 2];
					final Symbol _symbol_source = _symbols[offset + 3];
					final Expr source = (Expr) _symbol_source.value;
					 return new AssignURShiftExpr(dest, source);
			}
			case 333: // assignment = postfix_expression.dest ANDEQ.ANDEQ assignment_expression.source
			{
					final Symbol _symbol_dest = _symbols[offset + 1];
					final Expr dest = (Expr) _symbol_dest.value;
					final Symbol ANDEQ = _symbols[offset + 2];
					final Symbol _symbol_source = _symbols[offset + 3];
					final Expr source = (Expr) _symbol_source.value;
					 return new AssignAndExpr(dest, source);
			}
			case 334: // assignment = postfix_expression.dest XOREQ.XOREQ assignment_expression.source
			{
					final Symbol _symbol_dest = _symbols[offset + 1];
					final Expr dest = (Expr) _symbol_dest.value;
					final Symbol XOREQ = _symbols[offset + 2];
					final Symbol _symbol_source = _symbols[offset + 3];
					final Expr source = (Expr) _symbol_source.value;
					 return new AssignXorExpr(dest, source);
			}
			case 335: // assignment = postfix_expression.dest OREQ.OREQ assignment_expression.source
			{
					final Symbol _symbol_dest = _symbols[offset + 1];
					final Expr dest = (Expr) _symbol_dest.value;
					final Symbol OREQ = _symbols[offset + 2];
					final Symbol _symbol_source = _symbols[offset + 3];
					final Expr source = (Expr) _symbol_source.value;
					 return new AssignOrExpr(dest, source);
			}
			case 336: // expression = assignment_expression.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					 return a;
			}
			case 337: // constant_expression = expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 338: // class_body_declaration = error.error SEMICOLON.SEMICOLON
			{
					final Symbol error = _symbols[offset + 1];
					final Symbol SEMICOLON = _symbols[offset + 2];
					 return new InstanceInitializer(new Block());
			}
			case 339: // class_body_declaration = error.error LBRACE.LBRACE
			{
					final Symbol error = _symbols[offset + 1];
					final Symbol LBRACE = _symbols[offset + 2];
					 return new InstanceInitializer(new Block());
			}
			case 340: // block = error.error RBRACE.RBRACE
			{
					final Symbol error = _symbols[offset + 1];
					final Symbol RBRACE = _symbols[offset + 2];
					 return new Block(new List());
			}
			case 341: // statement = error.error SEMICOLON.SEMICOLON
			{
					final Symbol error = _symbols[offset + 1];
					final Symbol SEMICOLON = _symbols[offset + 2];
					 return new EmptyStmt();
			}
			case 342: // type_declaration = annotation_type_declaration.i
			{
					final Symbol _symbol_i = _symbols[offset + 1];
					final AnnotationDecl i = (AnnotationDecl) _symbol_i.value;
					 return i;
			}
			case 343: // interface_member_declaration = annotation_type_declaration.i
			{
					final Symbol _symbol_i = _symbols[offset + 1];
					final AnnotationDecl i = (AnnotationDecl) _symbol_i.value;
					 return new MemberInterfaceDecl(i);
			}
			case 344: // class_member_declaration = annotation_type_declaration.i
			{
					final Symbol _symbol_i = _symbols[offset + 1];
					final AnnotationDecl i = (AnnotationDecl) _symbol_i.value;
					 return new MemberInterfaceDecl(i);
			}
			case 345: // annotation_type_declaration = AT.AT INTERFACE.INTERFACE IDENTIFIER.IDENTIFIER annotation_type_body.b
			{
					final Symbol AT = _symbols[offset + 1];
					final Symbol INTERFACE = _symbols[offset + 2];
					final Symbol IDENTIFIER = _symbols[offset + 3];
					final Symbol _symbol_b = _symbols[offset + 4];
					final List b = (List) _symbol_b.value;
					 return new AnnotationDecl(new Modifiers(new List()), IDENTIFIER, b);
			}
			case 346: // annotation_type_declaration = modifiers.m AT.AT INTERFACE.INTERFACE IDENTIFIER.IDENTIFIER annotation_type_body.b
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final List m = (List) _symbol_m.value;
					final Symbol AT = _symbols[offset + 2];
					final Symbol INTERFACE = _symbols[offset + 3];
					final Symbol IDENTIFIER = _symbols[offset + 4];
					final Symbol _symbol_b = _symbols[offset + 5];
					final List b = (List) _symbol_b.value;
					 return new AnnotationDecl(new Modifiers(m), IDENTIFIER, b);
			}
			case 347: // annotation_type_body = LBRACE.LBRACE annotation_type_element_declarations_opt.i RBRACE.RBRACE
			{
					final Symbol LBRACE = _symbols[offset + 1];
					final Symbol _symbol_i = _symbols[offset + 2];
					final List i = (List) _symbol_i.value;
					final Symbol RBRACE = _symbols[offset + 3];
					 return i;
			}
			case 348: // annotation_type_element_declarations = annotation_type_element_declaration.i
			{
					final Symbol _symbol_i = _symbols[offset + 1];
					final BodyDecl i = (BodyDecl) _symbol_i.value;
					 return new List().add(i);
			}
			case 349: // annotation_type_element_declarations = annotation_type_element_declarations.l annotation_type_element_declaration.i
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol _symbol_i = _symbols[offset + 2];
					final BodyDecl i = (BodyDecl) _symbol_i.value;
					 return l.add(i);
			}
			case 350: // annotation_type_element_declaration = type.t IDENTIFIER.IDENTIFIER LPAREN.LPAREN RPAREN.RPAREN default_value_opt.default_value SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final Access t = (Access) _symbol_t.value;
					final Symbol IDENTIFIER = _symbols[offset + 2];
					final Symbol LPAREN = _symbols[offset + 3];
					final Symbol RPAREN = _symbols[offset + 4];
					final Symbol _symbol_default_value = _symbols[offset + 5];
					final Opt default_value = (Opt) _symbol_default_value.value;
					final Symbol SEMICOLON = _symbols[offset + 6];
					 return new AnnotationMethodDecl(new Modifiers(new List()), t, IDENTIFIER, new List(), new List(), new Opt(), default_value);
			}
			case 351: // annotation_type_element_declaration = modifiers.m type.t IDENTIFIER.IDENTIFIER LPAREN.LPAREN RPAREN.RPAREN default_value_opt.default_value SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final List m = (List) _symbol_m.value;
					final Symbol _symbol_t = _symbols[offset + 2];
					final Access t = (Access) _symbol_t.value;
					final Symbol IDENTIFIER = _symbols[offset + 3];
					final Symbol LPAREN = _symbols[offset + 4];
					final Symbol RPAREN = _symbols[offset + 5];
					final Symbol _symbol_default_value = _symbols[offset + 6];
					final Opt default_value = (Opt) _symbol_default_value.value;
					final Symbol SEMICOLON = _symbols[offset + 7];
					 return new AnnotationMethodDecl(new Modifiers(m), t, IDENTIFIER, new List(), new List(), new Opt(), default_value);
			}
			case 353: // annotation_type_element_declaration = class_declaration.class_declaration
			{
					final Symbol _symbol_class_declaration = _symbols[offset + 1];
					final ClassDecl class_declaration = (ClassDecl) _symbol_class_declaration.value;
					 return new MemberClassDecl(class_declaration);
			}
			case 354: // annotation_type_element_declaration = interface_declaration.interface_declaration
			{
					final Symbol _symbol_interface_declaration = _symbols[offset + 1];
					final InterfaceDecl interface_declaration = (InterfaceDecl) _symbol_interface_declaration.value;
					 return new MemberInterfaceDecl(interface_declaration);
			}
			case 355: // annotation_type_element_declaration = enum_declaration.enum_declaration
			{
					final Symbol _symbol_enum_declaration = _symbols[offset + 1];
					final EnumDecl enum_declaration = (EnumDecl) _symbol_enum_declaration.value;
					 return new MemberClassDecl(enum_declaration);
			}
			case 356: // annotation_type_element_declaration = annotation_type_declaration.annotation_type_declaration
			{
					final Symbol _symbol_annotation_type_declaration = _symbols[offset + 1];
					final AnnotationDecl annotation_type_declaration = (AnnotationDecl) _symbol_annotation_type_declaration.value;
					 return new MemberInterfaceDecl(annotation_type_declaration);
			}
			case 357: // annotation_type_element_declaration = SEMICOLON.SEMICOLON
			{
					final Symbol SEMICOLON = _symbols[offset + 1];
					 return new StaticInitializer(new Block());
			}
			case 358: // default_value = DEFAULT.DEFAULT element_value.element_value
			{
					final Symbol DEFAULT = _symbols[offset + 1];
					final Symbol _symbol_element_value = _symbols[offset + 2];
					final ElementValue element_value = (ElementValue) _symbol_element_value.value;
					 return element_value;
			}
			case 363: // normal_annotation = AT.AT type.type LPAREN.LPAREN element_value_pairs_opt.element_value_pairs RPAREN.RPAREN
			{
					final Symbol AT = _symbols[offset + 1];
					final Symbol _symbol_type = _symbols[offset + 2];
					final Access type = (Access) _symbol_type.value;
					final Symbol LPAREN = _symbols[offset + 3];
					final Symbol _symbol_element_value_pairs = _symbols[offset + 4];
					final List element_value_pairs = (List) _symbol_element_value_pairs.value;
					final Symbol RPAREN = _symbols[offset + 5];
					 return new Annotation("annotation", type, element_value_pairs);
			}
			case 364: // element_value_pairs = element_value_pair.element_value_pair
			{
					final Symbol _symbol_element_value_pair = _symbols[offset + 1];
					final ElementValuePair element_value_pair = (ElementValuePair) _symbol_element_value_pair.value;
					 return new List().add(element_value_pair);
			}
			case 365: // element_value_pairs = element_value_pairs.element_value_pairs COMMA.COMMA element_value_pair.element_value_pair
			{
					final Symbol _symbol_element_value_pairs = _symbols[offset + 1];
					final List element_value_pairs = (List) _symbol_element_value_pairs.value;
					final Symbol COMMA = _symbols[offset + 2];
					final Symbol _symbol_element_value_pair = _symbols[offset + 3];
					final ElementValuePair element_value_pair = (ElementValuePair) _symbol_element_value_pair.value;
					 return element_value_pairs.add(element_value_pair);
			}
			case 366: // element_value_pair = IDENTIFIER.IDENTIFIER EQ.EQ element_value.element_value
			{
					final Symbol IDENTIFIER = _symbols[offset + 1];
					final Symbol EQ = _symbols[offset + 2];
					final Symbol _symbol_element_value = _symbols[offset + 3];
					final ElementValue element_value = (ElementValue) _symbol_element_value.value;
					 return new ElementValuePair(IDENTIFIER, element_value);
			}
			case 367: // element_value = conditional_expression.conditional_expression
			{
					final Symbol _symbol_conditional_expression = _symbols[offset + 1];
					final Expr conditional_expression = (Expr) _symbol_conditional_expression.value;
					 return new ElementConstantValue(conditional_expression);
			}
			case 368: // element_value = annotation.annotation
			{
					final Symbol _symbol_annotation = _symbols[offset + 1];
					final Annotation annotation = (Annotation) _symbol_annotation.value;
					 return new ElementAnnotationValue(annotation);
			}
			case 369: // element_value = element_value_array_initializer.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final ElementArrayValue e = (ElementArrayValue) _symbol_e.value;
					 return e;
			}
			case 370: // element_value_array_initializer = LBRACE.LBRACE RBRACE.RBRACE
			{
					final Symbol LBRACE = _symbols[offset + 1];
					final Symbol RBRACE = _symbols[offset + 2];
					 return new ElementArrayValue(new List());
			}
			case 371: // element_value_array_initializer = LBRACE.LBRACE element_values.element_values RBRACE.RBRACE
			{
					final Symbol LBRACE = _symbols[offset + 1];
					final Symbol _symbol_element_values = _symbols[offset + 2];
					final List element_values = (List) _symbol_element_values.value;
					final Symbol RBRACE = _symbols[offset + 3];
					 return new ElementArrayValue(element_values);
			}
			case 372: // element_value_array_initializer = LBRACE.LBRACE COMMA.COMMA RBRACE.RBRACE
			{
					final Symbol LBRACE = _symbols[offset + 1];
					final Symbol COMMA = _symbols[offset + 2];
					final Symbol RBRACE = _symbols[offset + 3];
					 return new ElementArrayValue(new List());
			}
			case 373: // element_value_array_initializer = LBRACE.LBRACE element_values.element_values COMMA.COMMA RBRACE.RBRACE
			{
					final Symbol LBRACE = _symbols[offset + 1];
					final Symbol _symbol_element_values = _symbols[offset + 2];
					final List element_values = (List) _symbol_element_values.value;
					final Symbol COMMA = _symbols[offset + 3];
					final Symbol RBRACE = _symbols[offset + 4];
					 return new ElementArrayValue(element_values);
			}
			case 374: // element_values = element_value.element_value
			{
					final Symbol _symbol_element_value = _symbols[offset + 1];
					final ElementValue element_value = (ElementValue) _symbol_element_value.value;
					 return new List().add(element_value);
			}
			case 375: // element_values = element_values.element_values COMMA.COMMA element_value.element_value
			{
					final Symbol _symbol_element_values = _symbols[offset + 1];
					final List element_values = (List) _symbol_element_values.value;
					final Symbol COMMA = _symbols[offset + 2];
					final Symbol _symbol_element_value = _symbols[offset + 3];
					final ElementValue element_value = (ElementValue) _symbol_element_value.value;
					 return element_values.add(element_value);
			}
			case 376: // marker_annotation = AT.AT type.type
			{
					final Symbol AT = _symbols[offset + 1];
					final Symbol _symbol_type = _symbols[offset + 2];
					final Access type = (Access) _symbol_type.value;
					 return new Annotation("annotation", type, new List());
			}
			case 377: // single_element_annotation = AT.AT type.type LPAREN.LPAREN element_value.element_value RPAREN.RPAREN
			{
					final Symbol AT = _symbols[offset + 1];
					final Symbol _symbol_type = _symbols[offset + 2];
					final Access type = (Access) _symbol_type.value;
					final Symbol LPAREN = _symbols[offset + 3];
					final Symbol _symbol_element_value = _symbols[offset + 4];
					final ElementValue element_value = (ElementValue) _symbol_element_value.value;
					final Symbol RPAREN = _symbols[offset + 5];
					 return new Annotation("annotation", type, new List().add(new ElementValuePair("value", element_value)));
			}
			case 378: // compilation_unit = modifiers.a package_declaration.p
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final List a = (List) _symbol_a.value;
					final Symbol _symbol_p = _symbols[offset + 2];
					final IdUse p = (IdUse) _symbol_p.value;
					 return new AnnotatedCompilationUnit(p.getID(), new List(), new List(), new Modifiers(a));
			}
			case 379: // compilation_unit = modifiers.a package_declaration.p import_declarations.i
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final List a = (List) _symbol_a.value;
					final Symbol _symbol_p = _symbols[offset + 2];
					final IdUse p = (IdUse) _symbol_p.value;
					final Symbol _symbol_i = _symbols[offset + 3];
					final List i = (List) _symbol_i.value;
					 return new AnnotatedCompilationUnit(p.getID(), i, new List(), new Modifiers(a));
			}
			case 380: // compilation_unit = modifiers.a package_declaration.p type_declarations.t
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final List a = (List) _symbol_a.value;
					final Symbol _symbol_p = _symbols[offset + 2];
					final IdUse p = (IdUse) _symbol_p.value;
					final Symbol _symbol_t = _symbols[offset + 3];
					final List t = (List) _symbol_t.value;
					 return new AnnotatedCompilationUnit(p.getID(), new List(), t, new Modifiers(a));
			}
			case 381: // compilation_unit = modifiers.a package_declaration.p import_declarations.i type_declarations.t
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final List a = (List) _symbol_a.value;
					final Symbol _symbol_p = _symbols[offset + 2];
					final IdUse p = (IdUse) _symbol_p.value;
					final Symbol _symbol_i = _symbols[offset + 3];
					final List i = (List) _symbol_i.value;
					final Symbol _symbol_t = _symbols[offset + 4];
					final List t = (List) _symbol_t.value;
					 return new AnnotatedCompilationUnit(p.getID(), i, t, new Modifiers(a));
			}
			case 382: // statement = enhanced_for_statement.f
			{
					final Symbol _symbol_f = _symbols[offset + 1];
					final Stmt f = (Stmt) _symbol_f.value;
					 return f;
			}
			case 383: // statement_no_short_if = enhanced_for_statement_no_short_if.f
			{
					final Symbol _symbol_f = _symbols[offset + 1];
					final Stmt f = (Stmt) _symbol_f.value;
					 return f;
			}
			case 384: // enhanced_for_statement = FOR.FOR LPAREN.LPAREN enhanced_for_parameter.p COLON.COLON expression.e RPAREN.RPAREN statement.s
			{
					final Symbol FOR = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_p = _symbols[offset + 3];
					final VariableDeclaration p = (VariableDeclaration) _symbol_p.value;
					final Symbol COLON = _symbols[offset + 4];
					final Symbol _symbol_e = _symbols[offset + 5];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol RPAREN = _symbols[offset + 6];
					final Symbol _symbol_s = _symbols[offset + 7];
					final Stmt s = (Stmt) _symbol_s.value;
					 return new EnhancedForStmt(p, e, s);
			}
			case 385: // enhanced_for_statement_no_short_if = FOR.FOR LPAREN.LPAREN enhanced_for_parameter.p COLON.COLON expression.e RPAREN.RPAREN statement_no_short_if.s
			{
					final Symbol FOR = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_p = _symbols[offset + 3];
					final VariableDeclaration p = (VariableDeclaration) _symbol_p.value;
					final Symbol COLON = _symbols[offset + 4];
					final Symbol _symbol_e = _symbols[offset + 5];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol RPAREN = _symbols[offset + 6];
					final Symbol _symbol_s = _symbols[offset + 7];
					final Stmt s = (Stmt) _symbol_s.value;
					 return new EnhancedForStmt(p, e, s);
			}
			case 386: // enhanced_for_parameter = type.t IDENTIFIER.IDENTIFIER dims_opt.d
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final Access t = (Access) _symbol_t.value;
					final Symbol IDENTIFIER = _symbols[offset + 2];
					final Symbol _symbol_d = _symbols[offset + 3];
					final List d = (List) _symbol_d.value;
					 return new VariableDeclaration(new Modifiers(new List()), t.addArrayDims(d), IDENTIFIER, new Opt());
			}
			case 387: // enhanced_for_parameter = modifiers.m type.t IDENTIFIER.IDENTIFIER dims_opt.d
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final List m = (List) _symbol_m.value;
					final Symbol _symbol_t = _symbols[offset + 2];
					final Access t = (Access) _symbol_t.value;
					final Symbol IDENTIFIER = _symbols[offset + 3];
					final Symbol _symbol_d = _symbols[offset + 4];
					final List d = (List) _symbol_d.value;
					 return new VariableDeclaration(new Modifiers(m), t.addArrayDims(d), IDENTIFIER, new Opt());
			}
			case 388: // type_declaration = enum_declaration.i
			{
					final Symbol _symbol_i = _symbols[offset + 1];
					final EnumDecl i = (EnumDecl) _symbol_i.value;
					 return i;
			}
			case 389: // interface_member_declaration = enum_declaration.i
			{
					final Symbol _symbol_i = _symbols[offset + 1];
					final EnumDecl i = (EnumDecl) _symbol_i.value;
					 return new MemberClassDecl(i);
			}
			case 390: // class_member_declaration = enum_declaration.i
			{
					final Symbol _symbol_i = _symbols[offset + 1];
					final EnumDecl i = (EnumDecl) _symbol_i.value;
					 return new MemberClassDecl(i);
			}
			case 391: // enum_declaration = ENUM.ENUM IDENTIFIER.id enum_body.b
			{
					final Symbol ENUM = _symbols[offset + 1];
					final Symbol id = _symbols[offset + 2];
					final Symbol _symbol_b = _symbols[offset + 3];
					final List b = (List) _symbol_b.value;
					 return new EnumDecl(new Modifiers(new List()), ((String)id.value), new List(), b);
			}
			case 392: // enum_declaration = modifiers.m ENUM.ENUM IDENTIFIER.id enum_body.b
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final List m = (List) _symbol_m.value;
					final Symbol ENUM = _symbols[offset + 2];
					final Symbol id = _symbols[offset + 3];
					final Symbol _symbol_b = _symbols[offset + 4];
					final List b = (List) _symbol_b.value;
					 return new EnumDecl(new Modifiers(m), ((String)id.value), new List(), b);
			}
			case 393: // enum_declaration = ENUM.ENUM IDENTIFIER.id interfaces.i enum_body.b
			{
					final Symbol ENUM = _symbols[offset + 1];
					final Symbol id = _symbols[offset + 2];
					final Symbol _symbol_i = _symbols[offset + 3];
					final List i = (List) _symbol_i.value;
					final Symbol _symbol_b = _symbols[offset + 4];
					final List b = (List) _symbol_b.value;
					 return new EnumDecl(new Modifiers(new List()), ((String)id.value), i, b);
			}
			case 394: // enum_declaration = modifiers.m ENUM.ENUM IDENTIFIER.id interfaces.i enum_body.b
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final List m = (List) _symbol_m.value;
					final Symbol ENUM = _symbols[offset + 2];
					final Symbol id = _symbols[offset + 3];
					final Symbol _symbol_i = _symbols[offset + 4];
					final List i = (List) _symbol_i.value;
					final Symbol _symbol_b = _symbols[offset + 5];
					final List b = (List) _symbol_b.value;
					 return new EnumDecl(new Modifiers(m), ((String)id.value), i, b);
			}
			case 395: // enum_body = LBRACE.LBRACE RBRACE.RBRACE
			{
					final Symbol LBRACE = _symbols[offset + 1];
					final Symbol RBRACE = _symbols[offset + 2];
					 return new List();
			}
			case 396: // enum_body = LBRACE.LBRACE enum_constants.enum_constants RBRACE.RBRACE
			{
					final Symbol LBRACE = _symbols[offset + 1];
					final Symbol _symbol_enum_constants = _symbols[offset + 2];
					final List enum_constants = (List) _symbol_enum_constants.value;
					final Symbol RBRACE = _symbols[offset + 3];
					 return enum_constants;
			}
			case 397: // enum_body = LBRACE.LBRACE COMMA.COMMA RBRACE.RBRACE
			{
					final Symbol LBRACE = _symbols[offset + 1];
					final Symbol COMMA = _symbols[offset + 2];
					final Symbol RBRACE = _symbols[offset + 3];
					 return new List();
			}
			case 398: // enum_body = LBRACE.LBRACE enum_constants.enum_constants COMMA.COMMA RBRACE.RBRACE
			{
					final Symbol LBRACE = _symbols[offset + 1];
					final Symbol _symbol_enum_constants = _symbols[offset + 2];
					final List enum_constants = (List) _symbol_enum_constants.value;
					final Symbol COMMA = _symbols[offset + 3];
					final Symbol RBRACE = _symbols[offset + 4];
					 return enum_constants;
			}
			case 399: // enum_body = LBRACE.LBRACE enum_body_declarations.enum_body_declarations RBRACE.RBRACE
			{
					final Symbol LBRACE = _symbols[offset + 1];
					final Symbol _symbol_enum_body_declarations = _symbols[offset + 2];
					final List enum_body_declarations = (List) _symbol_enum_body_declarations.value;
					final Symbol RBRACE = _symbols[offset + 3];
					 return enum_body_declarations;
			}
			case 400: // enum_body = LBRACE.LBRACE enum_constants.c enum_body_declarations.d RBRACE.RBRACE
			{
					final Symbol LBRACE = _symbols[offset + 1];
					final Symbol _symbol_c = _symbols[offset + 2];
					final List c = (List) _symbol_c.value;
					final Symbol _symbol_d = _symbols[offset + 3];
					final List d = (List) _symbol_d.value;
					final Symbol RBRACE = _symbols[offset + 4];
					 for(int i = 0; i < d.getNumChildNoTransform(); i++) c.add(d.getChildNoTransform(i)); return c;
			}
			case 401: // enum_body = LBRACE.LBRACE COMMA.COMMA enum_body_declarations.enum_body_declarations RBRACE.RBRACE
			{
					final Symbol LBRACE = _symbols[offset + 1];
					final Symbol COMMA = _symbols[offset + 2];
					final Symbol _symbol_enum_body_declarations = _symbols[offset + 3];
					final List enum_body_declarations = (List) _symbol_enum_body_declarations.value;
					final Symbol RBRACE = _symbols[offset + 4];
					 return enum_body_declarations;
			}
			case 402: // enum_body = LBRACE.LBRACE enum_constants.c COMMA.COMMA enum_body_declarations.d RBRACE.RBRACE
			{
					final Symbol LBRACE = _symbols[offset + 1];
					final Symbol _symbol_c = _symbols[offset + 2];
					final List c = (List) _symbol_c.value;
					final Symbol COMMA = _symbols[offset + 3];
					final Symbol _symbol_d = _symbols[offset + 4];
					final List d = (List) _symbol_d.value;
					final Symbol RBRACE = _symbols[offset + 5];
					 for(int i = 0; i < d.getNumChildNoTransform(); i++) c.add(d.getChildNoTransform(i)); return c;
			}
			case 403: // enum_constants = enum_constant.enum_constant
			{
					final Symbol _symbol_enum_constant = _symbols[offset + 1];
					final BodyDecl enum_constant = (BodyDecl) _symbol_enum_constant.value;
					 return new List().add(enum_constant);
			}
			case 404: // enum_constants = enum_constants.enum_constants COMMA.COMMA enum_constant.enum_constant
			{
					final Symbol _symbol_enum_constants = _symbols[offset + 1];
					final List enum_constants = (List) _symbol_enum_constants.value;
					final Symbol COMMA = _symbols[offset + 2];
					final Symbol _symbol_enum_constant = _symbols[offset + 3];
					final BodyDecl enum_constant = (BodyDecl) _symbol_enum_constant.value;
					 return enum_constants.add(enum_constant);
			}
			case 405: // enum_constant = IDENTIFIER.id
			{
					final Symbol id = _symbols[offset + 1];
					 return new EnumConstant(new Modifiers(new List()), ((String)id.value), new List(), new List());
			}
			case 406: // enum_constant = annotations.annotations IDENTIFIER.id
			{
					final Symbol _symbol_annotations = _symbols[offset + 1];
					final List annotations = (List) _symbol_annotations.value;
					final Symbol id = _symbols[offset + 2];
					 return new EnumConstant(new Modifiers(annotations), ((String)id.value), new List(), new List());
			}
			case 407: // enum_constant = IDENTIFIER.id arguments.arguments
			{
					final Symbol id = _symbols[offset + 1];
					final Symbol _symbol_arguments = _symbols[offset + 2];
					final List arguments = (List) _symbol_arguments.value;
					 return new EnumConstant(new Modifiers(new List()), ((String)id.value), arguments, new List());
			}
			case 408: // enum_constant = annotations.annotations IDENTIFIER.id arguments.arguments
			{
					final Symbol _symbol_annotations = _symbols[offset + 1];
					final List annotations = (List) _symbol_annotations.value;
					final Symbol id = _symbols[offset + 2];
					final Symbol _symbol_arguments = _symbols[offset + 3];
					final List arguments = (List) _symbol_arguments.value;
					 return new EnumConstant(new Modifiers(annotations), ((String)id.value), arguments, new List());
			}
			case 409: // enum_constant = IDENTIFIER.id class_body.class_body
			{
					final Symbol id = _symbols[offset + 1];
					final Symbol _symbol_class_body = _symbols[offset + 2];
					final List class_body = (List) _symbol_class_body.value;
					 return new EnumConstant(new Modifiers(new List()), ((String)id.value), new List(), class_body);
			}
			case 410: // enum_constant = annotations.annotations IDENTIFIER.id class_body.class_body
			{
					final Symbol _symbol_annotations = _symbols[offset + 1];
					final List annotations = (List) _symbol_annotations.value;
					final Symbol id = _symbols[offset + 2];
					final Symbol _symbol_class_body = _symbols[offset + 3];
					final List class_body = (List) _symbol_class_body.value;
					 return new EnumConstant(new Modifiers(annotations), ((String)id.value), new List(), class_body);
			}
			case 411: // enum_constant = IDENTIFIER.id arguments.arguments class_body.class_body
			{
					final Symbol id = _symbols[offset + 1];
					final Symbol _symbol_arguments = _symbols[offset + 2];
					final List arguments = (List) _symbol_arguments.value;
					final Symbol _symbol_class_body = _symbols[offset + 3];
					final List class_body = (List) _symbol_class_body.value;
					 return new EnumConstant(new Modifiers(new List()), ((String)id.value), arguments, class_body);
			}
			case 412: // enum_constant = annotations.annotations IDENTIFIER.id arguments.arguments class_body.class_body
			{
					final Symbol _symbol_annotations = _symbols[offset + 1];
					final List annotations = (List) _symbol_annotations.value;
					final Symbol id = _symbols[offset + 2];
					final Symbol _symbol_arguments = _symbols[offset + 3];
					final List arguments = (List) _symbol_arguments.value;
					final Symbol _symbol_class_body = _symbols[offset + 4];
					final List class_body = (List) _symbol_class_body.value;
					 return new EnumConstant(new Modifiers(annotations), ((String)id.value), arguments, class_body);
			}
			case 413: // arguments = LPAREN.LPAREN argument_list.argument_list RPAREN.RPAREN
			{
					final Symbol LPAREN = _symbols[offset + 1];
					final Symbol _symbol_argument_list = _symbols[offset + 2];
					final List argument_list = (List) _symbol_argument_list.value;
					final Symbol RPAREN = _symbols[offset + 3];
					 return argument_list;
			}
			case 414: // annotations = annotation.annotation
			{
					final Symbol _symbol_annotation = _symbols[offset + 1];
					final Annotation annotation = (Annotation) _symbol_annotation.value;
					 return new List().add(annotation);
			}
			case 415: // annotations = annotations.annotations annotation.annotation
			{
					final Symbol _symbol_annotations = _symbols[offset + 1];
					final List annotations = (List) _symbol_annotations.value;
					final Symbol _symbol_annotation = _symbols[offset + 2];
					final Annotation annotation = (Annotation) _symbol_annotation.value;
					 return annotations.add(annotation);
			}
			case 416: // enum_body_declarations = SEMICOLON.SEMICOLON class_body_declarations_opt.class_body_declarations
			{
					final Symbol SEMICOLON = _symbols[offset + 1];
					final Symbol _symbol_class_body_declarations = _symbols[offset + 2];
					final List class_body_declarations = (List) _symbol_class_body_declarations.value;
					 return class_body_declarations;
			}
			case 417: // explicit_constructor_invocation = type_arguments.a THIS.THIS LPAREN.LPAREN argument_list_opt.l RPAREN.RPAREN SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final List a = (List) _symbol_a.value;
					final Symbol THIS = _symbols[offset + 2];
					final Symbol LPAREN = _symbols[offset + 3];
					final Symbol _symbol_l = _symbols[offset + 4];
					final List l = (List) _symbol_l.value;
					final Symbol RPAREN = _symbols[offset + 5];
					final Symbol SEMICOLON = _symbols[offset + 6];
					 return new ExprStmt(new ParConstructorAccess("this", l, a));
			}
			case 418: // explicit_constructor_invocation = type_arguments.a SUPER.SUPER LPAREN.LPAREN argument_list_opt.l RPAREN.RPAREN SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final List a = (List) _symbol_a.value;
					final Symbol SUPER = _symbols[offset + 2];
					final Symbol LPAREN = _symbols[offset + 3];
					final Symbol _symbol_l = _symbols[offset + 4];
					final List l = (List) _symbol_l.value;
					final Symbol RPAREN = _symbols[offset + 5];
					final Symbol SEMICOLON = _symbols[offset + 6];
					 return new ExprStmt(new ParSuperConstructorAccess("super", l, a));
			}
			case 419: // explicit_constructor_invocation = primary.p DOT.DOT type_arguments.a SUPER.SUPER LPAREN.LPAREN argument_list_opt.l RPAREN.RPAREN SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_p = _symbols[offset + 1];
					final Expr p = (Expr) _symbol_p.value;
					final Symbol DOT = _symbols[offset + 2];
					final Symbol _symbol_a = _symbols[offset + 3];
					final List a = (List) _symbol_a.value;
					final Symbol SUPER = _symbols[offset + 4];
					final Symbol LPAREN = _symbols[offset + 5];
					final Symbol _symbol_l = _symbols[offset + 6];
					final List l = (List) _symbol_l.value;
					final Symbol RPAREN = _symbols[offset + 7];
					final Symbol SEMICOLON = _symbols[offset + 8];
					 return new ExprStmt(p.qualifiesAccess(new ParSuperConstructorAccess("super", l, a)));
			}
			case 420: // explicit_constructor_invocation = name.n DOT.DOT type_arguments.a SUPER.SUPER LPAREN.LPAREN argument_list_opt.l RPAREN.RPAREN SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Access n = (Access) _symbol_n.value;
					final Symbol DOT = _symbols[offset + 2];
					final Symbol _symbol_a = _symbols[offset + 3];
					final List a = (List) _symbol_a.value;
					final Symbol SUPER = _symbols[offset + 4];
					final Symbol LPAREN = _symbols[offset + 5];
					final Symbol _symbol_l = _symbols[offset + 6];
					final List l = (List) _symbol_l.value;
					final Symbol RPAREN = _symbols[offset + 7];
					final Symbol SEMICOLON = _symbols[offset + 8];
					 return new ExprStmt(n.qualifiesAccess(new ParSuperConstructorAccess("super", l, a)));
			}
			case 421: // method_invocation = primary.p DOT.DOT type_arguments.a IDENTIFIER.IDENTIFIER LPAREN.LPAREN argument_list_opt.l RPAREN.RPAREN
			{
					final Symbol _symbol_p = _symbols[offset + 1];
					final Expr p = (Expr) _symbol_p.value;
					final Symbol DOT = _symbols[offset + 2];
					final Symbol _symbol_a = _symbols[offset + 3];
					final List a = (List) _symbol_a.value;
					final Symbol IDENTIFIER = _symbols[offset + 4];
					final Symbol LPAREN = _symbols[offset + 5];
					final Symbol _symbol_l = _symbols[offset + 6];
					final List l = (List) _symbol_l.value;
					final Symbol RPAREN = _symbols[offset + 7];
					 return p.qualifiesAccess(new ParMethodAccess(IDENTIFIER, l, a));
			}
			case 422: // method_invocation = name.n DOT.DOT type_arguments.a IDENTIFIER.IDENTIFIER LPAREN.LPAREN argument_list_opt.l RPAREN.RPAREN
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Access n = (Access) _symbol_n.value;
					final Symbol DOT = _symbols[offset + 2];
					final Symbol _symbol_a = _symbols[offset + 3];
					final List a = (List) _symbol_a.value;
					final Symbol IDENTIFIER = _symbols[offset + 4];
					final Symbol LPAREN = _symbols[offset + 5];
					final Symbol _symbol_l = _symbols[offset + 6];
					final List l = (List) _symbol_l.value;
					final Symbol RPAREN = _symbols[offset + 7];
					 return n.qualifiesAccess(new ParMethodAccess(IDENTIFIER, l, a));
			}
			case 423: // method_invocation = SUPER.SUPER DOT.DOT type_arguments.a IDENTIFIER.IDENTIFIER LPAREN.LPAREN argument_list_opt.l RPAREN.RPAREN
			{
					final Symbol SUPER = _symbols[offset + 1];
					final Symbol DOT = _symbols[offset + 2];
					final Symbol _symbol_a = _symbols[offset + 3];
					final List a = (List) _symbol_a.value;
					final Symbol IDENTIFIER = _symbols[offset + 4];
					final Symbol LPAREN = _symbols[offset + 5];
					final Symbol _symbol_l = _symbols[offset + 6];
					final List l = (List) _symbol_l.value;
					final Symbol RPAREN = _symbols[offset + 7];
					 return new SuperAccess("super").qualifiesAccess(
		                    new ParMethodAccess(IDENTIFIER, l, a));
			}
			case 424: // method_invocation = name.n DOT.d1 SUPER.SUPER DOT.d2 type_arguments.a IDENTIFIER.IDENTIFIER LPAREN.LPAREN argument_list_opt.l RPAREN.RPAREN
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Access n = (Access) _symbol_n.value;
					final Symbol d1 = _symbols[offset + 2];
					final Symbol SUPER = _symbols[offset + 3];
					final Symbol d2 = _symbols[offset + 4];
					final Symbol _symbol_a = _symbols[offset + 5];
					final List a = (List) _symbol_a.value;
					final Symbol IDENTIFIER = _symbols[offset + 6];
					final Symbol LPAREN = _symbols[offset + 7];
					final Symbol _symbol_l = _symbols[offset + 8];
					final List l = (List) _symbol_l.value;
					final Symbol RPAREN = _symbols[offset + 9];
					 return n.qualifiesAccess(new SuperAccess("super")).qualifiesAccess(
                            new ParMethodAccess(IDENTIFIER, l, a));
			}
			case 425: // method_header = LT.LT type_parameter_list_1.l type.t IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.p RPAREN.RPAREN
			{
					final Symbol LT = _symbols[offset + 1];
					final Symbol _symbol_l = _symbols[offset + 2];
					final List l = (List) _symbol_l.value;
					final Symbol _symbol_t = _symbols[offset + 3];
					final Access t = (Access) _symbol_t.value;
					final Symbol IDENTIFIER = _symbols[offset + 4];
					final Symbol LPAREN = _symbols[offset + 5];
					final Symbol _symbol_p = _symbols[offset + 6];
					final List p = (List) _symbol_p.value;
					final Symbol RPAREN = _symbols[offset + 7];
					 return new GenericMethodDecl(new Modifiers(new List()), t.addArrayDims(new List()), IDENTIFIER, p, new List(), new Opt(), l);
			}
			case 426: // method_header = modifiers.m LT.LT type_parameter_list_1.l type.t IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.p RPAREN.RPAREN
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final List m = (List) _symbol_m.value;
					final Symbol LT = _symbols[offset + 2];
					final Symbol _symbol_l = _symbols[offset + 3];
					final List l = (List) _symbol_l.value;
					final Symbol _symbol_t = _symbols[offset + 4];
					final Access t = (Access) _symbol_t.value;
					final Symbol IDENTIFIER = _symbols[offset + 5];
					final Symbol LPAREN = _symbols[offset + 6];
					final Symbol _symbol_p = _symbols[offset + 7];
					final List p = (List) _symbol_p.value;
					final Symbol RPAREN = _symbols[offset + 8];
					 return new GenericMethodDecl(new Modifiers(m), t.addArrayDims(new List()), IDENTIFIER, p, new List(), new Opt(), l);
			}
			case 427: // method_header = LT.LT type_parameter_list_1.l type.t IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.p RPAREN.RPAREN dims.d
			{
					final Symbol LT = _symbols[offset + 1];
					final Symbol _symbol_l = _symbols[offset + 2];
					final List l = (List) _symbol_l.value;
					final Symbol _symbol_t = _symbols[offset + 3];
					final Access t = (Access) _symbol_t.value;
					final Symbol IDENTIFIER = _symbols[offset + 4];
					final Symbol LPAREN = _symbols[offset + 5];
					final Symbol _symbol_p = _symbols[offset + 6];
					final List p = (List) _symbol_p.value;
					final Symbol RPAREN = _symbols[offset + 7];
					final Symbol _symbol_d = _symbols[offset + 8];
					final List d = (List) _symbol_d.value;
					 return new GenericMethodDecl(new Modifiers(new List()), t.addArrayDims(d), IDENTIFIER, p, new List(), new Opt(), l);
			}
			case 428: // method_header = modifiers.m LT.LT type_parameter_list_1.l type.t IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.p RPAREN.RPAREN dims.d
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final List m = (List) _symbol_m.value;
					final Symbol LT = _symbols[offset + 2];
					final Symbol _symbol_l = _symbols[offset + 3];
					final List l = (List) _symbol_l.value;
					final Symbol _symbol_t = _symbols[offset + 4];
					final Access t = (Access) _symbol_t.value;
					final Symbol IDENTIFIER = _symbols[offset + 5];
					final Symbol LPAREN = _symbols[offset + 6];
					final Symbol _symbol_p = _symbols[offset + 7];
					final List p = (List) _symbol_p.value;
					final Symbol RPAREN = _symbols[offset + 8];
					final Symbol _symbol_d = _symbols[offset + 9];
					final List d = (List) _symbol_d.value;
					 return new GenericMethodDecl(new Modifiers(m), t.addArrayDims(d), IDENTIFIER, p, new List(), new Opt(), l);
			}
			case 429: // method_header = LT.LT type_parameter_list_1.l type.t IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.p RPAREN.RPAREN throws.tl
			{
					final Symbol LT = _symbols[offset + 1];
					final Symbol _symbol_l = _symbols[offset + 2];
					final List l = (List) _symbol_l.value;
					final Symbol _symbol_t = _symbols[offset + 3];
					final Access t = (Access) _symbol_t.value;
					final Symbol IDENTIFIER = _symbols[offset + 4];
					final Symbol LPAREN = _symbols[offset + 5];
					final Symbol _symbol_p = _symbols[offset + 6];
					final List p = (List) _symbol_p.value;
					final Symbol RPAREN = _symbols[offset + 7];
					final Symbol _symbol_tl = _symbols[offset + 8];
					final List tl = (List) _symbol_tl.value;
					 return new GenericMethodDecl(new Modifiers(new List()), t.addArrayDims(new List()), IDENTIFIER, p, tl, new Opt(), l);
			}
			case 430: // method_header = modifiers.m LT.LT type_parameter_list_1.l type.t IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.p RPAREN.RPAREN throws.tl
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final List m = (List) _symbol_m.value;
					final Symbol LT = _symbols[offset + 2];
					final Symbol _symbol_l = _symbols[offset + 3];
					final List l = (List) _symbol_l.value;
					final Symbol _symbol_t = _symbols[offset + 4];
					final Access t = (Access) _symbol_t.value;
					final Symbol IDENTIFIER = _symbols[offset + 5];
					final Symbol LPAREN = _symbols[offset + 6];
					final Symbol _symbol_p = _symbols[offset + 7];
					final List p = (List) _symbol_p.value;
					final Symbol RPAREN = _symbols[offset + 8];
					final Symbol _symbol_tl = _symbols[offset + 9];
					final List tl = (List) _symbol_tl.value;
					 return new GenericMethodDecl(new Modifiers(m), t.addArrayDims(new List()), IDENTIFIER, p, tl, new Opt(), l);
			}
			case 431: // method_header = LT.LT type_parameter_list_1.l type.t IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.p RPAREN.RPAREN dims.d throws.tl
			{
					final Symbol LT = _symbols[offset + 1];
					final Symbol _symbol_l = _symbols[offset + 2];
					final List l = (List) _symbol_l.value;
					final Symbol _symbol_t = _symbols[offset + 3];
					final Access t = (Access) _symbol_t.value;
					final Symbol IDENTIFIER = _symbols[offset + 4];
					final Symbol LPAREN = _symbols[offset + 5];
					final Symbol _symbol_p = _symbols[offset + 6];
					final List p = (List) _symbol_p.value;
					final Symbol RPAREN = _symbols[offset + 7];
					final Symbol _symbol_d = _symbols[offset + 8];
					final List d = (List) _symbol_d.value;
					final Symbol _symbol_tl = _symbols[offset + 9];
					final List tl = (List) _symbol_tl.value;
					 return new GenericMethodDecl(new Modifiers(new List()), t.addArrayDims(d), IDENTIFIER, p, tl, new Opt(), l);
			}
			case 432: // method_header = modifiers.m LT.LT type_parameter_list_1.l type.t IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.p RPAREN.RPAREN dims.d throws.tl
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final List m = (List) _symbol_m.value;
					final Symbol LT = _symbols[offset + 2];
					final Symbol _symbol_l = _symbols[offset + 3];
					final List l = (List) _symbol_l.value;
					final Symbol _symbol_t = _symbols[offset + 4];
					final Access t = (Access) _symbol_t.value;
					final Symbol IDENTIFIER = _symbols[offset + 5];
					final Symbol LPAREN = _symbols[offset + 6];
					final Symbol _symbol_p = _symbols[offset + 7];
					final List p = (List) _symbol_p.value;
					final Symbol RPAREN = _symbols[offset + 8];
					final Symbol _symbol_d = _symbols[offset + 9];
					final List d = (List) _symbol_d.value;
					final Symbol _symbol_tl = _symbols[offset + 10];
					final List tl = (List) _symbol_tl.value;
					 return new GenericMethodDecl(new Modifiers(m), t.addArrayDims(d), IDENTIFIER, p, tl, new Opt(), l);
			}
			case 433: // method_header = LT.LT type_parameter_list_1.l VOID.VOID IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.p RPAREN.RPAREN throws_opt.tl
			{
					final Symbol LT = _symbols[offset + 1];
					final Symbol _symbol_l = _symbols[offset + 2];
					final List l = (List) _symbol_l.value;
					final Symbol VOID = _symbols[offset + 3];
					final Symbol IDENTIFIER = _symbols[offset + 4];
					final Symbol LPAREN = _symbols[offset + 5];
					final Symbol _symbol_p = _symbols[offset + 6];
					final List p = (List) _symbol_p.value;
					final Symbol RPAREN = _symbols[offset + 7];
					final Symbol _symbol_tl = _symbols[offset + 8];
					final List tl = (List) _symbol_tl.value;
					 return new GenericMethodDecl(new Modifiers(new List()), new PrimitiveTypeAccess("void"), IDENTIFIER, p, tl, new Opt(), l);
			}
			case 434: // method_header = modifiers.m LT.LT type_parameter_list_1.l VOID.VOID IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.p RPAREN.RPAREN throws_opt.tl
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final List m = (List) _symbol_m.value;
					final Symbol LT = _symbols[offset + 2];
					final Symbol _symbol_l = _symbols[offset + 3];
					final List l = (List) _symbol_l.value;
					final Symbol VOID = _symbols[offset + 4];
					final Symbol IDENTIFIER = _symbols[offset + 5];
					final Symbol LPAREN = _symbols[offset + 6];
					final Symbol _symbol_p = _symbols[offset + 7];
					final List p = (List) _symbol_p.value;
					final Symbol RPAREN = _symbols[offset + 8];
					final Symbol _symbol_tl = _symbols[offset + 9];
					final List tl = (List) _symbol_tl.value;
					 return new GenericMethodDecl(new Modifiers(m), new PrimitiveTypeAccess("void"), IDENTIFIER, p, tl, new Opt(), l);
			}
			case 435: // constructor_declaration = LT.LT type_parameter_list_1.l IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.pl RPAREN.RPAREN throws_opt.tl LBRACE.LBRACE RBRACE.RBRACE
			{
					final Symbol LT = _symbols[offset + 1];
					final Symbol _symbol_l = _symbols[offset + 2];
					final List l = (List) _symbol_l.value;
					final Symbol IDENTIFIER = _symbols[offset + 3];
					final Symbol LPAREN = _symbols[offset + 4];
					final Symbol _symbol_pl = _symbols[offset + 5];
					final List pl = (List) _symbol_pl.value;
					final Symbol RPAREN = _symbols[offset + 6];
					final Symbol _symbol_tl = _symbols[offset + 7];
					final List tl = (List) _symbol_tl.value;
					final Symbol LBRACE = _symbols[offset + 8];
					final Symbol RBRACE = _symbols[offset + 9];
					 return new GenericConstructorDecl(new Modifiers(new List()), IDENTIFIER, pl, tl, new Opt(), new Block(new List()), l);
			}
			case 436: // constructor_declaration = modifiers.m LT.LT type_parameter_list_1.l IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.pl RPAREN.RPAREN throws_opt.tl LBRACE.LBRACE RBRACE.RBRACE
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final List m = (List) _symbol_m.value;
					final Symbol LT = _symbols[offset + 2];
					final Symbol _symbol_l = _symbols[offset + 3];
					final List l = (List) _symbol_l.value;
					final Symbol IDENTIFIER = _symbols[offset + 4];
					final Symbol LPAREN = _symbols[offset + 5];
					final Symbol _symbol_pl = _symbols[offset + 6];
					final List pl = (List) _symbol_pl.value;
					final Symbol RPAREN = _symbols[offset + 7];
					final Symbol _symbol_tl = _symbols[offset + 8];
					final List tl = (List) _symbol_tl.value;
					final Symbol LBRACE = _symbols[offset + 9];
					final Symbol RBRACE = _symbols[offset + 10];
					 return new GenericConstructorDecl(new Modifiers(m), IDENTIFIER, pl, tl, new Opt(), new Block(new List()), l);
			}
			case 437: // constructor_declaration = LT.LT type_parameter_list_1.l IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.pl RPAREN.RPAREN throws_opt.tl LBRACE.LBRACE explicit_constructor_invocation.c RBRACE.RBRACE
			{
					final Symbol LT = _symbols[offset + 1];
					final Symbol _symbol_l = _symbols[offset + 2];
					final List l = (List) _symbol_l.value;
					final Symbol IDENTIFIER = _symbols[offset + 3];
					final Symbol LPAREN = _symbols[offset + 4];
					final Symbol _symbol_pl = _symbols[offset + 5];
					final List pl = (List) _symbol_pl.value;
					final Symbol RPAREN = _symbols[offset + 6];
					final Symbol _symbol_tl = _symbols[offset + 7];
					final List tl = (List) _symbol_tl.value;
					final Symbol LBRACE = _symbols[offset + 8];
					final Symbol _symbol_c = _symbols[offset + 9];
					final ExprStmt c = (ExprStmt) _symbol_c.value;
					final Symbol RBRACE = _symbols[offset + 10];
					 return new GenericConstructorDecl(new Modifiers(new List()), IDENTIFIER, pl, tl, new Opt(c), new Block(new List()), l);
			}
			case 438: // constructor_declaration = modifiers.m LT.LT type_parameter_list_1.l IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.pl RPAREN.RPAREN throws_opt.tl LBRACE.LBRACE explicit_constructor_invocation.c RBRACE.RBRACE
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final List m = (List) _symbol_m.value;
					final Symbol LT = _symbols[offset + 2];
					final Symbol _symbol_l = _symbols[offset + 3];
					final List l = (List) _symbol_l.value;
					final Symbol IDENTIFIER = _symbols[offset + 4];
					final Symbol LPAREN = _symbols[offset + 5];
					final Symbol _symbol_pl = _symbols[offset + 6];
					final List pl = (List) _symbol_pl.value;
					final Symbol RPAREN = _symbols[offset + 7];
					final Symbol _symbol_tl = _symbols[offset + 8];
					final List tl = (List) _symbol_tl.value;
					final Symbol LBRACE = _symbols[offset + 9];
					final Symbol _symbol_c = _symbols[offset + 10];
					final ExprStmt c = (ExprStmt) _symbol_c.value;
					final Symbol RBRACE = _symbols[offset + 11];
					 return new GenericConstructorDecl(new Modifiers(m), IDENTIFIER, pl, tl, new Opt(c), new Block(new List()), l);
			}
			case 439: // constructor_declaration = LT.LT type_parameter_list_1.l IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.pl RPAREN.RPAREN throws_opt.tl LBRACE.LBRACE block_statements.bl RBRACE.RBRACE
			{
					final Symbol LT = _symbols[offset + 1];
					final Symbol _symbol_l = _symbols[offset + 2];
					final List l = (List) _symbol_l.value;
					final Symbol IDENTIFIER = _symbols[offset + 3];
					final Symbol LPAREN = _symbols[offset + 4];
					final Symbol _symbol_pl = _symbols[offset + 5];
					final List pl = (List) _symbol_pl.value;
					final Symbol RPAREN = _symbols[offset + 6];
					final Symbol _symbol_tl = _symbols[offset + 7];
					final List tl = (List) _symbol_tl.value;
					final Symbol LBRACE = _symbols[offset + 8];
					final Symbol _symbol_bl = _symbols[offset + 9];
					final List bl = (List) _symbol_bl.value;
					final Symbol RBRACE = _symbols[offset + 10];
					 return new GenericConstructorDecl(new Modifiers(new List()), IDENTIFIER, pl, tl, new Opt(), new Block(bl), l);
			}
			case 440: // constructor_declaration = modifiers.m LT.LT type_parameter_list_1.l IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.pl RPAREN.RPAREN throws_opt.tl LBRACE.LBRACE block_statements.bl RBRACE.RBRACE
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final List m = (List) _symbol_m.value;
					final Symbol LT = _symbols[offset + 2];
					final Symbol _symbol_l = _symbols[offset + 3];
					final List l = (List) _symbol_l.value;
					final Symbol IDENTIFIER = _symbols[offset + 4];
					final Symbol LPAREN = _symbols[offset + 5];
					final Symbol _symbol_pl = _symbols[offset + 6];
					final List pl = (List) _symbol_pl.value;
					final Symbol RPAREN = _symbols[offset + 7];
					final Symbol _symbol_tl = _symbols[offset + 8];
					final List tl = (List) _symbol_tl.value;
					final Symbol LBRACE = _symbols[offset + 9];
					final Symbol _symbol_bl = _symbols[offset + 10];
					final List bl = (List) _symbol_bl.value;
					final Symbol RBRACE = _symbols[offset + 11];
					 return new GenericConstructorDecl(new Modifiers(m), IDENTIFIER, pl, tl, new Opt(), new Block(bl), l);
			}
			case 441: // constructor_declaration = LT.LT type_parameter_list_1.l IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.pl RPAREN.RPAREN throws_opt.tl LBRACE.LBRACE explicit_constructor_invocation.c block_statements.bl RBRACE.RBRACE
			{
					final Symbol LT = _symbols[offset + 1];
					final Symbol _symbol_l = _symbols[offset + 2];
					final List l = (List) _symbol_l.value;
					final Symbol IDENTIFIER = _symbols[offset + 3];
					final Symbol LPAREN = _symbols[offset + 4];
					final Symbol _symbol_pl = _symbols[offset + 5];
					final List pl = (List) _symbol_pl.value;
					final Symbol RPAREN = _symbols[offset + 6];
					final Symbol _symbol_tl = _symbols[offset + 7];
					final List tl = (List) _symbol_tl.value;
					final Symbol LBRACE = _symbols[offset + 8];
					final Symbol _symbol_c = _symbols[offset + 9];
					final ExprStmt c = (ExprStmt) _symbol_c.value;
					final Symbol _symbol_bl = _symbols[offset + 10];
					final List bl = (List) _symbol_bl.value;
					final Symbol RBRACE = _symbols[offset + 11];
					 return new GenericConstructorDecl(new Modifiers(new List()), IDENTIFIER, pl, tl, new Opt(c), new Block(bl), l);
			}
			case 442: // constructor_declaration = modifiers.m LT.LT type_parameter_list_1.l IDENTIFIER.IDENTIFIER LPAREN.LPAREN formal_parameter_list_opt.pl RPAREN.RPAREN throws_opt.tl LBRACE.LBRACE explicit_constructor_invocation.c block_statements.bl RBRACE.RBRACE
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final List m = (List) _symbol_m.value;
					final Symbol LT = _symbols[offset + 2];
					final Symbol _symbol_l = _symbols[offset + 3];
					final List l = (List) _symbol_l.value;
					final Symbol IDENTIFIER = _symbols[offset + 4];
					final Symbol LPAREN = _symbols[offset + 5];
					final Symbol _symbol_pl = _symbols[offset + 6];
					final List pl = (List) _symbol_pl.value;
					final Symbol RPAREN = _symbols[offset + 7];
					final Symbol _symbol_tl = _symbols[offset + 8];
					final List tl = (List) _symbol_tl.value;
					final Symbol LBRACE = _symbols[offset + 9];
					final Symbol _symbol_c = _symbols[offset + 10];
					final ExprStmt c = (ExprStmt) _symbol_c.value;
					final Symbol _symbol_bl = _symbols[offset + 11];
					final List bl = (List) _symbol_bl.value;
					final Symbol RBRACE = _symbols[offset + 12];
					 return new GenericConstructorDecl(new Modifiers(m), IDENTIFIER, pl, tl, new Opt(c), new Block(bl), l);
			}
			case 443: // class_declaration = CLASS.CLASS IDENTIFIER.IDENTIFIER type_parameters.p class_body.b
			{
					final Symbol CLASS = _symbols[offset + 1];
					final Symbol IDENTIFIER = _symbols[offset + 2];
					final Symbol _symbol_p = _symbols[offset + 3];
					final List p = (List) _symbol_p.value;
					final Symbol _symbol_b = _symbols[offset + 4];
					final List b = (List) _symbol_b.value;
					 return new GenericClassDecl(new Modifiers(new List()), IDENTIFIER, new Opt(), new List(), b, p);
			}
			case 444: // class_declaration = modifiers.m CLASS.CLASS IDENTIFIER.IDENTIFIER type_parameters.p class_body.b
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final List m = (List) _symbol_m.value;
					final Symbol CLASS = _symbols[offset + 2];
					final Symbol IDENTIFIER = _symbols[offset + 3];
					final Symbol _symbol_p = _symbols[offset + 4];
					final List p = (List) _symbol_p.value;
					final Symbol _symbol_b = _symbols[offset + 5];
					final List b = (List) _symbol_b.value;
					 return new GenericClassDecl(new Modifiers(m), IDENTIFIER, new Opt(), new List(), b, p);
			}
			case 445: // class_declaration = CLASS.CLASS IDENTIFIER.IDENTIFIER type_parameters.p super.s class_body.b
			{
					final Symbol CLASS = _symbols[offset + 1];
					final Symbol IDENTIFIER = _symbols[offset + 2];
					final Symbol _symbol_p = _symbols[offset + 3];
					final List p = (List) _symbol_p.value;
					final Symbol _symbol_s = _symbols[offset + 4];
					final Opt s = (Opt) _symbol_s.value;
					final Symbol _symbol_b = _symbols[offset + 5];
					final List b = (List) _symbol_b.value;
					 return new GenericClassDecl(new Modifiers(new List()), IDENTIFIER, s, new List(), b, p);
			}
			case 446: // class_declaration = modifiers.m CLASS.CLASS IDENTIFIER.IDENTIFIER type_parameters.p super.s class_body.b
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final List m = (List) _symbol_m.value;
					final Symbol CLASS = _symbols[offset + 2];
					final Symbol IDENTIFIER = _symbols[offset + 3];
					final Symbol _symbol_p = _symbols[offset + 4];
					final List p = (List) _symbol_p.value;
					final Symbol _symbol_s = _symbols[offset + 5];
					final Opt s = (Opt) _symbol_s.value;
					final Symbol _symbol_b = _symbols[offset + 6];
					final List b = (List) _symbol_b.value;
					 return new GenericClassDecl(new Modifiers(m), IDENTIFIER, s, new List(), b, p);
			}
			case 447: // class_declaration = CLASS.CLASS IDENTIFIER.IDENTIFIER type_parameters.p interfaces.i class_body.b
			{
					final Symbol CLASS = _symbols[offset + 1];
					final Symbol IDENTIFIER = _symbols[offset + 2];
					final Symbol _symbol_p = _symbols[offset + 3];
					final List p = (List) _symbol_p.value;
					final Symbol _symbol_i = _symbols[offset + 4];
					final List i = (List) _symbol_i.value;
					final Symbol _symbol_b = _symbols[offset + 5];
					final List b = (List) _symbol_b.value;
					 return new GenericClassDecl(new Modifiers(new List()), IDENTIFIER, new Opt(), i, b, p);
			}
			case 448: // class_declaration = modifiers.m CLASS.CLASS IDENTIFIER.IDENTIFIER type_parameters.p interfaces.i class_body.b
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final List m = (List) _symbol_m.value;
					final Symbol CLASS = _symbols[offset + 2];
					final Symbol IDENTIFIER = _symbols[offset + 3];
					final Symbol _symbol_p = _symbols[offset + 4];
					final List p = (List) _symbol_p.value;
					final Symbol _symbol_i = _symbols[offset + 5];
					final List i = (List) _symbol_i.value;
					final Symbol _symbol_b = _symbols[offset + 6];
					final List b = (List) _symbol_b.value;
					 return new GenericClassDecl(new Modifiers(m), IDENTIFIER, new Opt(), i, b, p);
			}
			case 449: // class_declaration = CLASS.CLASS IDENTIFIER.IDENTIFIER type_parameters.p super.s interfaces.i class_body.b
			{
					final Symbol CLASS = _symbols[offset + 1];
					final Symbol IDENTIFIER = _symbols[offset + 2];
					final Symbol _symbol_p = _symbols[offset + 3];
					final List p = (List) _symbol_p.value;
					final Symbol _symbol_s = _symbols[offset + 4];
					final Opt s = (Opt) _symbol_s.value;
					final Symbol _symbol_i = _symbols[offset + 5];
					final List i = (List) _symbol_i.value;
					final Symbol _symbol_b = _symbols[offset + 6];
					final List b = (List) _symbol_b.value;
					 return new GenericClassDecl(new Modifiers(new List()), IDENTIFIER, s, i, b, p);
			}
			case 450: // class_declaration = modifiers.m CLASS.CLASS IDENTIFIER.IDENTIFIER type_parameters.p super.s interfaces.i class_body.b
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final List m = (List) _symbol_m.value;
					final Symbol CLASS = _symbols[offset + 2];
					final Symbol IDENTIFIER = _symbols[offset + 3];
					final Symbol _symbol_p = _symbols[offset + 4];
					final List p = (List) _symbol_p.value;
					final Symbol _symbol_s = _symbols[offset + 5];
					final Opt s = (Opt) _symbol_s.value;
					final Symbol _symbol_i = _symbols[offset + 6];
					final List i = (List) _symbol_i.value;
					final Symbol _symbol_b = _symbols[offset + 7];
					final List b = (List) _symbol_b.value;
					 return new GenericClassDecl(new Modifiers(m), IDENTIFIER, s, i, b, p);
			}
			case 451: // interface_declaration = INTERFACE.INTERFACE IDENTIFIER.IDENTIFIER type_parameters.p interface_body.b
			{
					final Symbol INTERFACE = _symbols[offset + 1];
					final Symbol IDENTIFIER = _symbols[offset + 2];
					final Symbol _symbol_p = _symbols[offset + 3];
					final List p = (List) _symbol_p.value;
					final Symbol _symbol_b = _symbols[offset + 4];
					final List b = (List) _symbol_b.value;
					 return new GenericInterfaceDecl(new Modifiers(new List()), IDENTIFIER, new List(), b, p);
			}
			case 452: // interface_declaration = modifiers.m INTERFACE.INTERFACE IDENTIFIER.IDENTIFIER type_parameters.p interface_body.b
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final List m = (List) _symbol_m.value;
					final Symbol INTERFACE = _symbols[offset + 2];
					final Symbol IDENTIFIER = _symbols[offset + 3];
					final Symbol _symbol_p = _symbols[offset + 4];
					final List p = (List) _symbol_p.value;
					final Symbol _symbol_b = _symbols[offset + 5];
					final List b = (List) _symbol_b.value;
					 return new GenericInterfaceDecl(new Modifiers(m), IDENTIFIER, new List(), b, p);
			}
			case 453: // interface_declaration = INTERFACE.INTERFACE IDENTIFIER.IDENTIFIER type_parameters.p extends_interfaces.i interface_body.b
			{
					final Symbol INTERFACE = _symbols[offset + 1];
					final Symbol IDENTIFIER = _symbols[offset + 2];
					final Symbol _symbol_p = _symbols[offset + 3];
					final List p = (List) _symbol_p.value;
					final Symbol _symbol_i = _symbols[offset + 4];
					final List i = (List) _symbol_i.value;
					final Symbol _symbol_b = _symbols[offset + 5];
					final List b = (List) _symbol_b.value;
					 return new GenericInterfaceDecl(new Modifiers(new List()), IDENTIFIER, i, b, p);
			}
			case 454: // interface_declaration = modifiers.m INTERFACE.INTERFACE IDENTIFIER.IDENTIFIER type_parameters.p extends_interfaces.i interface_body.b
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final List m = (List) _symbol_m.value;
					final Symbol INTERFACE = _symbols[offset + 2];
					final Symbol IDENTIFIER = _symbols[offset + 3];
					final Symbol _symbol_p = _symbols[offset + 4];
					final List p = (List) _symbol_p.value;
					final Symbol _symbol_i = _symbols[offset + 5];
					final List i = (List) _symbol_i.value;
					final Symbol _symbol_b = _symbols[offset + 6];
					final List b = (List) _symbol_b.value;
					 return new GenericInterfaceDecl(new Modifiers(m), IDENTIFIER, i, b, p);
			}
			case 455: // class_or_interface = name.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Access n = (Access) _symbol_n.value;
					 return n;
			}
			case 456: // class_or_interface = class_or_interface.n LT.LT type_argument_list_1.l DOT.DOT name.end
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Access n = (Access) _symbol_n.value;
					final Symbol LT = _symbols[offset + 2];
					final Symbol _symbol_l = _symbols[offset + 3];
					final List l = (List) _symbol_l.value;
					final Symbol DOT = _symbols[offset + 4];
					final Symbol _symbol_end = _symbols[offset + 5];
					final Access end = (Access) _symbol_end.value;
					 return new ParTypeAccess(n, l).qualifiesAccess(end);
			}
			case 457: // class_or_interface_type = class_or_interface.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Access n = (Access) _symbol_n.value;
					 return n;
			}
			case 458: // class_or_interface_type = class_or_interface.n LT.LT type_argument_list_1.l
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Access n = (Access) _symbol_n.value;
					final Symbol LT = _symbols[offset + 2];
					final Symbol _symbol_l = _symbols[offset + 3];
					final List l = (List) _symbol_l.value;
					 return new ParTypeAccess(n, l);
			}
			case 459: // array_type = class_or_interface.t LT.LT type_argument_list_1.l DOT.DOT name.n dims.d
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final Access t = (Access) _symbol_t.value;
					final Symbol LT = _symbols[offset + 2];
					final Symbol _symbol_l = _symbols[offset + 3];
					final List l = (List) _symbol_l.value;
					final Symbol DOT = _symbols[offset + 4];
					final Symbol _symbol_n = _symbols[offset + 5];
					final Access n = (Access) _symbol_n.value;
					final Symbol _symbol_d = _symbols[offset + 6];
					final List d = (List) _symbol_d.value;
					 return new ParTypeAccess(t, l).qualifiesAccess(n).addArrayDims(d);
			}
			case 460: // array_type = class_or_interface.t LT.LT type_argument_list_1.l dims.d
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final Access t = (Access) _symbol_t.value;
					final Symbol LT = _symbols[offset + 2];
					final Symbol _symbol_l = _symbols[offset + 3];
					final List l = (List) _symbol_l.value;
					final Symbol _symbol_d = _symbols[offset + 4];
					final List d = (List) _symbol_d.value;
					 return new ParTypeAccess(t, l).addArrayDims(d);
			}
			case 461: // type_arguments = LT.LT type_argument_list_1.l
			{
					final Symbol LT = _symbols[offset + 1];
					final Symbol _symbol_l = _symbols[offset + 2];
					final List l = (List) _symbol_l.value;
					 return l;
			}
			case 462: // wildcard = QUESTION.QUESTION
			{
					final Symbol QUESTION = _symbols[offset + 1];
					 return new Wildcard();
			}
			case 463: // wildcard = QUESTION.QUESTION EXTENDS.EXTENDS reference_type.t
			{
					final Symbol QUESTION = _symbols[offset + 1];
					final Symbol EXTENDS = _symbols[offset + 2];
					final Symbol _symbol_t = _symbols[offset + 3];
					final Access t = (Access) _symbol_t.value;
					 return new WildcardExtends(t);
			}
			case 464: // wildcard = QUESTION.QUESTION SUPER.SUPER reference_type.t
			{
					final Symbol QUESTION = _symbols[offset + 1];
					final Symbol SUPER = _symbols[offset + 2];
					final Symbol _symbol_t = _symbols[offset + 3];
					final Access t = (Access) _symbol_t.value;
					 return new WildcardSuper(t);
			}
			case 465: // wildcard_1 = QUESTION.QUESTION GT.GT
			{
					final Symbol QUESTION = _symbols[offset + 1];
					final Symbol GT = _symbols[offset + 2];
					 return new Wildcard();
			}
			case 466: // wildcard_1 = QUESTION.QUESTION EXTENDS.EXTENDS reference_type_1.t
			{
					final Symbol QUESTION = _symbols[offset + 1];
					final Symbol EXTENDS = _symbols[offset + 2];
					final Symbol _symbol_t = _symbols[offset + 3];
					final Access t = (Access) _symbol_t.value;
					 return new WildcardExtends(t);
			}
			case 467: // wildcard_1 = QUESTION.QUESTION SUPER.SUPER reference_type_1.t
			{
					final Symbol QUESTION = _symbols[offset + 1];
					final Symbol SUPER = _symbols[offset + 2];
					final Symbol _symbol_t = _symbols[offset + 3];
					final Access t = (Access) _symbol_t.value;
					 return new WildcardSuper(t);
			}
			case 468: // wildcard_2 = QUESTION.QUESTION RSHIFT.RSHIFT
			{
					final Symbol QUESTION = _symbols[offset + 1];
					final Symbol RSHIFT = _symbols[offset + 2];
					 return new Wildcard();
			}
			case 469: // wildcard_2 = QUESTION.QUESTION EXTENDS.EXTENDS reference_type_2.t
			{
					final Symbol QUESTION = _symbols[offset + 1];
					final Symbol EXTENDS = _symbols[offset + 2];
					final Symbol _symbol_t = _symbols[offset + 3];
					final Access t = (Access) _symbol_t.value;
					 return new WildcardExtends(t);
			}
			case 470: // wildcard_2 = QUESTION.QUESTION SUPER.SUPER reference_type_2.t
			{
					final Symbol QUESTION = _symbols[offset + 1];
					final Symbol SUPER = _symbols[offset + 2];
					final Symbol _symbol_t = _symbols[offset + 3];
					final Access t = (Access) _symbol_t.value;
					 return new WildcardSuper(t);
			}
			case 471: // wildcard_3 = QUESTION.QUESTION URSHIFT.URSHIFT
			{
					final Symbol QUESTION = _symbols[offset + 1];
					final Symbol URSHIFT = _symbols[offset + 2];
					 return new Wildcard();
			}
			case 472: // wildcard_3 = QUESTION.QUESTION EXTENDS.EXTENDS reference_type_3.t
			{
					final Symbol QUESTION = _symbols[offset + 1];
					final Symbol EXTENDS = _symbols[offset + 2];
					final Symbol _symbol_t = _symbols[offset + 3];
					final Access t = (Access) _symbol_t.value;
					 return new WildcardExtends(t);
			}
			case 473: // wildcard_3 = QUESTION.QUESTION SUPER.SUPER reference_type_3.t
			{
					final Symbol QUESTION = _symbols[offset + 1];
					final Symbol SUPER = _symbols[offset + 2];
					final Symbol _symbol_t = _symbols[offset + 3];
					final Access t = (Access) _symbol_t.value;
					 return new WildcardSuper(t);
			}
			case 474: // class_instance_creation_expression = NEW.NEW class_or_interface_type.t LPAREN.LPAREN argument_list_opt.l RPAREN.RPAREN subclass_body_opt.b
			{
					final Symbol NEW = _symbols[offset + 1];
					final Symbol _symbol_t = _symbols[offset + 2];
					final Access t = (Access) _symbol_t.value;
					final Symbol LPAREN = _symbols[offset + 3];
					final Symbol _symbol_l = _symbols[offset + 4];
					final List l = (List) _symbol_l.value;
					final Symbol RPAREN = _symbols[offset + 5];
					final Symbol _symbol_b = _symbols[offset + 6];
					final Opt b = (Opt) _symbol_b.value;
					 return new ClassInstanceExpr(t, l, b);
			}
			case 475: // class_instance_creation_expression = NEW.NEW type_arguments.a class_or_interface_type.t LPAREN.LPAREN argument_list_opt.l RPAREN.RPAREN subclass_body_opt.b
			{
					final Symbol NEW = _symbols[offset + 1];
					final Symbol _symbol_a = _symbols[offset + 2];
					final List a = (List) _symbol_a.value;
					final Symbol _symbol_t = _symbols[offset + 3];
					final Access t = (Access) _symbol_t.value;
					final Symbol LPAREN = _symbols[offset + 4];
					final Symbol _symbol_l = _symbols[offset + 5];
					final List l = (List) _symbol_l.value;
					final Symbol RPAREN = _symbols[offset + 6];
					final Symbol _symbol_b = _symbols[offset + 7];
					final Opt b = (Opt) _symbol_b.value;
					 return new ParClassInstanceExpr(t, l, b, a);
			}
			case 476: // class_instance_creation_expression = primary.n DOT.DOT NEW.NEW simple_name.id LPAREN.LPAREN argument_list_opt.l RPAREN.RPAREN subclass_body_opt.b
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Expr n = (Expr) _symbol_n.value;
					final Symbol DOT = _symbols[offset + 2];
					final Symbol NEW = _symbols[offset + 3];
					final Symbol _symbol_id = _symbols[offset + 4];
					final Access id = (Access) _symbol_id.value;
					final Symbol LPAREN = _symbols[offset + 5];
					final Symbol _symbol_l = _symbols[offset + 6];
					final List l = (List) _symbol_l.value;
					final Symbol RPAREN = _symbols[offset + 7];
					final Symbol _symbol_b = _symbols[offset + 8];
					final Opt b = (Opt) _symbol_b.value;
					 ClassInstanceExpr e = new ClassInstanceExpr(id, l, b); 
        e.setStart(NEW.getStart());
        e.setEnd(RPAREN.getEnd());
        return n.qualifiesAccess(e);
			}
			case 477: // class_instance_creation_expression = primary.n DOT.DOT NEW.NEW simple_name.id type_arguments.a LPAREN.LPAREN argument_list_opt.l RPAREN.RPAREN subclass_body_opt.b
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Expr n = (Expr) _symbol_n.value;
					final Symbol DOT = _symbols[offset + 2];
					final Symbol NEW = _symbols[offset + 3];
					final Symbol _symbol_id = _symbols[offset + 4];
					final Access id = (Access) _symbol_id.value;
					final Symbol _symbol_a = _symbols[offset + 5];
					final List a = (List) _symbol_a.value;
					final Symbol LPAREN = _symbols[offset + 6];
					final Symbol _symbol_l = _symbols[offset + 7];
					final List l = (List) _symbol_l.value;
					final Symbol RPAREN = _symbols[offset + 8];
					final Symbol _symbol_b = _symbols[offset + 9];
					final Opt b = (Opt) _symbol_b.value;
					 ClassInstanceExpr e = new ClassInstanceExpr(new ParTypeAccess(id, a), l, b); 
        e.setStart(NEW.getStart());
        e.setEnd(RPAREN.getEnd());
        return n.qualifiesAccess(e);
			}
			case 478: // class_instance_creation_expression = primary.n DOT.DOT NEW.NEW type_arguments.ca simple_name.id LPAREN.LPAREN argument_list_opt.l RPAREN.RPAREN subclass_body_opt.b
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Expr n = (Expr) _symbol_n.value;
					final Symbol DOT = _symbols[offset + 2];
					final Symbol NEW = _symbols[offset + 3];
					final Symbol _symbol_ca = _symbols[offset + 4];
					final List ca = (List) _symbol_ca.value;
					final Symbol _symbol_id = _symbols[offset + 5];
					final Access id = (Access) _symbol_id.value;
					final Symbol LPAREN = _symbols[offset + 6];
					final Symbol _symbol_l = _symbols[offset + 7];
					final List l = (List) _symbol_l.value;
					final Symbol RPAREN = _symbols[offset + 8];
					final Symbol _symbol_b = _symbols[offset + 9];
					final Opt b = (Opt) _symbol_b.value;
					 return n.qualifiesAccess(new ParClassInstanceExpr(id, l, b, ca));
			}
			case 479: // class_instance_creation_expression = primary.n DOT.DOT NEW.NEW type_arguments.ca simple_name.id type_arguments.ta LPAREN.LPAREN argument_list_opt.l RPAREN.RPAREN subclass_body_opt.b
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Expr n = (Expr) _symbol_n.value;
					final Symbol DOT = _symbols[offset + 2];
					final Symbol NEW = _symbols[offset + 3];
					final Symbol _symbol_ca = _symbols[offset + 4];
					final List ca = (List) _symbol_ca.value;
					final Symbol _symbol_id = _symbols[offset + 5];
					final Access id = (Access) _symbol_id.value;
					final Symbol _symbol_ta = _symbols[offset + 6];
					final List ta = (List) _symbol_ta.value;
					final Symbol LPAREN = _symbols[offset + 7];
					final Symbol _symbol_l = _symbols[offset + 8];
					final List l = (List) _symbol_l.value;
					final Symbol RPAREN = _symbols[offset + 9];
					final Symbol _symbol_b = _symbols[offset + 10];
					final Opt b = (Opt) _symbol_b.value;
					 return n.qualifiesAccess(new ParClassInstanceExpr(new ParTypeAccess(id, ta), l, b, ca));
			}
			case 480: // class_instance_creation_expression = name.n DOT.DOT NEW.NEW simple_name.id LPAREN.LPAREN argument_list_opt.l RPAREN.RPAREN subclass_body_opt.b
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Access n = (Access) _symbol_n.value;
					final Symbol DOT = _symbols[offset + 2];
					final Symbol NEW = _symbols[offset + 3];
					final Symbol _symbol_id = _symbols[offset + 4];
					final Access id = (Access) _symbol_id.value;
					final Symbol LPAREN = _symbols[offset + 5];
					final Symbol _symbol_l = _symbols[offset + 6];
					final List l = (List) _symbol_l.value;
					final Symbol RPAREN = _symbols[offset + 7];
					final Symbol _symbol_b = _symbols[offset + 8];
					final Opt b = (Opt) _symbol_b.value;
					 ClassInstanceExpr e = new ClassInstanceExpr(id, l, b); 
        e.setStart(NEW.getStart());
        e.setEnd(RPAREN.getEnd());
        return n.qualifiesAccess(e);
			}
			case 481: // class_instance_creation_expression = name.n DOT.DOT NEW.NEW simple_name.id type_arguments.a LPAREN.LPAREN argument_list_opt.l RPAREN.RPAREN subclass_body_opt.b
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Access n = (Access) _symbol_n.value;
					final Symbol DOT = _symbols[offset + 2];
					final Symbol NEW = _symbols[offset + 3];
					final Symbol _symbol_id = _symbols[offset + 4];
					final Access id = (Access) _symbol_id.value;
					final Symbol _symbol_a = _symbols[offset + 5];
					final List a = (List) _symbol_a.value;
					final Symbol LPAREN = _symbols[offset + 6];
					final Symbol _symbol_l = _symbols[offset + 7];
					final List l = (List) _symbol_l.value;
					final Symbol RPAREN = _symbols[offset + 8];
					final Symbol _symbol_b = _symbols[offset + 9];
					final Opt b = (Opt) _symbol_b.value;
					 ClassInstanceExpr e = new ClassInstanceExpr(new ParTypeAccess(id, a), l, b); 
        e.setStart(NEW.getStart());
        e.setEnd(RPAREN.getEnd());
        return n.qualifiesAccess(e);
			}
			case 482: // class_instance_creation_expression = name.n DOT.DOT NEW.NEW type_arguments.ca simple_name.id LPAREN.LPAREN argument_list_opt.l RPAREN.RPAREN subclass_body_opt.b
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Access n = (Access) _symbol_n.value;
					final Symbol DOT = _symbols[offset + 2];
					final Symbol NEW = _symbols[offset + 3];
					final Symbol _symbol_ca = _symbols[offset + 4];
					final List ca = (List) _symbol_ca.value;
					final Symbol _symbol_id = _symbols[offset + 5];
					final Access id = (Access) _symbol_id.value;
					final Symbol LPAREN = _symbols[offset + 6];
					final Symbol _symbol_l = _symbols[offset + 7];
					final List l = (List) _symbol_l.value;
					final Symbol RPAREN = _symbols[offset + 8];
					final Symbol _symbol_b = _symbols[offset + 9];
					final Opt b = (Opt) _symbol_b.value;
					 return n.qualifiesAccess(new ParClassInstanceExpr(id, l, b, ca));
			}
			case 483: // class_instance_creation_expression = name.n DOT.DOT NEW.NEW type_arguments.ca simple_name.id type_arguments.ta LPAREN.LPAREN argument_list_opt.l RPAREN.RPAREN subclass_body_opt.b
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Access n = (Access) _symbol_n.value;
					final Symbol DOT = _symbols[offset + 2];
					final Symbol NEW = _symbols[offset + 3];
					final Symbol _symbol_ca = _symbols[offset + 4];
					final List ca = (List) _symbol_ca.value;
					final Symbol _symbol_id = _symbols[offset + 5];
					final Access id = (Access) _symbol_id.value;
					final Symbol _symbol_ta = _symbols[offset + 6];
					final List ta = (List) _symbol_ta.value;
					final Symbol LPAREN = _symbols[offset + 7];
					final Symbol _symbol_l = _symbols[offset + 8];
					final List l = (List) _symbol_l.value;
					final Symbol RPAREN = _symbols[offset + 9];
					final Symbol _symbol_b = _symbols[offset + 10];
					final Opt b = (Opt) _symbol_b.value;
					 return n.qualifiesAccess(new ParClassInstanceExpr(new ParTypeAccess(id, ta), l, b, ca));
			}
			case 484: // type_argument_list = type_argument.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Access a = (Access) _symbol_a.value;
					 return new List().add(a);
			}
			case 485: // type_argument_list = type_argument_list.l COMMA.COMMA type_argument.a
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol COMMA = _symbols[offset + 2];
					final Symbol _symbol_a = _symbols[offset + 3];
					final Access a = (Access) _symbol_a.value;
					 return l.add(a);
			}
			case 486: // type_argument_list_1 = type_argument_1.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Access a = (Access) _symbol_a.value;
					 return new List().add(a);
			}
			case 487: // type_argument_list_1 = type_argument_list.l COMMA.COMMA type_argument_1.a
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol COMMA = _symbols[offset + 2];
					final Symbol _symbol_a = _symbols[offset + 3];
					final Access a = (Access) _symbol_a.value;
					 return l.add(a);
			}
			case 488: // type_argument_list_2 = type_argument_2.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Access a = (Access) _symbol_a.value;
					 return new List().add(a);
			}
			case 489: // type_argument_list_2 = type_argument_list.l COMMA.COMMA type_argument_2.a
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol COMMA = _symbols[offset + 2];
					final Symbol _symbol_a = _symbols[offset + 3];
					final Access a = (Access) _symbol_a.value;
					 return l.add(a);
			}
			case 490: // type_argument_list_3 = type_argument_3.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Access a = (Access) _symbol_a.value;
					 return new List().add(a);
			}
			case 491: // type_argument_list_3 = type_argument_list.l COMMA.COMMA type_argument_3.a
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol COMMA = _symbols[offset + 2];
					final Symbol _symbol_a = _symbols[offset + 3];
					final Access a = (Access) _symbol_a.value;
					 return l.add(a);
			}
			case 492: // type_argument = reference_type.t
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final Access t = (Access) _symbol_t.value;
					 return t;
			}
			case 493: // type_argument = wildcard.w
			{
					final Symbol _symbol_w = _symbols[offset + 1];
					final Access w = (Access) _symbol_w.value;
					 return w;
			}
			case 494: // type_argument_1 = reference_type_1.t
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final Access t = (Access) _symbol_t.value;
					 return t;
			}
			case 495: // type_argument_1 = wildcard_1.w
			{
					final Symbol _symbol_w = _symbols[offset + 1];
					final Access w = (Access) _symbol_w.value;
					 return w;
			}
			case 496: // type_argument_2 = reference_type_2.t
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final Access t = (Access) _symbol_t.value;
					 return t;
			}
			case 497: // type_argument_2 = wildcard_2.w
			{
					final Symbol _symbol_w = _symbols[offset + 1];
					final Access w = (Access) _symbol_w.value;
					 return w;
			}
			case 498: // type_argument_3 = reference_type_3.t
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final Access t = (Access) _symbol_t.value;
					 return t;
			}
			case 499: // type_argument_3 = wildcard_3.w
			{
					final Symbol _symbol_w = _symbols[offset + 1];
					final Access w = (Access) _symbol_w.value;
					 return w;
			}
			case 500: // reference_type_1 = reference_type.t GT.GT
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final Access t = (Access) _symbol_t.value;
					final Symbol GT = _symbols[offset + 2];
					 return t;
			}
			case 501: // reference_type_1 = class_or_interface.t LT.LT type_argument_list_2.l
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final Access t = (Access) _symbol_t.value;
					final Symbol LT = _symbols[offset + 2];
					final Symbol _symbol_l = _symbols[offset + 3];
					final List l = (List) _symbol_l.value;
					 return new ParTypeAccess(t, l);
			}
			case 502: // reference_type_2 = reference_type.t RSHIFT.RSHIFT
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final Access t = (Access) _symbol_t.value;
					final Symbol RSHIFT = _symbols[offset + 2];
					 return t;
			}
			case 503: // reference_type_2 = class_or_interface.t LT.LT type_argument_list_3.l
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final Access t = (Access) _symbol_t.value;
					final Symbol LT = _symbols[offset + 2];
					final Symbol _symbol_l = _symbols[offset + 3];
					final List l = (List) _symbol_l.value;
					 return new ParTypeAccess(t, l);
			}
			case 504: // reference_type_3 = reference_type.t URSHIFT.URSHIFT
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final Access t = (Access) _symbol_t.value;
					final Symbol URSHIFT = _symbols[offset + 2];
					 return t;
			}
			case 505: // cast_expression = LPAREN.LPAREN name.n LT.LT type_argument_list_1.a RPAREN.RPAREN unary_expression_not_plus_minus.e
			{
					final Symbol LPAREN = _symbols[offset + 1];
					final Symbol _symbol_n = _symbols[offset + 2];
					final Access n = (Access) _symbol_n.value;
					final Symbol LT = _symbols[offset + 3];
					final Symbol _symbol_a = _symbols[offset + 4];
					final List a = (List) _symbol_a.value;
					final Symbol RPAREN = _symbols[offset + 5];
					final Symbol _symbol_e = _symbols[offset + 6];
					final Expr e = (Expr) _symbol_e.value;
					 return new CastExpr(new ParTypeAccess(n, a).addArrayDims(new List()), e);
			}
			case 506: // cast_expression = LPAREN.LPAREN name.n LT.LT type_argument_list_1.a dims.d RPAREN.RPAREN unary_expression_not_plus_minus.e
			{
					final Symbol LPAREN = _symbols[offset + 1];
					final Symbol _symbol_n = _symbols[offset + 2];
					final Access n = (Access) _symbol_n.value;
					final Symbol LT = _symbols[offset + 3];
					final Symbol _symbol_a = _symbols[offset + 4];
					final List a = (List) _symbol_a.value;
					final Symbol _symbol_d = _symbols[offset + 5];
					final List d = (List) _symbol_d.value;
					final Symbol RPAREN = _symbols[offset + 6];
					final Symbol _symbol_e = _symbols[offset + 7];
					final Expr e = (Expr) _symbol_e.value;
					 return new CastExpr(new ParTypeAccess(n, a).addArrayDims(d), e);
			}
			case 507: // cast_expression = LPAREN.LPAREN name.n LT.LT type_argument_list_1.a DOT.DOT class_or_interface_type.t RPAREN.RPAREN unary_expression_not_plus_minus.e
			{
					final Symbol LPAREN = _symbols[offset + 1];
					final Symbol _symbol_n = _symbols[offset + 2];
					final Access n = (Access) _symbol_n.value;
					final Symbol LT = _symbols[offset + 3];
					final Symbol _symbol_a = _symbols[offset + 4];
					final List a = (List) _symbol_a.value;
					final Symbol DOT = _symbols[offset + 5];
					final Symbol _symbol_t = _symbols[offset + 6];
					final Access t = (Access) _symbol_t.value;
					final Symbol RPAREN = _symbols[offset + 7];
					final Symbol _symbol_e = _symbols[offset + 8];
					final Expr e = (Expr) _symbol_e.value;
					 return new CastExpr(new ParTypeAccess(n, a).qualifiesAccess(t).addArrayDims(new List()), e);
			}
			case 508: // cast_expression = LPAREN.LPAREN name.n LT.LT type_argument_list_1.a DOT.DOT class_or_interface_type.t dims.d RPAREN.RPAREN unary_expression_not_plus_minus.e
			{
					final Symbol LPAREN = _symbols[offset + 1];
					final Symbol _symbol_n = _symbols[offset + 2];
					final Access n = (Access) _symbol_n.value;
					final Symbol LT = _symbols[offset + 3];
					final Symbol _symbol_a = _symbols[offset + 4];
					final List a = (List) _symbol_a.value;
					final Symbol DOT = _symbols[offset + 5];
					final Symbol _symbol_t = _symbols[offset + 6];
					final Access t = (Access) _symbol_t.value;
					final Symbol _symbol_d = _symbols[offset + 7];
					final List d = (List) _symbol_d.value;
					final Symbol RPAREN = _symbols[offset + 8];
					final Symbol _symbol_e = _symbols[offset + 9];
					final Expr e = (Expr) _symbol_e.value;
					 return new CastExpr(new ParTypeAccess(n, a).qualifiesAccess(t).addArrayDims(d), e);
			}
			case 509: // type_parameters = LT.LT type_parameter_list_1.l
			{
					final Symbol LT = _symbols[offset + 1];
					final Symbol _symbol_l = _symbols[offset + 2];
					final List l = (List) _symbol_l.value;
					 return l;
			}
			case 510: // type_parameter_list = type_parameter_list.l COMMA.COMMA type_parameter.p
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol COMMA = _symbols[offset + 2];
					final Symbol _symbol_p = _symbols[offset + 3];
					final TypeVariable p = (TypeVariable) _symbol_p.value;
					 return l.add(p);
			}
			case 511: // type_parameter_list = type_parameter.p
			{
					final Symbol _symbol_p = _symbols[offset + 1];
					final TypeVariable p = (TypeVariable) _symbol_p.value;
					 return new List().add(p);
			}
			case 512: // type_parameter_list_1 = type_parameter_1.p
			{
					final Symbol _symbol_p = _symbols[offset + 1];
					final TypeVariable p = (TypeVariable) _symbol_p.value;
					 return new List().add(p);
			}
			case 513: // type_parameter_list_1 = type_parameter_list.l COMMA.COMMA type_parameter_1.p
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol COMMA = _symbols[offset + 2];
					final Symbol _symbol_p = _symbols[offset + 3];
					final TypeVariable p = (TypeVariable) _symbol_p.value;
					 return l.add(p);
			}
			case 514: // type_parameter = IDENTIFIER.IDENTIFIER
			{
					final Symbol IDENTIFIER = _symbols[offset + 1];
					 return new TypeVariable(new Modifiers(), IDENTIFIER, new List(), new List());
			}
			case 515: // type_parameter = IDENTIFIER.IDENTIFIER type_bound.l
			{
					final Symbol IDENTIFIER = _symbols[offset + 1];
					final Symbol _symbol_l = _symbols[offset + 2];
					final List l = (List) _symbol_l.value;
					 return new TypeVariable(new Modifiers(), IDENTIFIER, new List(), l);
			}
			case 516: // type_parameter_1 = IDENTIFIER.IDENTIFIER GT.GT
			{
					final Symbol IDENTIFIER = _symbols[offset + 1];
					final Symbol GT = _symbols[offset + 2];
					 return new TypeVariable(new Modifiers(), IDENTIFIER, new List(), new List());
			}
			case 517: // type_parameter_1 = IDENTIFIER.IDENTIFIER type_bound_1.l
			{
					final Symbol IDENTIFIER = _symbols[offset + 1];
					final Symbol _symbol_l = _symbols[offset + 2];
					final List l = (List) _symbol_l.value;
					 return new TypeVariable(new Modifiers(), IDENTIFIER, new List(), l);
			}
			case 518: // type_bound = EXTENDS.EXTENDS reference_type.t
			{
					final Symbol EXTENDS = _symbols[offset + 1];
					final Symbol _symbol_t = _symbols[offset + 2];
					final Access t = (Access) _symbol_t.value;
					 return new List().add(t);
			}
			case 519: // type_bound = EXTENDS.EXTENDS reference_type.t additional_bound_list.l
			{
					final Symbol EXTENDS = _symbols[offset + 1];
					final Symbol _symbol_t = _symbols[offset + 2];
					final Access t = (Access) _symbol_t.value;
					final Symbol _symbol_l = _symbols[offset + 3];
					final List l = (List) _symbol_l.value;
					 l.insertChild(t,0); return l;
			}
			case 520: // type_bound_1 = EXTENDS.EXTENDS reference_type_1.t
			{
					final Symbol EXTENDS = _symbols[offset + 1];
					final Symbol _symbol_t = _symbols[offset + 2];
					final Access t = (Access) _symbol_t.value;
					 return new List().add(t);
			}
			case 521: // type_bound_1 = EXTENDS.EXTENDS reference_type.t additional_bound_list_1.l
			{
					final Symbol EXTENDS = _symbols[offset + 1];
					final Symbol _symbol_t = _symbols[offset + 2];
					final Access t = (Access) _symbol_t.value;
					final Symbol _symbol_l = _symbols[offset + 3];
					final List l = (List) _symbol_l.value;
					 l.insertChild(t,0); return l;
			}
			case 522: // additional_bound_list = additional_bound.b additional_bound_list.l
			{
					final Symbol _symbol_b = _symbols[offset + 1];
					final Access b = (Access) _symbol_b.value;
					final Symbol _symbol_l = _symbols[offset + 2];
					final List l = (List) _symbol_l.value;
					 l.insertChild(b,0); return l;
			}
			case 523: // additional_bound_list = additional_bound.b
			{
					final Symbol _symbol_b = _symbols[offset + 1];
					final Access b = (Access) _symbol_b.value;
					 return new List().add(b);
			}
			case 524: // additional_bound_list_1 = additional_bound.b additional_bound_list_1.l
			{
					final Symbol _symbol_b = _symbols[offset + 1];
					final Access b = (Access) _symbol_b.value;
					final Symbol _symbol_l = _symbols[offset + 2];
					final List l = (List) _symbol_l.value;
					 l.insertChild(b,0); return l;
			}
			case 525: // additional_bound_list_1 = additional_bound_1.b
			{
					final Symbol _symbol_b = _symbols[offset + 1];
					final Access b = (Access) _symbol_b.value;
					 return new List().add(b);
			}
			case 526: // additional_bound = AND.AND interface_type.t
			{
					final Symbol AND = _symbols[offset + 1];
					final Symbol _symbol_t = _symbols[offset + 2];
					final Access t = (Access) _symbol_t.value;
					 return t;
			}
			case 527: // additional_bound_1 = AND.AND reference_type_1.t
			{
					final Symbol AND = _symbols[offset + 1];
					final Symbol _symbol_t = _symbols[offset + 2];
					final Access t = (Access) _symbol_t.value;
					 return t;
			}
			case 528: // import_declaration = single_static_import_declaration.s
			{
					final Symbol _symbol_s = _symbols[offset + 1];
					final ImportDecl s = (ImportDecl) _symbol_s.value;
					 return s;
			}
			case 529: // import_declaration = static_import_on_demand_declaration.t
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final ImportDecl t = (ImportDecl) _symbol_t.value;
					 return t;
			}
			case 530: // single_static_import_declaration = IMPORT.IMPORT STATIC.STATIC name.n DOT.DOT IDENTIFIER.IDENTIFIER SEMICOLON.SEMICOLON
			{
					final Symbol IMPORT = _symbols[offset + 1];
					final Symbol STATIC = _symbols[offset + 2];
					final Symbol _symbol_n = _symbols[offset + 3];
					final Access n = (Access) _symbol_n.value;
					final Symbol DOT = _symbols[offset + 4];
					final Symbol IDENTIFIER = _symbols[offset + 5];
					final Symbol SEMICOLON = _symbols[offset + 6];
					 return new SingleStaticImportDecl(n, IDENTIFIER);
			}
			case 531: // static_import_on_demand_declaration = IMPORT.IMPORT STATIC.STATIC name.n DOT.DOT MULT.MULT SEMICOLON.SEMICOLON
			{
					final Symbol IMPORT = _symbols[offset + 1];
					final Symbol STATIC = _symbols[offset + 2];
					final Symbol _symbol_n = _symbols[offset + 3];
					final Access n = (Access) _symbol_n.value;
					final Symbol DOT = _symbols[offset + 4];
					final Symbol MULT = _symbols[offset + 5];
					final Symbol SEMICOLON = _symbols[offset + 6];
					 return new StaticImportOnDemandDecl(n);
			}
			case 532: // formal_parameter = type.t ELLIPSIS.ELLIPSIS IDENTIFIER.IDENTIFIER dims_opt.d
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final Access t = (Access) _symbol_t.value;
					final Symbol ELLIPSIS = _symbols[offset + 2];
					final Symbol IDENTIFIER = _symbols[offset + 3];
					final Symbol _symbol_d = _symbols[offset + 4];
					final List d = (List) _symbol_d.value;
					 return new VariableArityParameterDeclaration(new Modifiers(new List()), t.addArrayDims(d), IDENTIFIER);
			}
			case 533: // formal_parameter = modifiers.m type.t ELLIPSIS.ELLIPSIS IDENTIFIER.IDENTIFIER dims_opt.d
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final List m = (List) _symbol_m.value;
					final Symbol _symbol_t = _symbols[offset + 2];
					final Access t = (Access) _symbol_t.value;
					final Symbol ELLIPSIS = _symbols[offset + 3];
					final Symbol IDENTIFIER = _symbols[offset + 4];
					final Symbol _symbol_d = _symbols[offset + 5];
					final List d = (List) _symbol_d.value;
					 return new VariableArityParameterDeclaration(new Modifiers(m), t.addArrayDims(d), IDENTIFIER);
			}
			case 534: // primary_no_new_array = literal.l
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final Expr l = (Expr) _symbol_l.value;
					 return l;
			}
			case 535: // primary_no_new_array = primitive_type.n DOT.DOT class_literal.c
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Access n = (Access) _symbol_n.value;
					final Symbol DOT = _symbols[offset + 2];
					final Symbol _symbol_c = _symbols[offset + 3];
					final ClassAccess c = (ClassAccess) _symbol_c.value;
					 return n.addArrayDims(new List()).qualifiesAccess(c);
			}
			case 536: // primary_no_new_array = primitive_type.n dims.d DOT.DOT class_literal.c
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Access n = (Access) _symbol_n.value;
					final Symbol _symbol_d = _symbols[offset + 2];
					final List d = (List) _symbol_d.value;
					final Symbol DOT = _symbols[offset + 3];
					final Symbol _symbol_c = _symbols[offset + 4];
					final ClassAccess c = (ClassAccess) _symbol_c.value;
					 return n.addArrayDims(d).qualifiesAccess(c);
			}
			case 537: // primary_no_new_array = name.n DOT.DOT class_literal.c
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Access n = (Access) _symbol_n.value;
					final Symbol DOT = _symbols[offset + 2];
					final Symbol _symbol_c = _symbols[offset + 3];
					final ClassAccess c = (ClassAccess) _symbol_c.value;
					 return n.addArrayDims(new List()).qualifiesAccess(c);
			}
			case 538: // primary_no_new_array = name.n dims.d DOT.DOT class_literal.c
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Access n = (Access) _symbol_n.value;
					final Symbol _symbol_d = _symbols[offset + 2];
					final List d = (List) _symbol_d.value;
					final Symbol DOT = _symbols[offset + 3];
					final Symbol _symbol_c = _symbols[offset + 4];
					final ClassAccess c = (ClassAccess) _symbol_c.value;
					 return n.addArrayDims(d).qualifiesAccess(c);
			}
			case 539: // primary_no_new_array = VOID.VOID DOT.DOT class_literal.c
			{
					final Symbol VOID = _symbols[offset + 1];
					final Symbol DOT = _symbols[offset + 2];
					final Symbol _symbol_c = _symbols[offset + 3];
					final ClassAccess c = (ClassAccess) _symbol_c.value;
					 PrimitiveTypeAccess v = new PrimitiveTypeAccess("void");
                                                  v.setStart(VOID.getStart());
                                                  v.setEnd(VOID.getEnd());
                                                  return v.qualifiesAccess(c);
			}
			case 540: // primary_no_new_array = THIS.THIS
			{
					final Symbol THIS = _symbols[offset + 1];
					 return new ThisAccess("this");
			}
			case 541: // primary_no_new_array = name.n DOT.DOT THIS.THIS
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Access n = (Access) _symbol_n.value;
					final Symbol DOT = _symbols[offset + 2];
					final Symbol THIS = _symbols[offset + 3];
					 ThisAccess t = new ThisAccess("this");
                                                  t.setStart(THIS.getStart()); t.setEnd(THIS.getEnd());
                                                  return n.qualifiesAccess(t);
			}
			case 542: // primary_no_new_array = LPAREN.LPAREN expression_nn.e RPAREN.RPAREN
			{
					final Symbol LPAREN = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol RPAREN = _symbols[offset + 3];
					 return new ParExpr(e);
			}
			case 543: // primary_no_new_array = LPAREN.LPAREN name.n RPAREN.RPAREN
			{
					final Symbol LPAREN = _symbols[offset + 1];
					final Symbol _symbol_n = _symbols[offset + 2];
					final Access n = (Access) _symbol_n.value;
					final Symbol RPAREN = _symbols[offset + 3];
					 return new ParExpr(n);
			}
			case 544: // primary_no_new_array = class_instance_creation_expression.c
			{
					final Symbol _symbol_c = _symbols[offset + 1];
					final Expr c = (Expr) _symbol_c.value;
					 return c;
			}
			case 545: // primary_no_new_array = field_access.f
			{
					final Symbol _symbol_f = _symbols[offset + 1];
					final Access f = (Access) _symbol_f.value;
					 return f;
			}
			case 546: // primary_no_new_array = method_invocation.m
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final Access m = (Access) _symbol_m.value;
					 return m;
			}
			case 547: // primary_no_new_array = array_access.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Access a = (Access) _symbol_a.value;
					 return a;
			}
			case 548: // postfix_expression_nn = primary.p
			{
					final Symbol _symbol_p = _symbols[offset + 1];
					final Expr p = (Expr) _symbol_p.value;
					 return p;
			}
			case 549: // postfix_expression_nn = postincrement_expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 550: // postfix_expression_nn = postdecrement_expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 551: // unary_expression_nn = preincrement_expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 552: // unary_expression_nn = predecrement_expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 553: // unary_expression_nn = PLUS.PLUS unary_expression.e
			{
					final Symbol PLUS = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expr e = (Expr) _symbol_e.value;
					 return new PlusExpr(e);
			}
			case 554: // unary_expression_nn = MINUS.MINUS unary_expression.e
			{
					final Symbol MINUS = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expr e = (Expr) _symbol_e.value;
					 return new MinusExpr(e);
			}
			case 555: // unary_expression_nn = unary_expression_not_plus_minus_nn.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 556: // unary_expression_not_plus_minus_nn = postfix_expression_nn.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 557: // unary_expression_not_plus_minus_nn = COMP.COMP unary_expression.e
			{
					final Symbol COMP = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expr e = (Expr) _symbol_e.value;
					 return new BitNotExpr(e);
			}
			case 558: // unary_expression_not_plus_minus_nn = NOT.NOT unary_expression.e
			{
					final Symbol NOT = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expr e = (Expr) _symbol_e.value;
					 return new LogNotExpr(e);
			}
			case 559: // unary_expression_not_plus_minus_nn = cast_expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 560: // multiplicative_expression_nn = unary_expression_nn.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 561: // multiplicative_expression_nn = name.e1 MULT.MULT unary_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Access e1 = (Access) _symbol_e1.value;
					final Symbol MULT = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new MulExpr(e1, e2);
			}
			case 562: // multiplicative_expression_nn = multiplicative_expression_nn.e1 MULT.MULT unary_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol MULT = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new MulExpr(e1, e2);
			}
			case 563: // multiplicative_expression_nn = name.e1 DIV.DIV unary_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Access e1 = (Access) _symbol_e1.value;
					final Symbol DIV = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new DivExpr(e1, e2);
			}
			case 564: // multiplicative_expression_nn = multiplicative_expression_nn.e1 DIV.DIV unary_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol DIV = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new DivExpr(e1, e2);
			}
			case 565: // multiplicative_expression_nn = name.e1 MOD.MOD unary_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Access e1 = (Access) _symbol_e1.value;
					final Symbol MOD = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new ModExpr(e1, e2);
			}
			case 566: // multiplicative_expression_nn = multiplicative_expression_nn.e1 MOD.MOD unary_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol MOD = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new ModExpr(e1, e2);
			}
			case 567: // additive_expression_nn = multiplicative_expression_nn.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 568: // additive_expression_nn = name.e1 PLUS.PLUS multiplicative_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Access e1 = (Access) _symbol_e1.value;
					final Symbol PLUS = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new AddExpr(e1, e2);
			}
			case 569: // additive_expression_nn = additive_expression_nn.e1 PLUS.PLUS multiplicative_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol PLUS = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new AddExpr(e1, e2);
			}
			case 570: // additive_expression_nn = name.e1 MINUS.MINUS multiplicative_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Access e1 = (Access) _symbol_e1.value;
					final Symbol MINUS = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new SubExpr(e1, e2);
			}
			case 571: // additive_expression_nn = additive_expression_nn.e1 MINUS.MINUS multiplicative_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol MINUS = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new SubExpr(e1, e2);
			}
			case 572: // shift_expression_nn = additive_expression_nn.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 573: // shift_expression_nn = name.e1 LSHIFT.LSHIFT additive_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Access e1 = (Access) _symbol_e1.value;
					final Symbol LSHIFT = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new LShiftExpr(e1, e2);
			}
			case 574: // shift_expression_nn = shift_expression_nn.e1 LSHIFT.LSHIFT additive_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol LSHIFT = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new LShiftExpr(e1, e2);
			}
			case 575: // shift_expression_nn = name.e1 RSHIFT.RSHIFT additive_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Access e1 = (Access) _symbol_e1.value;
					final Symbol RSHIFT = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new RShiftExpr(e1, e2);
			}
			case 576: // shift_expression_nn = shift_expression_nn.e1 RSHIFT.RSHIFT additive_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol RSHIFT = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new RShiftExpr(e1, e2);
			}
			case 577: // shift_expression_nn = name.e1 URSHIFT.URSHIFT additive_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Access e1 = (Access) _symbol_e1.value;
					final Symbol URSHIFT = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new URShiftExpr(e1, e2);
			}
			case 578: // shift_expression_nn = shift_expression_nn.e1 URSHIFT.URSHIFT additive_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol URSHIFT = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new URShiftExpr(e1, e2);
			}
			case 579: // relational_expression_nn = shift_expression_nn.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 580: // relational_expression_nn = name.e1 LT.LT shift_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Access e1 = (Access) _symbol_e1.value;
					final Symbol LT = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new LTExpr(e1, e2);
			}
			case 581: // relational_expression_nn = shift_expression_nn.e1 LT.LT shift_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol LT = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new LTExpr(e1, e2);
			}
			case 582: // relational_expression_nn = name.e1 GT.GT shift_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Access e1 = (Access) _symbol_e1.value;
					final Symbol GT = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new GTExpr(e1, e2);
			}
			case 583: // relational_expression_nn = shift_expression_nn.e1 GT.GT shift_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol GT = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new GTExpr(e1, e2);
			}
			case 584: // relational_expression_nn = name.e1 LTEQ.LTEQ shift_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Access e1 = (Access) _symbol_e1.value;
					final Symbol LTEQ = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new LEExpr(e1, e2);
			}
			case 585: // relational_expression_nn = relational_expression_nn.e1 LTEQ.LTEQ shift_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol LTEQ = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new LEExpr(e1, e2);
			}
			case 586: // relational_expression_nn = name.e1 GTEQ.GTEQ shift_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Access e1 = (Access) _symbol_e1.value;
					final Symbol GTEQ = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new GEExpr(e1, e2);
			}
			case 587: // relational_expression_nn = relational_expression_nn.e1 GTEQ.GTEQ shift_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol GTEQ = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new GEExpr(e1, e2);
			}
			case 588: // relational_expression_nn = name.e INSTANCEOF.INSTANCEOF reference_type.t
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Access e = (Access) _symbol_e.value;
					final Symbol INSTANCEOF = _symbols[offset + 2];
					final Symbol _symbol_t = _symbols[offset + 3];
					final Access t = (Access) _symbol_t.value;
					 return new InstanceOfExpr(e, t);
			}
			case 589: // relational_expression_nn = relational_expression_nn.e INSTANCEOF.INSTANCEOF reference_type.t
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol INSTANCEOF = _symbols[offset + 2];
					final Symbol _symbol_t = _symbols[offset + 3];
					final Access t = (Access) _symbol_t.value;
					 return new InstanceOfExpr(e, t);
			}
			case 590: // equality_expression_nn = relational_expression_nn.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 591: // equality_expression_nn = name.e1 EQEQ.EQEQ relational_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Access e1 = (Access) _symbol_e1.value;
					final Symbol EQEQ = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new EQExpr(e1, e2);
			}
			case 592: // equality_expression_nn = equality_expression_nn.e1 EQEQ.EQEQ relational_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol EQEQ = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new EQExpr(e1, e2);
			}
			case 593: // equality_expression_nn = name.e1 NOTEQ.NOTEQ relational_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Access e1 = (Access) _symbol_e1.value;
					final Symbol NOTEQ = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new NEExpr(e1, e2);
			}
			case 594: // equality_expression_nn = equality_expression_nn.e1 NOTEQ.NOTEQ relational_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol NOTEQ = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new NEExpr(e1, e2);
			}
			case 595: // and_expression_nn = equality_expression_nn.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 596: // and_expression_nn = name.e1 AND.AND equality_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Access e1 = (Access) _symbol_e1.value;
					final Symbol AND = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new AndBitwiseExpr(e1, e2);
			}
			case 597: // and_expression_nn = and_expression_nn.e1 AND.AND equality_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol AND = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new AndBitwiseExpr(e1, e2);
			}
			case 598: // exclusive_or_expression_nn = and_expression_nn.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 599: // exclusive_or_expression_nn = name.e1 XOR.XOR and_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Access e1 = (Access) _symbol_e1.value;
					final Symbol XOR = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new XorBitwiseExpr(e1, e2);
			}
			case 600: // exclusive_or_expression_nn = exclusive_or_expression_nn.e1 XOR.XOR and_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol XOR = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new XorBitwiseExpr(e1, e2);
			}
			case 601: // inclusive_or_expression_nn = exclusive_or_expression_nn.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 602: // inclusive_or_expression_nn = name.e1 OR.OR exclusive_or_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Access e1 = (Access) _symbol_e1.value;
					final Symbol OR = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new OrBitwiseExpr(e1, e2);
			}
			case 603: // inclusive_or_expression_nn = inclusive_or_expression_nn.e1 OR.OR exclusive_or_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol OR = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new OrBitwiseExpr(e1, e2);
			}
			case 604: // conditional_and_expression_nn = inclusive_or_expression_nn.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 605: // conditional_and_expression_nn = name.e1 ANDAND.ANDAND inclusive_or_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Access e1 = (Access) _symbol_e1.value;
					final Symbol ANDAND = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new AndLogicalExpr(e1, e2);
			}
			case 606: // conditional_and_expression_nn = conditional_and_expression_nn.e1 ANDAND.ANDAND inclusive_or_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol ANDAND = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new AndLogicalExpr(e1, e2);
			}
			case 607: // conditional_or_expression_nn = conditional_and_expression_nn.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 608: // conditional_or_expression_nn = name.e1 OROR.OROR conditional_and_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Access e1 = (Access) _symbol_e1.value;
					final Symbol OROR = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new OrLogicalExpr(e1, e2);
			}
			case 609: // conditional_or_expression_nn = conditional_or_expression_nn.e1 OROR.OROR conditional_and_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol OROR = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new OrLogicalExpr(e1, e2);
			}
			case 610: // conditional_expression_nn = conditional_or_expression_nn.c
			{
					final Symbol _symbol_c = _symbols[offset + 1];
					final Expr c = (Expr) _symbol_c.value;
					 return c;
			}
			case 611: // conditional_expression_nn = name.c QUESTION.QUESTION expression.e1 COLON.COLON conditional_expression.e2
			{
					final Symbol _symbol_c = _symbols[offset + 1];
					final Access c = (Access) _symbol_c.value;
					final Symbol QUESTION = _symbols[offset + 2];
					final Symbol _symbol_e1 = _symbols[offset + 3];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol COLON = _symbols[offset + 4];
					final Symbol _symbol_e2 = _symbols[offset + 5];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new ConditionalExpr(c, e1, e2);
			}
			case 612: // conditional_expression_nn = conditional_or_expression_nn.c QUESTION.QUESTION expression.e1 COLON.COLON conditional_expression.e2
			{
					final Symbol _symbol_c = _symbols[offset + 1];
					final Expr c = (Expr) _symbol_c.value;
					final Symbol QUESTION = _symbols[offset + 2];
					final Symbol _symbol_e1 = _symbols[offset + 3];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol COLON = _symbols[offset + 4];
					final Symbol _symbol_e2 = _symbols[offset + 5];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new ConditionalExpr(c, e1, e2);
			}
			case 613: // assignment_expression_nn = conditional_expression_nn.c
			{
					final Symbol _symbol_c = _symbols[offset + 1];
					final Expr c = (Expr) _symbol_c.value;
					 return c;
			}
			case 614: // assignment_expression_nn = assignment.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					 return a;
			}
			case 616: // pointcut_expr = or_pointcut_expr.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final PointcutExpr a = (PointcutExpr) _symbol_a.value;
					 return a;
			}
			case 617: // pointcut_expr = pointcut_expr.a ANDAND.ANDAND or_pointcut_expr.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final PointcutExpr a = (PointcutExpr) _symbol_a.value;
					final Symbol ANDAND = _symbols[offset + 2];
					final Symbol _symbol_b = _symbols[offset + 3];
					final PointcutExpr b = (PointcutExpr) _symbol_b.value;
					 return new AndPointcutExpr(a, b);
			}
			case 618: // or_pointcut_expr = unary_pointcut_expr.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final PointcutExpr a = (PointcutExpr) _symbol_a.value;
					 return a;
			}
			case 619: // or_pointcut_expr = or_pointcut_expr.a OROR.OROR unary_pointcut_expr.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final PointcutExpr a = (PointcutExpr) _symbol_a.value;
					final Symbol OROR = _symbols[offset + 2];
					final Symbol _symbol_b = _symbols[offset + 3];
					final PointcutExpr b = (PointcutExpr) _symbol_b.value;
					 return new OrPointcutExpr(a, b);
			}
			case 620: // unary_pointcut_expr = basic_pointcut_expr.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final PointcutExpr a = (PointcutExpr) _symbol_a.value;
					 //ParserTrace.parserTrace("unary_pointcut_expr is a basic_pointcut_expr");
           return a;
			}
			case 621: // unary_pointcut_expr = NOT.NOT unary_pointcut_expr.a
			{
					final Symbol NOT = _symbols[offset + 1];
					final Symbol _symbol_a = _symbols[offset + 2];
					final PointcutExpr a = (PointcutExpr) _symbol_a.value;
					 //ParserTrace.parserTrace("! unary_pointcut_expr");
           return new NegPointcutExpr(a);
			}
			case 622: // basic_pointcut_expr = LPAREN.LPAREN pointcut_expr.a RPAREN.RPAREN
			{
					final Symbol LPAREN = _symbols[offset + 1];
					final Symbol _symbol_a = _symbols[offset + 2];
					final PointcutExpr a = (PointcutExpr) _symbol_a.value;
					final Symbol RPAREN = _symbols[offset + 3];
					 //ParserTrace.parserTrace("basic_pointcut_expr is ( pointcut_expr )");
          return a;
			}
			case 623: // basic_pointcut_expr = PC_CALL.x LPAREN.LPAREN method_constructor_pattern.a RPAREN.y
			{
					final Symbol x = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_a = _symbols[offset + 3];
					final MemberPattern a = (MemberPattern) _symbol_a.value;
					final Symbol y = _symbols[offset + 4];
					 //ParserTrace.parserTrace("CALL pointcut");
          return new CallPointcutExpr(a);
			}
			case 624: // basic_pointcut_expr = PC_EXECUTION.x LPAREN.LPAREN method_constructor_pattern.a RPAREN.y
			{
					final Symbol x = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_a = _symbols[offset + 3];
					final MemberPattern a = (MemberPattern) _symbol_a.value;
					final Symbol y = _symbols[offset + 4];
					 //ParserTrace.parserTrace("EXECUTION pointcut");
          return new ExecutionPointcutExpr(a);
			}
			case 625: // basic_pointcut_expr = PC_INITIALIZATION.x LPAREN.LPAREN constructor_pattern.a RPAREN.y
			{
					final Symbol x = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_a = _symbols[offset + 3];
					final ConstructorPattern a = (ConstructorPattern) _symbol_a.value;
					final Symbol y = _symbols[offset + 4];
					 //ParserTrace.parserTrace("INITIALIZATION pointcut");
          return new InitializationPointcutExpr(a);
			}
			case 626: // basic_pointcut_expr = PC_PREINITIALIZATION.x LPAREN.LPAREN constructor_pattern.a RPAREN.y
			{
					final Symbol x = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_a = _symbols[offset + 3];
					final ConstructorPattern a = (ConstructorPattern) _symbol_a.value;
					final Symbol y = _symbols[offset + 4];
					 //ParserTrace.parserTrace("PREINITIALIZATION pointcut");
          return new PreInitializationPointcutExpr(a);
			}
			case 627: // basic_pointcut_expr = PC_STATICINITIALIZATION.x LPAREN.LPAREN classname_pattern_expr.a RPAREN.y
			{
					final Symbol x = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_a = _symbols[offset + 3];
					final Pattern a = (Pattern) _symbol_a.value;
					final Symbol y = _symbols[offset + 4];
					 //ParserTrace.parserTrace("STATICINITIALIZATION pointcut");
          return new StaticInitializationPointcutExpr(a);
			}
			case 628: // basic_pointcut_expr = PC_GET.x LPAREN.LPAREN field_pattern.a RPAREN.y
			{
					final Symbol x = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_a = _symbols[offset + 3];
					final FieldPattern a = (FieldPattern) _symbol_a.value;
					final Symbol y = _symbols[offset + 4];
					 //ParserTrace.parserTrace("GET pointcut");
          return new GetPointcutExpr(a);
			}
			case 629: // basic_pointcut_expr = PC_SET.x LPAREN.LPAREN field_pattern.a RPAREN.y
			{
					final Symbol x = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_a = _symbols[offset + 3];
					final FieldPattern a = (FieldPattern) _symbol_a.value;
					final Symbol y = _symbols[offset + 4];
					 //ParserTrace.parserTrace("SET pointcut");
          return new SetPointcutExpr(a);
			}
			case 630: // basic_pointcut_expr = PC_HANDLER.x LPAREN.LPAREN classname_pattern_expr.a RPAREN.y
			{
					final Symbol x = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_a = _symbols[offset + 3];
					final Pattern a = (Pattern) _symbol_a.value;
					final Symbol y = _symbols[offset + 4];
					 //ParserTrace.parserTrace("HANDLER pointcut");
          return new HandlerPointcutExpr(a);
			}
			case 631: // basic_pointcut_expr = PC_ADVICEEXECUTION.a LPAREN.LPAREN RPAREN.y
			{
					final Symbol a = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol y = _symbols[offset + 3];
					 //ParserTrace.parserTrace("ADVICEEXECUTION pointcut");
          return new AdviceExecutionPointcutExpr();
			}
			case 632: // basic_pointcut_expr = PC_WITHIN.x LPAREN.LPAREN classname_pattern_expr.a RPAREN.y
			{
					final Symbol x = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_a = _symbols[offset + 3];
					final Pattern a = (Pattern) _symbol_a.value;
					final Symbol y = _symbols[offset + 4];
					 //ParserTrace.parserTrace("WITHIN pointcut on pattern");
          return new WithinPointcutExpr(a);
			}
			case 633: // basic_pointcut_expr = PC_WITHINCODE.x LPAREN.LPAREN method_constructor_pattern.a RPAREN.y
			{
					final Symbol x = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_a = _symbols[offset + 3];
					final MemberPattern a = (MemberPattern) _symbol_a.value;
					final Symbol y = _symbols[offset + 4];
					 //ParserTrace.parserTrace("WITHINCODE pointcut on method_constructor_pattern");
          return new WithinCodePointcutExpr(a);
			}
			case 634: // basic_pointcut_expr = PC_CFLOW.x LPAREN.LPAREN pointcut_expr.a RPAREN.y
			{
					final Symbol x = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_a = _symbols[offset + 3];
					final PointcutExpr a = (PointcutExpr) _symbol_a.value;
					final Symbol y = _symbols[offset + 4];
					 //ParserTrace.parserTrace("CFLOW pointcut");
          return new CflowPointcutExpr(a);
			}
			case 635: // basic_pointcut_expr = PC_CFLOWBELOW.x LPAREN.LPAREN pointcut_expr.a RPAREN.y
			{
					final Symbol x = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_a = _symbols[offset + 3];
					final PointcutExpr a = (PointcutExpr) _symbol_a.value;
					final Symbol y = _symbols[offset + 4];
					 //ParserTrace.parserTrace("CFLOWBELOW pointcut");
          return new CflowBelowPointcutExpr(a);
			}
			case 636: // basic_pointcut_expr = PC_IF.x LPAREN.LPAREN expression.a RPAREN.y
			{
					final Symbol x = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_a = _symbols[offset + 3];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol y = _symbols[offset + 4];
					 //ParserTrace.parserTrace("IF pointcut");
       
          return new IfPointcutExpr(a);
			}
			case 637: // basic_pointcut_expr = PC_THIS.x LPAREN.LPAREN type_id_star.a RPAREN.y
			{
					final Symbol x = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_a = _symbols[offset + 3];
					final BindingPattern a = (BindingPattern) _symbol_a.value;
					final Symbol y = _symbols[offset + 4];
					 //ParserTrace.parserTrace("THIS pointcut");
          return new ThisPointcutExpr(a);
			}
			case 638: // basic_pointcut_expr = PC_TARGET.x LPAREN.LPAREN type_id_star.a RPAREN.y
			{
					final Symbol x = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_a = _symbols[offset + 3];
					final BindingPattern a = (BindingPattern) _symbol_a.value;
					final Symbol y = _symbols[offset + 4];
					 //ParserTrace.parserTrace("TARGET pointcut");
          return new TargetPointcutExpr(a);
			}
			case 639: // basic_pointcut_expr = PC_ARGS.x LPAREN.LPAREN type_id_star_list_opt.a RPAREN.y
			{
					final Symbol x = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_a = _symbols[offset + 3];
					final List a = (List) _symbol_a.value;
					final Symbol y = _symbols[offset + 4];
					 //ParserTrace.parserTrace("ARGS pointcut");
          return new ArgsPointcutExpr(a);
			}
			case 640: // basic_pointcut_expr = name.a LPAREN.LPAREN type_id_star_list_opt.b RPAREN.y
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Access a = (Access) _symbol_a.value;
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_b = _symbols[offset + 3];
					final List b = (List) _symbol_b.value;
					final Symbol y = _symbols[offset + 4];
					 Access pc_access;
          if (a instanceof AbstractDot) {
            AbstractDot dot = (AbstractDot) a;
            ParseName pn = (ParseName) dot.extractLast();
            dot.replaceLast(new PointcutAccess(pn.getID()));
            pc_access = dot;
          } else {
            ParseName pn = (ParseName) a;
            pc_access = new PointcutAccess(pn.getID());
          }
          return new NamedPointcutExpr(pc_access, b);
			}
			case 641: // name_pattern = simple_name_pattern.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final SimpleNamePattern a = (SimpleNamePattern) _symbol_a.value;
					 return a;
			}
			case 642: // name_pattern = name_pattern.a DOT.DOT simple_name_pattern.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final NamePattern a = (NamePattern) _symbol_a.value;
					final Symbol DOT = _symbols[offset + 2];
					final Symbol _symbol_b = _symbols[offset + 3];
					final SimpleNamePattern b = (SimpleNamePattern) _symbol_b.value;
					 return new DotNamePattern(a, b);
			}
			case 643: // name_pattern = name_pattern.a PC_DOTDOT.d simple_name_pattern.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final NamePattern a = (NamePattern) _symbol_a.value;
					final Symbol d = _symbols[offset + 2];
					final Symbol _symbol_b = _symbols[offset + 3];
					final SimpleNamePattern b = (SimpleNamePattern) _symbol_b.value;
					 return new DotDotNamePattern(a, b);
			}
			case 644: // simple_name_pattern = MULT.m
			{
					final Symbol m = _symbols[offset + 1];
					 //ParserTrace.parserTrace("name_pattern is a star: ");
           return new SimpleNamePattern("*");
			}
			case 645: // simple_name_pattern = IDENTIFIERPATTERN.a
			{
					final Symbol a = _symbols[offset + 1];
					 //ParserTrace.parserTrace("name_pattern is simple name pattern: " + ((String)a.value));
           return new SimpleNamePattern(((String)a.value));
			}
			case 646: // simple_name_pattern = IDENTIFIER.IDENTIFIER
			{
					final Symbol IDENTIFIER = _symbols[offset + 1];
					 //ParserTrace.parserTrace("name_pattern is identifer: " + IDENTIFIER.value);
           return new SimpleNamePattern(IDENTIFIER);
			}
			case 647: // simple_name_pattern = ASPECT.a
			{
					final Symbol a = _symbols[offset + 1];
					 //ParserTrace.parserTrace("aspectj_reserved_identifier: " + ((String)a.value));
        return new SimpleNamePattern(((String)a.value).toString());
			}
			case 648: // simple_name_pattern = PC_ADVICEEXECUTION.a
			{
					final Symbol a = _symbols[offset + 1];
					 //ParserTrace.parserTrace("aspectj_reserved_identifier: " + ((String)a.value));
        return new SimpleNamePattern(((String)a.value).toString());
			}
			case 649: // simple_name_pattern = PC_ARGS.a
			{
					final Symbol a = _symbols[offset + 1];
					 //ParserTrace.parserTrace("aspectj_reserved_identifier: " + ((String)a.value));
        return new SimpleNamePattern(((String)a.value).toString());
			}
			case 650: // simple_name_pattern = PC_CALL.a
			{
					final Symbol a = _symbols[offset + 1];
					 //ParserTrace.parserTrace("aspectj_reserved_identifier: " + ((String)a.value));
        return new SimpleNamePattern(((String)a.value).toString());
			}
			case 651: // simple_name_pattern = PC_CFLOW.a
			{
					final Symbol a = _symbols[offset + 1];
					 //ParserTrace.parserTrace("aspectj_reserved_identifier: " + ((String)a.value));
        return new SimpleNamePattern(((String)a.value).toString());
			}
			case 652: // simple_name_pattern = PC_CFLOWBELOW.a
			{
					final Symbol a = _symbols[offset + 1];
					 //ParserTrace.parserTrace("aspectj_reserved_identifier: " + ((String)a.value));
        return new SimpleNamePattern(((String)a.value).toString());
			}
			case 653: // simple_name_pattern = PC_ERROR.a
			{
					final Symbol a = _symbols[offset + 1];
					 //ParserTrace.parserTrace("aspectj_reserved_identifier: " + ((String)a.value));
        return new SimpleNamePattern(((String)a.value).toString());
			}
			case 654: // simple_name_pattern = PC_EXECUTION.a
			{
					final Symbol a = _symbols[offset + 1];
					 //ParserTrace.parserTrace("aspectj_reserved_identifier: " + ((String)a.value));
        return new SimpleNamePattern(((String)a.value).toString());
			}
			case 655: // simple_name_pattern = PC_GET.a
			{
					final Symbol a = _symbols[offset + 1];
					 //ParserTrace.parserTrace("aspectj_reserved_identifier: " + ((String)a.value));
        return new SimpleNamePattern(((String)a.value).toString());
			}
			case 656: // simple_name_pattern = PC_HANDLER.a
			{
					final Symbol a = _symbols[offset + 1];
					 //ParserTrace.parserTrace("aspectj_reserved_identifier: " + ((String)a.value));
        return new SimpleNamePattern(((String)a.value).toString());
			}
			case 657: // simple_name_pattern = PC_INITIALIZATION.a
			{
					final Symbol a = _symbols[offset + 1];
					 //ParserTrace.parserTrace("aspectj_reserved_identifier: " + ((String)a.value));
        return new SimpleNamePattern(((String)a.value).toString());
			}
			case 658: // simple_name_pattern = PC_PARENTS.a
			{
					final Symbol a = _symbols[offset + 1];
					 //ParserTrace.parserTrace("aspectj_reserved_identifier: " + ((String)a.value));
        return new SimpleNamePattern(((String)a.value).toString());
			}
			case 659: // simple_name_pattern = PC_PRECEDENCE.a
			{
					final Symbol a = _symbols[offset + 1];
					 //ParserTrace.parserTrace("aspectj_reserved_identifier: " + ((String)a.value));
        return new SimpleNamePattern(((String)a.value).toString());
			}
			case 660: // simple_name_pattern = PC_PREINITIALIZATION.a
			{
					final Symbol a = _symbols[offset + 1];
					 //ParserTrace.parserTrace("aspectj_reserved_identifier: " + ((String)a.value));
        return new SimpleNamePattern(((String)a.value).toString());
			}
			case 661: // simple_name_pattern = PC_RETURNING.a
			{
					final Symbol a = _symbols[offset + 1];
					 //ParserTrace.parserTrace("aspectj_reserved_identifier: " + ((String)a.value));
        return new SimpleNamePattern(((String)a.value).toString());
			}
			case 662: // simple_name_pattern = PC_SET.a
			{
					final Symbol a = _symbols[offset + 1];
					 //ParserTrace.parserTrace("aspectj_reserved_identifier: " + ((String)a.value));
        return new SimpleNamePattern(((String)a.value).toString());
			}
			case 663: // simple_name_pattern = PC_SOFT.a
			{
					final Symbol a = _symbols[offset + 1];
					 //ParserTrace.parserTrace("aspectj_reserved_identifier: " + ((String)a.value));
        return new SimpleNamePattern(((String)a.value).toString());
			}
			case 664: // simple_name_pattern = PC_STATICINITIALIZATION.a
			{
					final Symbol a = _symbols[offset + 1];
					 //ParserTrace.parserTrace("aspectj_reserved_identifier: " + ((String)a.value));
        return new SimpleNamePattern(((String)a.value).toString());
			}
			case 665: // simple_name_pattern = PC_TARGET.a
			{
					final Symbol a = _symbols[offset + 1];
					 //ParserTrace.parserTrace("aspectj_reserved_identifier: " + ((String)a.value));
        return new SimpleNamePattern(((String)a.value).toString());
			}
			case 666: // simple_name_pattern = PC_THROWING.a
			{
					final Symbol a = _symbols[offset + 1];
					 //ParserTrace.parserTrace("aspectj_reserved_identifier: " + ((String)a.value));
        return new SimpleNamePattern(((String)a.value).toString());
			}
			case 667: // simple_name_pattern = PC_WARNING.a
			{
					final Symbol a = _symbols[offset + 1];
					 //ParserTrace.parserTrace("aspectj_reserved_identifier: " + ((String)a.value));
        return new SimpleNamePattern(((String)a.value).toString());
			}
			case 668: // simple_name_pattern = PC_WITHINCODE.a
			{
					final Symbol a = _symbols[offset + 1];
					 //ParserTrace.parserTrace("aspectj_reserved_identifier: " + ((String)a.value));
        return new SimpleNamePattern(((String)a.value).toString());
			}
			case 669: // classtype_dot_id = simple_name_pattern.b
			{
					final Symbol _symbol_b = _symbols[offset + 1];
					final SimpleNamePattern b = (SimpleNamePattern) _symbol_b.value;
					 //ParserTrace.parserTrace("classtype_dot_id is simple_name_pattern: ");
	   return b;
			}
			case 670: // classtype_dot_id = name_pattern.a DOT.DOT simple_name_pattern.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final NamePattern a = (NamePattern) _symbol_a.value;
					final Symbol DOT = _symbols[offset + 2];
					final Symbol _symbol_b = _symbols[offset + 3];
					final SimpleNamePattern b = (SimpleNamePattern) _symbol_b.value;
					 //ParserTrace.parserTrace("classtype_dot_id is np . simple_name_pattern");
           return new DotNamePattern(a, b);
			}
			case 671: // classtype_dot_id = name_pattern.a PC_PLUS.p DOT.DOT simple_name_pattern.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final NamePattern a = (NamePattern) _symbol_a.value;
					final Symbol p = _symbols[offset + 2];
					final Symbol DOT = _symbols[offset + 3];
					final Symbol _symbol_b = _symbols[offset + 4];
					final SimpleNamePattern b = (SimpleNamePattern) _symbol_b.value;
					 //ParserTrace.parserTrace("classtype_dot_id is np + . simple_name_pattern");
           return new DotNamePattern(new SubtypeNamePattern(a), b);
			}
			case 672: // classtype_dot_id = name_pattern.a PC_DOTDOT.d simple_name_pattern.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final NamePattern a = (NamePattern) _symbol_a.value;
					final Symbol d = _symbols[offset + 2];
					final Symbol _symbol_b = _symbols[offset + 3];
					final SimpleNamePattern b = (SimpleNamePattern) _symbol_b.value;
					 //ParserTrace.parserTrace("classtype_dot_id is np . simple_name_pattern");
           return new DotDotNamePattern(a, b);
			}
			case 673: // classtype_dot_id = LPAREN.x type_pattern_expr.a RPAREN.y DOT.DOT simple_name_pattern.b
			{
					final Symbol x = _symbols[offset + 1];
					final Symbol _symbol_a = _symbols[offset + 2];
					final Pattern a = (Pattern) _symbol_a.value;
					final Symbol y = _symbols[offset + 3];
					final Symbol DOT = _symbols[offset + 4];
					final Symbol _symbol_b = _symbols[offset + 5];
					final SimpleNamePattern b = (SimpleNamePattern) _symbol_b.value;
					 //ParserTrace.parserTrace("(tpe) . new");
          return new TypeDotNamePattern(a, b);
			}
			case 674: // classtype_dot_new = NEW.a
			{
					final Symbol a = _symbols[offset + 1];
					 //ParserTrace.parserTrace("classtype_dot_new is NEW: ");
	   return new DotNamePattern(new SimpleNamePattern("*"),
	                             new SimpleNamePattern("<init>"));
			}
			case 675: // classtype_dot_new = name_pattern.a DOT.DOT NEW.y
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final NamePattern a = (NamePattern) _symbol_a.value;
					final Symbol DOT = _symbols[offset + 2];
					final Symbol y = _symbols[offset + 3];
					 //ParserTrace.parserTrace("classtype_dot_new is np . NEW");
           return new DotNamePattern(a, new SimpleNamePattern("<init>"));
			}
			case 676: // classtype_dot_new = name_pattern.a PC_PLUS.p DOT.DOT NEW.y
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final NamePattern a = (NamePattern) _symbol_a.value;
					final Symbol p = _symbols[offset + 2];
					final Symbol DOT = _symbols[offset + 3];
					final Symbol y = _symbols[offset + 4];
					 //ParserTrace.parserTrace("classtype_dot_new is np + . NEW");
           return new DotNamePattern(new SubtypeNamePattern(a), new SimpleNamePattern("<init>"));
			}
			case 677: // classtype_dot_new = name_pattern.a PC_DOTDOT.d NEW.y
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final NamePattern a = (NamePattern) _symbol_a.value;
					final Symbol d = _symbols[offset + 2];
					final Symbol y = _symbols[offset + 3];
					 //ParserTrace.parserTrace("classtype_dot_new is np .. NEW");
           return new DotDotNamePattern(a, new SimpleNamePattern("<init>"));
			}
			case 678: // classtype_dot_new = LPAREN.x type_pattern_expr.a RPAREN.RPAREN DOT.DOT NEW.y
			{
					final Symbol x = _symbols[offset + 1];
					final Symbol _symbol_a = _symbols[offset + 2];
					final Pattern a = (Pattern) _symbol_a.value;
					final Symbol RPAREN = _symbols[offset + 3];
					final Symbol DOT = _symbols[offset + 4];
					final Symbol y = _symbols[offset + 5];
					 //ParserTrace.parserTrace("(tpe) . new");
          return new TypeDotNamePattern(a, new SimpleNamePattern("<init>"));
			}
			case 679: // type_pattern_expr = or_type_pattern_expr.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Pattern a = (Pattern) _symbol_a.value;
					 //ParserTrace.parserTrace("type_pattern_expr is an or_type_pattern_expr");
           return a;
			}
			case 680: // type_pattern_expr = type_pattern_expr.a PC_ANDAND.PC_ANDAND or_type_pattern_expr.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Pattern a = (Pattern) _symbol_a.value;
					final Symbol PC_ANDAND = _symbols[offset + 2];
					final Symbol _symbol_b = _symbols[offset + 3];
					final Pattern b = (Pattern) _symbol_b.value;
					 //ParserTrace.parserTrace("type_pattern_expr && or_type_pattern_expr");
	   return new AndPattern(a, b);
			}
			case 681: // or_type_pattern_expr = unary_type_pattern_expr.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Pattern a = (Pattern) _symbol_a.value;
					 //ParserTrace.parserTrace("or_type_pattern_expr is a unary_type_pattern_expr");
           return a;
			}
			case 682: // or_type_pattern_expr = or_type_pattern_expr.a PC_OROR.PC_OROR unary_type_pattern_expr.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Pattern a = (Pattern) _symbol_a.value;
					final Symbol PC_OROR = _symbols[offset + 2];
					final Symbol _symbol_b = _symbols[offset + 3];
					final Pattern b = (Pattern) _symbol_b.value;
					 //ParserTrace.parserTrace("or_type_pattern_expr || unary_type_pattern_expr");
           return new OrPattern(a, b);
			}
			case 683: // unary_type_pattern_expr = basic_type_pattern.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final NamePattern a = (NamePattern) _symbol_a.value;
					 //ParserTrace.parserTrace("unary_type_pattern_expr is a  basic_type_pattern");
           return a;
			}
			case 684: // unary_type_pattern_expr = NOT.a unary_type_pattern_expr.b
			{
					final Symbol a = _symbols[offset + 1];
					final Symbol _symbol_b = _symbols[offset + 2];
					final Pattern b = (Pattern) _symbol_b.value;
					 //ParserTrace.parserTrace("! unary_type_pattern_expr");
           return new NegPattern(b);
			}
			case 685: // basic_type_pattern = VOID.a
			{
					final Symbol a = _symbols[offset + 1];
					 //ParserTrace.parserTrace("VOID type");
          return new ExplicitTypeNamePattern(new TypeAccess("void"));
			}
			case 686: // basic_type_pattern = base_type_pattern.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final NamePattern a = (NamePattern) _symbol_a.value;
					 //ParserTrace.parserTrace("basic_type_pattern is a reference_type_pattern");
          return a;
			}
			case 687: // basic_type_pattern = base_type_pattern.a dims.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final NamePattern a = (NamePattern) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 2];
					final List b = (List) _symbol_b.value;
					 //ParserTrace.parserTrace("basic_type_pattern is just a primitive_type");
          return new ArraytypeNamePattern(a, b);
			}
			case 688: // basic_type_pattern = LPAREN.lp type_pattern_expr.a RPAREN.rp
			{
					final Symbol lp = _symbols[offset + 1];
					final Symbol _symbol_a = _symbols[offset + 2];
					final Pattern a = (Pattern) _symbol_a.value;
					final Symbol rp = _symbols[offset + 3];
					 //ParserTrace.parserTrace("basic_type_pattern is a ( type_pattern_expr )");
          return a;
			}
			case 689: // base_type_pattern = primitive_type.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Access a = (Access) _symbol_a.value;
					 //ParserTrace.parserTrace("basic_type_pattern is just a primitive_type");
          return new ExplicitTypeNamePattern(a);
			}
			case 690: // base_type_pattern = name_pattern.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final NamePattern a = (NamePattern) _symbol_a.value;
					 //ParserTrace.parserTrace("reference_type_pattern is a name_pattern");
	  return a;
			}
			case 691: // base_type_pattern = name_pattern.a PC_PLUS.p
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final NamePattern a = (NamePattern) _symbol_a.value;
					final Symbol p = _symbols[offset + 2];
					 //ParserTrace.parserTrace("reference_type_pattern is name_pattern +");
          return new SubtypeNamePattern(a);
			}
			case 692: // classname_pattern_expr = and_classname_pattern_expr.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Pattern a = (Pattern) _symbol_a.value;
					 //ParserTrace.parserTrace("classname_pattern_expr is an and_classname_pattern_expr");
           return a;
			}
			case 693: // classname_pattern_expr = classname_pattern_expr.a PC_OROR.PC_OROR and_classname_pattern_expr.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Pattern a = (Pattern) _symbol_a.value;
					final Symbol PC_OROR = _symbols[offset + 2];
					final Symbol _symbol_b = _symbols[offset + 3];
					final Pattern b = (Pattern) _symbol_b.value;
					 //ParserTrace.parserTrace("classname_pattern_expr || and_classname_pattern_expr");
           return new OrPattern(a, b);
			}
			case 694: // and_classname_pattern_expr = unary_classname_pattern_expr.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Pattern a = (Pattern) _symbol_a.value;
					 //ParserTrace.parserTrace("and_classname_pattern_expr is a unary_classname_pattern_expr");
           return a;
			}
			case 695: // and_classname_pattern_expr = and_classname_pattern_expr.a PC_ANDAND.PC_ANDAND unary_classname_pattern_expr.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Pattern a = (Pattern) _symbol_a.value;
					final Symbol PC_ANDAND = _symbols[offset + 2];
					final Symbol _symbol_b = _symbols[offset + 3];
					final Pattern b = (Pattern) _symbol_b.value;
					 //ParserTrace.parserTrace("and_classname_pattern_expr && unary_classname_pattern_expr");
           return new AndPattern(a, b);
			}
			case 696: // unary_classname_pattern_expr = basic_classname_pattern.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Pattern a = (Pattern) _symbol_a.value;
					 //ParserTrace.parserTrace("unary_classname_pattern_expr is a  basic_classname_pattern");
           return a;
			}
			case 697: // unary_classname_pattern_expr = NOT.x unary_classname_pattern_expr.a
			{
					final Symbol x = _symbols[offset + 1];
					final Symbol _symbol_a = _symbols[offset + 2];
					final Pattern a = (Pattern) _symbol_a.value;
					 //ParserTrace.parserTrace("! unary_classname_pattern_expr");
           return new NegPattern(a);
			}
			case 698: // basic_classname_pattern = name_pattern.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final NamePattern a = (NamePattern) _symbol_a.value;
					 //ParserTrace.parserTrace("classname_type_pattern is a name_pattern");
	   return a;
			}
			case 699: // basic_classname_pattern = name_pattern.a PC_PLUS.p
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final NamePattern a = (NamePattern) _symbol_a.value;
					final Symbol p = _symbols[offset + 2];
					 //ParserTrace.parserTrace("classname_type_pattern is name_pattern +");
           return new SubtypeNamePattern(a);
			}
			case 700: // basic_classname_pattern = LPAREN.lp classname_pattern_expr.a RPAREN.rp
			{
					final Symbol lp = _symbols[offset + 1];
					final Symbol _symbol_a = _symbols[offset + 2];
					final Pattern a = (Pattern) _symbol_a.value;
					final Symbol rp = _symbols[offset + 3];
					 //ParserTrace.parserTrace("basic_classname_pattern is a ( classname_pattern_expr )");
           return a;
			}
			case 701: // classname_pattern_expr_nobang = and_classname_pattern_expr_nobang.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final NamePattern a = (NamePattern) _symbol_a.value;
					 //ParserTrace.parserTrace("classname_pattern_expr_nobang is an and_classname_pattern_expr");
           return a;
			}
			case 702: // classname_pattern_expr_nobang = classname_pattern_expr_nobang.a PC_OROR.PC_OROR and_classname_pattern_expr.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final NamePattern a = (NamePattern) _symbol_a.value;
					final Symbol PC_OROR = _symbols[offset + 2];
					final Symbol _symbol_b = _symbols[offset + 3];
					final Pattern b = (Pattern) _symbol_b.value;
					 //ParserTrace.parserTrace("classname_pattern_expr_nobang || and_classname_pattern_expr");
           return new OrPattern(a, b);
			}
			case 703: // and_classname_pattern_expr_nobang = basic_classname_pattern.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Pattern a = (Pattern) _symbol_a.value;
					 //ParserTrace.parserTrace("and_classname_pattern_expr_nobang is a basic_classname_pattern");
           return a;
			}
			case 704: // and_classname_pattern_expr_nobang = and_classname_pattern_expr_nobang.a PC_ANDAND.PC_ANDAND unary_classname_pattern_expr.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final NamePattern a = (NamePattern) _symbol_a.value;
					final Symbol PC_ANDAND = _symbols[offset + 2];
					final Symbol _symbol_b = _symbols[offset + 3];
					final Pattern b = (Pattern) _symbol_b.value;
					 //ParserTrace.parserTrace("and_classname_pattern_expr_nobang && unary_classname_pattern_expr");
           return new AndPattern(a, b);
			}
			case 705: // modifier_pattern_expr = modifier.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Modifier a = (Modifier) _symbol_a.value;
					 //ParserTrace.parserTrace("first modifier " + a);
	  return new List().add(new ModifierPattern(a));
			}
			case 706: // modifier_pattern_expr = NOT.b modifier.a
			{
					final Symbol b = _symbols[offset + 1];
					final Symbol _symbol_a = _symbols[offset + 2];
					final Modifier a = (Modifier) _symbol_a.value;
					 //ParserTrace.parserTrace("first modifier is NOT " + a);
	  return new List().add(new NegModifierPattern(a));
			}
			case 707: // modifier_pattern_expr = modifier_pattern_expr.a modifier.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final List a = (List) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 2];
					final Modifier b = (Modifier) _symbol_b.value;
					 //ParserTrace.parserTrace("another modifier is " + b);
          return a.add(new ModifierPattern(b));
			}
			case 708: // modifier_pattern_expr = modifier_pattern_expr.a NOT.c modifier.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final List a = (List) _symbol_a.value;
					final Symbol c = _symbols[offset + 2];
					final Symbol _symbol_b = _symbols[offset + 3];
					final Modifier b = (Modifier) _symbol_b.value;
					 //ParserTrace.parserTrace("another modifier is NOT" + b);
          return a.add(new NegModifierPattern(b));
			}
			case 709: // throws_pattern_list_opt = 
			{
					 //ParserTrace.parserTrace("no throws patterns");
          return new List();
			}
			case 710: // throws_pattern_list_opt = THROWS.THROWS throws_pattern_list.a
			{
					final Symbol THROWS = _symbols[offset + 1];
					final Symbol _symbol_a = _symbols[offset + 2];
					final List a = (List) _symbol_a.value;
					 //ParserTrace.parserTrace("has throws patterns");
          return a;
			}
			case 711: // throws_pattern_list = throws_pattern.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final NamePattern a = (NamePattern) _symbol_a.value;
					 //ParserTrace.parserTrace("First throws pattern in the list.");
           return new List().add(a);
			}
			case 712: // throws_pattern_list = throws_pattern_list.a COMMA.COMMA throws_pattern.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final List a = (List) _symbol_a.value;
					final Symbol COMMA = _symbols[offset + 2];
					final Symbol _symbol_b = _symbols[offset + 3];
					final NamePattern b = (NamePattern) _symbol_b.value;
					 //ParserTrace.parserTrace("Another throws parameter");
	   return a.add(b);
			}
			case 713: // throws_pattern = classname_pattern_expr_nobang.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final NamePattern a = (NamePattern) _symbol_a.value;
					 //ParserTrace.parserTrace("throws pattern is " + a);
	  return a;
			}
			case 714: // throws_pattern = NOT.b classname_pattern_expr.a
			{
					final Symbol b = _symbols[offset + 1];
					final Symbol _symbol_a = _symbols[offset + 2];
					final Pattern a = (Pattern) _symbol_a.value;
					 //ParserTrace.parserTrace("throws pattern is NOT " + a);
          return new UniversalNegPattern(a);
			}
			case 715: // method_constructor_pattern = method_pattern.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final MethodPattern a = (MethodPattern) _symbol_a.value;
					 //ParserTrace.parserTrace("method_constructor is method");
          return a;
			}
			case 716: // method_constructor_pattern = constructor_pattern.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final ConstructorPattern a = (ConstructorPattern) _symbol_a.value;
					 //ParserTrace.parserTrace("method_constructor is constructor");
          return a;
			}
			case 717: // method_pattern = modifier_pattern_expr.a type_pattern_expr.b classtype_dot_id.c LPAREN.lp formal_pattern_list_opt.d RPAREN.rp throws_pattern_list_opt.e
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final List a = (List) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 2];
					final Pattern b = (Pattern) _symbol_b.value;
					final Symbol _symbol_c = _symbols[offset + 3];
					final NamePattern c = (NamePattern) _symbol_c.value;
					final Symbol lp = _symbols[offset + 4];
					final Symbol _symbol_d = _symbols[offset + 5];
					final List d = (List) _symbol_d.value;
					final Symbol rp = _symbols[offset + 6];
					final Symbol _symbol_e = _symbols[offset + 7];
					final List e = (List) _symbol_e.value;
					 //ParserTrace.parserTrace("method_pattern with modifiers");
           return new MethodPattern(a, b, c, d, e);
			}
			case 718: // method_pattern = type_pattern_expr.b classtype_dot_id.c LPAREN.lp formal_pattern_list_opt.d RPAREN.rp throws_pattern_list_opt.e
			{
					final Symbol _symbol_b = _symbols[offset + 1];
					final Pattern b = (Pattern) _symbol_b.value;
					final Symbol _symbol_c = _symbols[offset + 2];
					final NamePattern c = (NamePattern) _symbol_c.value;
					final Symbol lp = _symbols[offset + 3];
					final Symbol _symbol_d = _symbols[offset + 4];
					final List d = (List) _symbol_d.value;
					final Symbol rp = _symbols[offset + 5];
					final Symbol _symbol_e = _symbols[offset + 6];
					final List e = (List) _symbol_e.value;
					 //ParserTrace.parserTrace("method_pattern no modifiers");
           return new MethodPattern(new List(), b, c, d, e);
			}
			case 719: // constructor_pattern = modifier_pattern_expr.a classtype_dot_new.b LPAREN.lp formal_pattern_list_opt.c RPAREN.rp throws_pattern_list_opt.d
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final List a = (List) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 2];
					final NamePattern b = (NamePattern) _symbol_b.value;
					final Symbol lp = _symbols[offset + 3];
					final Symbol _symbol_c = _symbols[offset + 4];
					final List c = (List) _symbol_c.value;
					final Symbol rp = _symbols[offset + 5];
					final Symbol _symbol_d = _symbols[offset + 6];
					final List d = (List) _symbol_d.value;
					 //ParserTrace.parserTrace("constructor_pattern with modifiers");
           return new ConstructorPattern(a, b, c, d);
			}
			case 720: // constructor_pattern = classtype_dot_new.b LPAREN.lp formal_pattern_list_opt.c RPAREN.rp throws_pattern_list_opt.d
			{
					final Symbol _symbol_b = _symbols[offset + 1];
					final NamePattern b = (NamePattern) _symbol_b.value;
					final Symbol lp = _symbols[offset + 2];
					final Symbol _symbol_c = _symbols[offset + 3];
					final List c = (List) _symbol_c.value;
					final Symbol rp = _symbols[offset + 4];
					final Symbol _symbol_d = _symbols[offset + 5];
					final List d = (List) _symbol_d.value;
					 //ParserTrace.parserTrace("constructor_pattern no modifiers");
           return new ConstructorPattern(new List(), b, c, d);
			}
			case 721: // field_pattern = modifier_pattern_expr.a type_pattern_expr.b classtype_dot_id.c
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final List a = (List) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 2];
					final Pattern b = (Pattern) _symbol_b.value;
					final Symbol _symbol_c = _symbols[offset + 3];
					final NamePattern c = (NamePattern) _symbol_c.value;
					 //ParserTrace.parserTrace("field pattern with modifiers");
          return new FieldPattern(a, b, c);
			}
			case 722: // field_pattern = type_pattern_expr.b classtype_dot_id.c
			{
					final Symbol _symbol_b = _symbols[offset + 1];
					final Pattern b = (Pattern) _symbol_b.value;
					final Symbol _symbol_c = _symbols[offset + 2];
					final NamePattern c = (NamePattern) _symbol_c.value;
					 //ParserTrace.parserTrace("field pattern without modifiers");
          return new FieldPattern(new List(), b, c);
			}
			case 723: // formal_pattern_list = formal_pattern.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final FormalPattern a = (FormalPattern) _symbol_a.value;
					 //ParserTrace.parserTrace("First formal pattern in the list.");
           return new List().add(a);
			}
			case 724: // formal_pattern_list = formal_pattern_list.a COMMA.COMMA formal_pattern.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final List a = (List) _symbol_a.value;
					final Symbol COMMA = _symbols[offset + 2];
					final Symbol _symbol_b = _symbols[offset + 3];
					final FormalPattern b = (FormalPattern) _symbol_b.value;
					 //ParserTrace.parserTrace("Another formal parameter");
	   return a.add(b);
			}
			case 725: // formal_pattern = PC_DOTDOT.a
			{
					final Symbol a = _symbols[offset + 1];
					 //ParserTrace.parserTrace("DOT DOT formal pattern");
            return new WildcardFormalPattern();
			}
			case 726: // formal_pattern = DOT.DOT DOT.a
			{
					final Symbol DOT = _symbols[offset + 1];
					final Symbol a = _symbols[offset + 2];
					 //ParserTrace.parserTrace("DOT DOT formal pattern - separate dots");
            return new WildcardFormalPattern();
			}
			case 727: // formal_pattern = type_pattern_expr.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Pattern a = (Pattern) _symbol_a.value;
					 //ParserTrace.parserTrace("A type pattern formal pattern");
            return new ConcreteFormalPattern(a);
			}
			case 728: // type_id_star_list = type_id_star.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final BindingPattern a = (BindingPattern) _symbol_a.value;
					 //ParserTrace.parserTrace("First pointcut parameter in the list.");
           return new List().add(a);
			}
			case 729: // type_id_star_list = type_id_star_list.a COMMA.COMMA type_id_star.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final List a = (List) _symbol_a.value;
					final Symbol COMMA = _symbols[offset + 2];
					final Symbol _symbol_b = _symbols[offset + 3];
					final BindingPattern b = (BindingPattern) _symbol_b.value;
					 //ParserTrace.parserTrace("Another pointcut parameter");
	   return a.add(b);
			}
			case 730: // type_id_star = PC_MULT.a
			{
					final Symbol a = _symbols[offset + 1];
					 //ParserTrace.parserTrace("Star pointcut parameter");
            return new StarBindingPattern();
			}
			case 731: // type_id_star = PC_DOTDOT.a
			{
					final Symbol a = _symbols[offset + 1];
					 //ParserTrace.parserTrace("DotDot pointcut parameter");
            return new DotDotBindingPattern();
			}
			case 732: // type_id_star = type.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Access a = (Access) _symbol_a.value;
					 //ParserTrace.parserTrace("A type pointcut parameter");
            return new NameBindingPattern(new ExplicitTypeNamePattern(a));
			}
			case 733: // type_id_star = type.a PC_PLUS.PC_PLUS
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Access a = (Access) _symbol_a.value;
					final Symbol PC_PLUS = _symbols[offset + 2];
					 //ParserTrace.parserTrace("A type pointcut parameter with a plus");
            return new NameBindingPattern(new ExplicitTypeNamePattern(a));
			}
			case 734: // class_declaration = layer_declaration.c
			{
					final Symbol _symbol_c = _symbols[offset + 1];
					final LayerDecl c = (LayerDecl) _symbol_c.value;
					 return c;
			}
			case 735: // layer_declaration = modifiers.m LAYER.LAYER IDENTIFIER.IDENTIFIER layer_body.body
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final List m = (List) _symbol_m.value;
					final Symbol LAYER = _symbols[offset + 2];
					final Symbol IDENTIFIER = _symbols[offset + 3];
					final Symbol _symbol_body = _symbols[offset + 4];
					final List body = (List) _symbol_body.value;
					 return new LayerDecl(/*implements*/new List(), new Modifiers(m), IDENTIFIER, new List(), new Opt(), body);
			}
			case 736: // layer_declaration = modifiers.m LAYER.LAYER IDENTIFIER.IDENTIFIER subject_declaration.subject layer_body.body
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final List m = (List) _symbol_m.value;
					final Symbol LAYER = _symbols[offset + 2];
					final Symbol IDENTIFIER = _symbols[offset + 3];
					final Symbol _symbol_subject = _symbols[offset + 4];
					final List subject = (List) _symbol_subject.value;
					final Symbol _symbol_body = _symbols[offset + 5];
					final List body = (List) _symbol_body.value;
					 return new LayerDecl(/*implements*/new List(), new Modifiers(m), IDENTIFIER, subject, new Opt(), body);
			}
			case 737: // layer_declaration = modifiers.m LAYER.LAYER IDENTIFIER.IDENTIFIER super.s layer_body.body
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final List m = (List) _symbol_m.value;
					final Symbol LAYER = _symbols[offset + 2];
					final Symbol IDENTIFIER = _symbols[offset + 3];
					final Symbol _symbol_s = _symbols[offset + 4];
					final Opt s = (Opt) _symbol_s.value;
					final Symbol _symbol_body = _symbols[offset + 5];
					final List body = (List) _symbol_body.value;
					 return new LayerDecl(/*implements*/new List(), new Modifiers(m), IDENTIFIER, new List(), s, body);
			}
			case 738: // layer_declaration = modifiers.m LAYER.LAYER IDENTIFIER.IDENTIFIER subject_declaration.subject super.s layer_body.body
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final List m = (List) _symbol_m.value;
					final Symbol LAYER = _symbols[offset + 2];
					final Symbol IDENTIFIER = _symbols[offset + 3];
					final Symbol _symbol_subject = _symbols[offset + 4];
					final List subject = (List) _symbol_subject.value;
					final Symbol _symbol_s = _symbols[offset + 5];
					final Opt s = (Opt) _symbol_s.value;
					final Symbol _symbol_body = _symbols[offset + 6];
					final List body = (List) _symbol_body.value;
					 return new LayerDecl(/*implements*/new List(), new Modifiers(m), IDENTIFIER, subject, s, body);
			}
			case 739: // subject_declaration = FORSUBJECT.FORSUBJECT class_type_list.i
			{
					final Symbol FORSUBJECT = _symbols[offset + 1];
					final Symbol _symbol_i = _symbols[offset + 2];
					final List i = (List) _symbol_i.value;
					 return i;
			}
			case 740: // class_body_declaration = open_layer_declaration.d
			{
					final Symbol _symbol_d = _symbols[offset + 1];
					final OpenLayerDecl d = (OpenLayerDecl) _symbol_d.value;
					 return d;
			}
			case 741: // open_layer_declaration = LAYER.LAYER type.t layer_body.b
			{
					final Symbol LAYER = _symbols[offset + 1];
					final Symbol _symbol_t = _symbols[offset + 2];
					final Access t = (Access) _symbol_t.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final List b = (List) _symbol_b.value;
					 return new OpenLayerDecl(t, b);
			}
			case 742: // layer_body = LBRACE.LBRACE layer_body_declarations_opt.c RBRACE.RBRACE
			{
					final Symbol LBRACE = _symbols[offset + 1];
					final Symbol _symbol_c = _symbols[offset + 2];
					final List c = (List) _symbol_c.value;
					final Symbol RBRACE = _symbols[offset + 3];
					 return c;
			}
			case 743: // layer_body_declarations = layer_body_declaration.c
			{
					final Symbol _symbol_c = _symbols[offset + 1];
					final BodyDecl c = (BodyDecl) _symbol_c.value;
					 return new List().add(c);
			}
			case 744: // layer_body_declarations = layer_body_declarations.l layer_body_declaration.c
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol _symbol_c = _symbols[offset + 2];
					final BodyDecl c = (BodyDecl) _symbol_c.value;
					 return l.add(c);
			}
			case 745: // layer_body_declaration = partial_method_declaration.c
			{
					final Symbol _symbol_c = _symbols[offset + 1];
					final PartialMethodDecl c = (PartialMethodDecl) _symbol_c.value;
					 return c;
			}
			case 746: // layer_body_declaration = method_declaration.c
			{
					final Symbol _symbol_c = _symbols[offset + 1];
					final MethodDecl c = (MethodDecl) _symbol_c.value;
					 return c;
			}
			case 747: // layer_body_declaration = field_declaration.c
			{
					final Symbol _symbol_c = _symbols[offset + 1];
					final BodyDecl c = (BodyDecl) _symbol_c.value;
					 return c;
			}
			case 748: // layer_body_declaration = constructor_declaration.c
			{
					final Symbol _symbol_c = _symbols[offset + 1];
					final ConstructorDecl c = (ConstructorDecl) _symbol_c.value;
					 return c;
			}
			case 749: // partial_method_declaration = partial_method_header.m method_body.b
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final PartialMethodDecl m = (PartialMethodDecl) _symbol_m.value;
					final Symbol _symbol_b = _symbols[offset + 2];
					final Opt b = (Opt) _symbol_b.value;
					 m.setBlockOpt(b); return m;
			}
			case 750: // partial_method_header = type.retType name_pattern.pattern LPAREN.LPAREN formal_parameter_list_opt.params RPAREN.RPAREN throws_opt.exceptions
			{
					final Symbol _symbol_retType = _symbols[offset + 1];
					final Access retType = (Access) _symbol_retType.value;
					final Symbol _symbol_pattern = _symbols[offset + 2];
					final NamePattern pattern = (NamePattern) _symbol_pattern.value;
					final Symbol LPAREN = _symbols[offset + 3];
					final Symbol _symbol_params = _symbols[offset + 4];
					final List params = (List) _symbol_params.value;
					final Symbol RPAREN = _symbols[offset + 5];
					final Symbol _symbol_exceptions = _symbols[offset + 6];
					final List exceptions = (List) _symbol_exceptions.value;
					 return new PartialMethodDecl(new Modifiers(new List()), retType, "", params, exceptions, new Opt(),  pattern);
			}
			case 751: // partial_method_header = modifiers.m type.retType name_pattern.pattern LPAREN.LPAREN formal_parameter_list_opt.params RPAREN.RPAREN throws_opt.exceptions
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final List m = (List) _symbol_m.value;
					final Symbol _symbol_retType = _symbols[offset + 2];
					final Access retType = (Access) _symbol_retType.value;
					final Symbol _symbol_pattern = _symbols[offset + 3];
					final NamePattern pattern = (NamePattern) _symbol_pattern.value;
					final Symbol LPAREN = _symbols[offset + 4];
					final Symbol _symbol_params = _symbols[offset + 5];
					final List params = (List) _symbol_params.value;
					final Symbol RPAREN = _symbols[offset + 6];
					final Symbol _symbol_exceptions = _symbols[offset + 7];
					final List exceptions = (List) _symbol_exceptions.value;
					 return new PartialMethodDecl(new Modifiers(m), retType, "", params, exceptions, new Opt(),  pattern);
			}
			case 752: // partial_method_header = VOID.VOID name_pattern.pattern LPAREN.LPAREN formal_parameter_list_opt.params RPAREN.RPAREN throws_opt.exceptions
			{
					final Symbol VOID = _symbols[offset + 1];
					final Symbol _symbol_pattern = _symbols[offset + 2];
					final NamePattern pattern = (NamePattern) _symbol_pattern.value;
					final Symbol LPAREN = _symbols[offset + 3];
					final Symbol _symbol_params = _symbols[offset + 4];
					final List params = (List) _symbol_params.value;
					final Symbol RPAREN = _symbols[offset + 5];
					final Symbol _symbol_exceptions = _symbols[offset + 6];
					final List exceptions = (List) _symbol_exceptions.value;
					 return new PartialMethodDecl(new Modifiers(new List()), new PrimitiveTypeAccess("void"), "", params, exceptions, new Opt(),  pattern);
			}
			case 753: // partial_method_header = modifiers.m VOID.VOID name_pattern.pattern LPAREN.LPAREN formal_parameter_list_opt.params RPAREN.RPAREN throws_opt.exceptions
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final List m = (List) _symbol_m.value;
					final Symbol VOID = _symbols[offset + 2];
					final Symbol _symbol_pattern = _symbols[offset + 3];
					final NamePattern pattern = (NamePattern) _symbol_pattern.value;
					final Symbol LPAREN = _symbols[offset + 4];
					final Symbol _symbol_params = _symbols[offset + 5];
					final List params = (List) _symbol_params.value;
					final Symbol RPAREN = _symbols[offset + 6];
					final Symbol _symbol_exceptions = _symbols[offset + 7];
					final List exceptions = (List) _symbol_exceptions.value;
					 return new PartialMethodDecl(new Modifiers(m), new PrimitiveTypeAccess("void"), "", params, exceptions, new Opt(),  pattern);
			}
			case 754: // modifier = BEFORE.BEFORE
			{
					final Symbol BEFORE = _symbols[offset + 1];
					 return new Modifier("before");
			}
			case 755: // modifier = AFTER.AFTER
			{
					final Symbol AFTER = _symbols[offset + 1];
					 return new Modifier("after");
			}
			case 756: // modifier = ACTIVE.ACTIVE
			{
					final Symbol ACTIVE = _symbols[offset + 1];
					 return new Modifier("staticactive");
			}
			case 757: // method_invocation = PROCEED.PROCEED LPAREN.LPAREN argument_list_opt.l RPAREN.RPAREN
			{
					final Symbol PROCEED = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_l = _symbols[offset + 3];
					final List l = (List) _symbol_l.value;
					final Symbol RPAREN = _symbols[offset + 4];
					 return new ProceedExpr(l);
			}
			case 758: // method_invocation = SUPER_PROCEED.SUPER_PROCEED LPAREN.LPAREN argument_list_opt.l RPAREN.RPAREN
			{
					final Symbol SUPER_PROCEED = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_l = _symbols[offset + 3];
					final List l = (List) _symbol_l.value;
					final Symbol RPAREN = _symbols[offset + 4];
					 return new SuperProceedExpr(l);
			}
			case 759: // block_statement = LAYER_ACTIVATION.LAYER_ACTIVATION LPAREN.LPAREN argument_list.p RPAREN.RPAREN statement_no_short_if.s
			{
					final Symbol LAYER_ACTIVATION = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_p = _symbols[offset + 3];
					final List p = (List) _symbol_p.value;
					final Symbol RPAREN = _symbols[offset + 4];
					final Symbol _symbol_s = _symbols[offset + 5];
					final Stmt s = (Stmt) _symbol_s.value;
					 return new LayerActivation(p, new Block(new List<Stmt>().add(s)), true);
			}
			case 760: // block_statement = LAYER_DEACTIVATION.LAYER_DEACTIVATION LPAREN.LPAREN argument_list.p RPAREN.RPAREN statement_no_short_if.s
			{
					final Symbol LAYER_DEACTIVATION = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_p = _symbols[offset + 3];
					final List p = (List) _symbol_p.value;
					final Symbol RPAREN = _symbols[offset + 4];
					final Symbol _symbol_s = _symbols[offset + 5];
					final Stmt s = (Stmt) _symbol_s.value;
					 return new LayerActivation(p, new Block(new List<Stmt>().add(s)), false);
			}
			case 761: // object_access = primary_no_new_array.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 762: // object_access = name.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Access e = (Access) _symbol_e.value;
					 return e;
			}
			case 763: // statement = object_access.e LAYER_ACTIVATION.LAYER_ACTIVATION LPAREN.LPAREN argument_list.a RPAREN.RPAREN SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol LAYER_ACTIVATION = _symbols[offset + 2];
					final Symbol LPAREN = _symbols[offset + 3];
					final Symbol _symbol_a = _symbols[offset + 4];
					final List a = (List) _symbol_a.value;
					final Symbol RPAREN = _symbols[offset + 5];
					final Symbol SEMICOLON = _symbols[offset + 6];
					 return new ObjectSpecificLayerActivation(e, a, true);
			}
			case 764: // statement = object_access.e LAYER_DEACTIVATION.LAYER_DEACTIVATION LPAREN.LPAREN argument_list.a RPAREN.RPAREN SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol LAYER_DEACTIVATION = _symbols[offset + 2];
					final Symbol LPAREN = _symbols[offset + 3];
					final Symbol _symbol_a = _symbols[offset + 4];
					final List a = (List) _symbol_a.value;
					final Symbol RPAREN = _symbols[offset + 5];
					final Symbol SEMICOLON = _symbols[offset + 6];
					 return new ObjectSpecificLayerActivation(e, a, false);
			}
			case 765: // statement = object_access.e LAYER_DEACTIVATION.LAYER_DEACTIVATION SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol LAYER_DEACTIVATION = _symbols[offset + 2];
					final Symbol SEMICOLON = _symbols[offset + 3];
					 return new ObjectSpecificLayerActivation(e, new List(), false);
			}
			case 766: // type_declaration = context_declaration.c
			{
					final Symbol _symbol_c = _symbols[offset + 1];
					final ContextDecl c = (ContextDecl) _symbol_c.value;
					 return c;
			}
			case 767: // context_declaration = CONTEXT.CONTEXT IDENTIFIER.IDENTIFIER LBRACE.LBRACE addidional_context_body_block.additional_body RBRACE.RBRACE
			{
					final Symbol CONTEXT = _symbols[offset + 1];
					final Symbol IDENTIFIER = _symbols[offset + 2];
					final Symbol LBRACE = _symbols[offset + 3];
					final Symbol _symbol_additional_body = _symbols[offset + 4];
					final ContextBodyBlock additional_body = (ContextBodyBlock) _symbol_additional_body.value;
					final Symbol RBRACE = _symbols[offset + 5];
					 return new ContextDecl(new Modifiers(new List()), new Opt(), new List(), additional_body.getBodyElelemtListNoTransform(), IDENTIFIER, additional_body.getConstraintListNoTransform());
			}
			case 768: // context_declaration = modifiers.m CONTEXT.CONTEXT IDENTIFIER.IDENTIFIER LBRACE.LBRACE addidional_context_body_block.additional_body RBRACE.RBRACE
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final List m = (List) _symbol_m.value;
					final Symbol CONTEXT = _symbols[offset + 2];
					final Symbol IDENTIFIER = _symbols[offset + 3];
					final Symbol LBRACE = _symbols[offset + 4];
					final Symbol _symbol_additional_body = _symbols[offset + 5];
					final ContextBodyBlock additional_body = (ContextBodyBlock) _symbol_additional_body.value;
					final Symbol RBRACE = _symbols[offset + 6];
					 return new ContextDecl(new Modifiers(m), new Opt(), new List(), additional_body.getBodyElelemtListNoTransform(), IDENTIFIER, additional_body.getConstraintListNoTransform());
			}
			case 769: // addidional_context_body_block = context_constraint.last_constraint
			{
					final Symbol _symbol_last_constraint = _symbols[offset + 1];
					final ContextConstraint last_constraint = (ContextConstraint) _symbol_last_constraint.value;
					 return new ContextBodyBlock(new List(), new List().add(last_constraint), new List());
			}
			case 770: // addidional_context_body_block = class_body_declaration.last_bodydecl
			{
					final Symbol _symbol_last_bodydecl = _symbols[offset + 1];
					final BodyDecl last_bodydecl = (BodyDecl) _symbol_last_bodydecl.value;
					 return new ContextBodyBlock(new List(), new List(), new List().add(last_bodydecl));
			}
			case 771: // addidional_context_body_block = context_constraint.next_constraint addidional_context_body_block.additional_body
			{
					final Symbol _symbol_next_constraint = _symbols[offset + 1];
					final ContextConstraint next_constraint = (ContextConstraint) _symbol_next_constraint.value;
					final Symbol _symbol_additional_body = _symbols[offset + 2];
					final ContextBodyBlock additional_body = (ContextBodyBlock) _symbol_additional_body.value;
					 additional_body.getConstraintListNoTransform().add(next_constraint); return additional_body;
			}
			case 772: // addidional_context_body_block = class_body_declaration.next_bodydecl addidional_context_body_block.additional_body
			{
					final Symbol _symbol_next_bodydecl = _symbols[offset + 1];
					final BodyDecl next_bodydecl = (BodyDecl) _symbol_next_bodydecl.value;
					final Symbol _symbol_additional_body = _symbols[offset + 2];
					final ContextBodyBlock additional_body = (ContextBodyBlock) _symbol_additional_body.value;
					 additional_body.getBodyElelemtListNoTransform().add(next_bodydecl); return additional_body;
			}
			case 773: // context_constraint = pointcut_expr.p dla_block.s
			{
					final Symbol _symbol_p = _symbols[offset + 1];
					final PointcutExpr p = (PointcutExpr) _symbol_p.value;
					final Symbol _symbol_s = _symbols[offset + 2];
					final LayerActivationBlock s = (LayerActivationBlock) _symbol_s.value;
					 return new ContextConstraint(p, s);
			}
			case 774: // dla_block = COLON.COLON dla_composition_statements.s SEMICOLON.SEMICOLON
			{
					final Symbol COLON = _symbols[offset + 1];
					final Symbol _symbol_s = _symbols[offset + 2];
					final List s = (List) _symbol_s.value;
					final Symbol SEMICOLON = _symbols[offset + 3];
					 return new LayerActivationBlock(new List(), s);
			}
			case 775: // dla_composition_statements = dla_composition_statement.s
			{
					final Symbol _symbol_s = _symbols[offset + 1];
					final DLALayerActivation s = (DLALayerActivation) _symbol_s.value;
					 return new List().add(s);
			}
			case 776: // dla_composition_statements = dla_composition_statements.l COMMA.COMMA dla_composition_statement.s
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol COMMA = _symbols[offset + 2];
					final Symbol _symbol_s = _symbols[offset + 3];
					final DLALayerActivation s = (DLALayerActivation) _symbol_s.value;
					 return l.add(s);
			}
			case 777: // dla_composition_statement = LAYER_ACTIVATION.LAYER_ACTIVATION LPAREN.LPAREN argument_list.a RPAREN.RPAREN
			{
					final Symbol LAYER_ACTIVATION = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_a = _symbols[offset + 3];
					final List a = (List) _symbol_a.value;
					final Symbol RPAREN = _symbols[offset + 4];
					 return new DLALayerActivation(a, true);
			}
			case 778: // dla_composition_statement = LAYER_DEACTIVATION.LAYER_DEACTIVATION LPAREN.LPAREN argument_list.a RPAREN.RPAREN
			{
					final Symbol LAYER_DEACTIVATION = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_a = _symbols[offset + 3];
					final List a = (List) _symbol_a.value;
					final Symbol RPAREN = _symbols[offset + 4];
					 return new DLALayerActivation(a, false);
			}
			case 779: // if_then_statement = UNLESS.UNLESS LPAREN.LPAREN expression.e RPAREN.RPAREN statement.s
			{
					final Symbol UNLESS = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_e = _symbols[offset + 3];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol RPAREN = _symbols[offset + 4];
					final Symbol _symbol_s = _symbols[offset + 5];
					final Stmt s = (Stmt) _symbol_s.value;
					 return new IfStmt(new LogNotExpr(e), s, new Opt());
			}
			case 780: // if_then_else_statement = UNLESS.UNLESS LPAREN.LPAREN expression.e RPAREN.RPAREN statement_no_short_if.t ELSE.ELSE statement.els
			{
					final Symbol UNLESS = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_e = _symbols[offset + 3];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol RPAREN = _symbols[offset + 4];
					final Symbol _symbol_t = _symbols[offset + 5];
					final Stmt t = (Stmt) _symbol_t.value;
					final Symbol ELSE = _symbols[offset + 6];
					final Symbol _symbol_els = _symbols[offset + 7];
					final Stmt els = (Stmt) _symbol_els.value;
					 return new IfStmt(new LogNotExpr(e), t, new Opt(els));
			}
			case 781: // if_then_else_statement_no_short_if = UNLESS.UNLESS LPAREN.LPAREN expression.e RPAREN.RPAREN statement_no_short_if.t ELSE.ELSE statement_no_short_if.els
			{
					final Symbol UNLESS = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_e = _symbols[offset + 3];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol RPAREN = _symbols[offset + 4];
					final Symbol _symbol_t = _symbols[offset + 5];
					final Stmt t = (Stmt) _symbol_t.value;
					final Symbol ELSE = _symbols[offset + 6];
					final Symbol _symbol_els = _symbols[offset + 7];
					final Stmt els = (Stmt) _symbol_els.value;
					 return new IfStmt(new LogNotExpr(e), t, new Opt(els));
			}
			case 782: // statement = statement_expression.s UNLESS.UNLESS expression.e SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_s = _symbols[offset + 1];
					final ExprStmt s = (ExprStmt) _symbol_s.value;
					final Symbol UNLESS = _symbols[offset + 2];
					final Symbol _symbol_e = _symbols[offset + 3];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol SEMICOLON = _symbols[offset + 4];
					 return new IfStmt(new LogNotExpr(e), s, new Opt());
			}
			case 783: // statement = statement_expression.s IF.IF expression.e SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_s = _symbols[offset + 1];
					final ExprStmt s = (ExprStmt) _symbol_s.value;
					final Symbol IF = _symbols[offset + 2];
					final Symbol _symbol_e = _symbols[offset + 3];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol SEMICOLON = _symbols[offset + 4];
					 return new IfStmt(e, s, new Opt());
			}
			case 784: // primary_no_new_array = THIS_LAYER.THIS_LAYER
			{
					final Symbol THIS_LAYER = _symbols[offset + 1];
					 return new ThisLayerAccess("thislayer");
			}
			case 785: // annotation_type_element_declarations_opt = 
			{
					 return new List();
			}
			case 786: // annotation_type_element_declarations_opt = annotation_type_element_declarations.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final List n = (List) _symbol_n.value;
					 return n;
			}
			case 787: // default_value_opt = 
			{
					 return new Opt();
			}
			case 788: // default_value_opt = default_value.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final ElementValue n = (ElementValue) _symbol_n.value;
					 return new Opt(n);
			}
			case 789: // block_statements_opt = 
			{
					 return new List();
			}
			case 790: // block_statements_opt = block_statements.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final List n = (List) _symbol_n.value;
					 return n;
			}
			case 791: // expression_opt = 
			{
					 return new Opt();
			}
			case 792: // expression_opt = expression.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Expr n = (Expr) _symbol_n.value;
					 return new Opt(n);
			}
			case 793: // interface_member_declarations_opt = 
			{
					 return new List();
			}
			case 794: // interface_member_declarations_opt = interface_member_declarations.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final List n = (List) _symbol_n.value;
					 return n;
			}
			case 795: // argument_list_opt = 
			{
					 return new List();
			}
			case 796: // argument_list_opt = argument_list.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final List n = (List) _symbol_n.value;
					 return n;
			}
			case 797: // subclass_body_opt = 
			{
					 return new Opt();
			}
			case 798: // subclass_body_opt = subclass_body.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Opt n = (Opt) _symbol_n.value;
					 return n;
			}
			case 799: // type_id_star_list_opt = 
			{
					 return new List();
			}
			case 800: // type_id_star_list_opt = type_id_star_list.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final List n = (List) _symbol_n.value;
					 return n;
			}
			case 801: // dims_opt = 
			{
					 return new List();
			}
			case 802: // dims_opt = dims.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final List n = (List) _symbol_n.value;
					 return n;
			}
			case 803: // class_body_declarations_opt = 
			{
					 return new List();
			}
			case 804: // class_body_declarations_opt = class_body_declarations.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final List n = (List) _symbol_n.value;
					 return n;
			}
			case 805: // formal_pattern_list_opt = 
			{
					 return new List();
			}
			case 806: // formal_pattern_list_opt = formal_pattern_list.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final List n = (List) _symbol_n.value;
					 return n;
			}
			case 807: // element_value_pairs_opt = 
			{
					 return new List();
			}
			case 808: // element_value_pairs_opt = element_value_pairs.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final List n = (List) _symbol_n.value;
					 return n;
			}
			case 809: // layer_body_declarations_opt = 
			{
					 return new List();
			}
			case 810: // layer_body_declarations_opt = layer_body_declarations.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final List n = (List) _symbol_n.value;
					 return n;
			}
			case 811: // throws_opt = 
			{
					 return new List();
			}
			case 812: // throws_opt = throws.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final List n = (List) _symbol_n.value;
					 return n;
			}
			case 813: // for_init_opt = 
			{
					 return new List();
			}
			case 814: // for_init_opt = for_init.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final List n = (List) _symbol_n.value;
					 return n;
			}
			case 815: // formal_parameter_list_opt = 
			{
					 return new List();
			}
			case 816: // formal_parameter_list_opt = formal_parameter_list.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final List n = (List) _symbol_n.value;
					 return n;
			}
			case 817: // for_update_opt = 
			{
					 return new List();
			}
			case 818: // for_update_opt = for_update.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final List n = (List) _symbol_n.value;
					 return n;
			}
			case 352: // annotation_type_element_declaration = constant_declaration.constant_declaration
			case 359: // modifier = annotation.annotation
			case 360: // annotation = normal_annotation.normal_annotation
			case 361: // annotation = marker_annotation.marker_annotation
			case 362: // annotation = single_element_annotation.single_element_annotation
			case 615: // expression_nn = assignment_expression_nn.assignment_expression_nn
			{
				return _symbols[offset + 1];
			}
			default:
				throw new IllegalArgumentException("unknown production #" + rule_num);
		}
	}
}
