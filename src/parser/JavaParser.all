%header {:
 package parser;
 import AST.*;
:};
%embed {:
  class Events extends Parser.Events {
    public void scannerError(Scanner.Exception e) {
      errors.add(new Problem(null, e.getMessage(), e.line, e.column, Problem.Severity.ERROR, Problem.Kind.LEXICAL));
    }
    public void syntaxError(Symbol token) {
      int line = token.getLine(token.getStart());
      int column = token.getColumn(token.getStart());
      int endLine = token.getLine(token.getEnd());
      int endColumn = token.getColumn(token.getEnd());
      String value = token.value != null ? token.value.toString() : Terminals.NAMES[token.getId()];
      errors.add(new Problem(null, "unexpected token \"" + value + "\"", line, column, endLine, endColumn, Problem.Severity.ERROR, Problem.Kind.SYNTACTIC));
    }
    public void unexpectedTokenRemoved(Symbol token) {
    }
    public void missingTokenInserted(Symbol token) {
    }
    public void misspelledTokenReplaced(Symbol token) {
    }
    public void errorPhraseRemoved(Symbol error) {
    }
  }

        {
            report = new Events(); // Use error handler in parser
        }

   public CompilationUnit parse(java.io.InputStream is, String fileName) throws java.io.IOException, beaver.Parser.Exception {
     CompilationUnit cu;
     errors = new ArrayList();
     try {
       scanner.JavaScanner scanner = new scanner.JavaScanner(new scanner.Unicode(is));
       cu = (CompilationUnit)parse(scanner);
     } catch(Parser.Exception e) {
       // build empty compilation unit for failed error recovery
       cu = new CompilationUnit();
     } catch(Error e) {
       cu = new CompilationUnit();
       errors.add(new Problem(null, e.getMessage(), 0, 0, Problem.Severity.ERROR, Problem.Kind.LEXICAL));
     }
     for(java.util.Iterator iter = errors.iterator(); iter.hasNext(); ) {
       Problem p = (Problem)iter.next();
       p.setFileName(fileName);
       cu.addParseError(p);
     }
     return cu;
   }
   protected java.util.Collection errors = new ArrayList();
:};

CompilationUnit goal =
    compilation_unit.cu      {: return cu; :}
  ;
      
Expr literal =
    INTEGER_LITERAL.i        {: return new IntegerLiteral(i); :}
  | LONG_LITERAL.l           {: return new LongLiteral(l); :}
  | FLOATING_POINT_LITERAL.f {: return new FloatingPointLiteral(f); :}
  | DOUBLE_LITERAL.d         {: return new DoubleLiteral(d); :}
  | BOOLEAN_LITERAL.b        {: return new BooleanLiteral(b); :}
  | CHARACTER_LITERAL.c      {: return new CharacterLiteral(c); :}
  | STRING_LITERAL.s         {: return new StringLiteral(s); :}
  | NULL_LITERAL             {: return new NullLiteral("null"); :}
  ;
Access type =
    primitive_type.t         {: return t; :}
  | reference_type.t         {: return t; :}
  ;
Access primitive_type =
    numeric_type.t           {: return t; :}
  | BOOLEAN                  {: return new PrimitiveTypeAccess("boolean"); :}
  ;
Access numeric_type =
    integral_type.t          {: return t; :}
  | floating_point_type.t    {: return t; :}
  ;
Access integral_type =
    BYTE                     {: return new PrimitiveTypeAccess("byte"); :}
  | SHORT                    {: return new PrimitiveTypeAccess("short"); :}
  | INT                      {: return new PrimitiveTypeAccess("int"); :}
  | LONG                     {: return new PrimitiveTypeAccess("long"); :}
  | CHAR                     {: return new PrimitiveTypeAccess("char"); :}
  ;
Access floating_point_type =
    FLOAT                    {: return new PrimitiveTypeAccess("float"); :}
  | DOUBLE                   {: return new PrimitiveTypeAccess("double"); :}
  ;
Access reference_type =
    class_or_interface_type.t {: return t; :}
  | array_type.t              {: return t; :}
  ;
Access class_or_interface_type =
    name.n                    {: return n; :}
  ;
Access class_type =
    class_or_interface_type.n {: return n; :}
  ;
Access interface_type =
    class_or_interface_type.n {: return n; :}
  ;
Access array_type =
    primitive_type.t dims.d   {: return t.addArrayDims(d); :}
  | name.n dims.d             {: return n.addArrayDims(d); :}
  ;
Access name =
    simple_name.s             {: return s; :}
  | qualified_name.q          {: return q; :}
  ;
Access simple_name =
    IDENTIFIER              {: return new ParseName(IDENTIFIER); :}
  ;
Access qualified_name =
    name.n DOT simple_name.i   {: return n.qualifiesAccess(i); :}
  ;
CompilationUnit compilation_unit =
    package_declaration.p import_declarations.i? type_declarations.t? {: return new CompilationUnit(p.getID(), i, t); :}
  |                       import_declarations.i? type_declarations.t? {: return new CompilationUnit("", i, t); :}
  ;
List import_declarations =
    import_declaration.i                       {: return new List().add(i); :}
  | import_declarations.l import_declaration.i {: return l.add(i); :}
  ;
List type_declarations =
    type_declaration.t                         {: return !(t instanceof EmptyType) ? new List().add(t) : new List() ; :}
  | type_declarations.l type_declaration.t     {: return !(t instanceof EmptyType) ? l.add(t) : l; :}
  ;
IdUse package_declaration =
    PACKAGE name_decl.n SEMICOLON              {: return n; :}
  ;
IdUse name_decl =
    simple_name_decl.s        {: return s; :}
  | qualified_name_decl.q     {: return q; :}
  ;
IdUse simple_name_decl =
    IDENTIFIER              {: return new IdUse(IDENTIFIER); :}
  ;
IdUse qualified_name_decl =
    name_decl.n DOT IDENTIFIER.i {: return new IdUse(n.getID() + "." + i); :}
  ;
ImportDecl import_declaration =
    single_type_import_declaration.s           {: return s; :}
  | type_import_on_demand_declaration.t        {: return t; :}
  ;
ImportDecl single_type_import_declaration =
    IMPORT name.n SEMICOLON                    {: return new SingleTypeImportDecl(n); :}
  ;
ImportDecl type_import_on_demand_declaration =
    IMPORT name.n DOT MULT SEMICOLON           {: return new TypeImportOnDemandDecl(n); :}
  ;
TypeDecl type_declaration =
    class_declaration.c                        {: return c; :}
  | interface_declaration.i                    {: return i; :}
  | SEMICOLON                                  {: return new EmptyType(new Modifiers(), "EmptyType", new Opt(), new List()); :}
  ;
List modifiers =
    modifier.m                                 {: return new List().add(m); :}
  | modifiers.l modifier.m                     {: return l.add(m); :}
  ;
Modifier modifier =
    PUBLIC                                     {: return new Modifier("public"); :}
  | PROTECTED                                  {: return new Modifier("protected"); :}
  | PRIVATE                                    {: return new Modifier("private"); :}
  | STATIC                                     {: return new Modifier("static"); :}
  | ABSTRACT                                   {: return new Modifier("abstract"); :}
  | FINAL                                      {: return new Modifier("final"); :}
  | NATIVE                                     {: return new Modifier("native"); :}
  | SYNCHRONIZED                               {: return new Modifier("synchronized"); :}
  | TRANSIENT                                  {: return new Modifier("transient"); :}
  | VOLATILE                                   {: return new Modifier("volatile"); :}
  | STRICTFP                                   {: return new Modifier("strictfp"); :}
  ;
ClassDecl class_declaration =
    modifiers.m? CLASS IDENTIFIER super.s? interfaces.i? class_body.b 
                                               {: return new ClassDecl(new Modifiers(m), IDENTIFIER, s, i, b); :}
  ;
Opt super =
    EXTENDS class_type.c                       {: return new Opt(c); :}
  ;
List interfaces =
    IMPLEMENTS interface_type_list.i           {: return i; :}
  ;
List interface_type_list =
    interface_type.i                              {: return new List().add(i); :}
  | interface_type_list.l COMMA interface_type.i  {: return l.add(i); :}
  ;
List class_body =
    LBRACE class_body_declarations.c? RBRACE    {: return c; :}
  ;
List class_body_declarations =
    class_body_declaration.c                           {: return new List().add(c); :}
  | class_body_declarations.l class_body_declaration.c {: return l.add(c); :}
  ;
BodyDecl class_body_declaration =
    class_member_declaration.c                 {: return c; :}
  | instance_initializer.i                     {: return i; :}
  | static_initializer.si                      {: return si; :}
  | constructor_declaration.c                  {: return c; :}
  ;
BodyDecl class_member_declaration =
    field_declaration.f                        {: return f; :}
  | method_declaration.m                       {: return m; :}
  | class_declaration.c                        {: return new MemberClassDecl(c); :}
  | interface_declaration.i                    {: return new MemberInterfaceDecl(i); :}
  | SEMICOLON                                  {: return new InstanceInitializer(new Block()); :}
  ;
BodyDecl field_declaration =
    modifiers.m? type.t variable_declarators.v SEMICOLON {: return new FieldDecl(new Modifiers(m), t, v); :}
  ;
List variable_declarators =
    variable_declarator.v                              {: return new List().add(v); :}
  | variable_declarators.l COMMA variable_declarator.v {: return l.add(v); :}
  ;
VariableDecl variable_declarator =
    variable_declarator_id.v                           {: return v; :}
  | variable_declarator_id.v EQ variable_initializer.i {: v.setInit(i); return v; :}
  ;
VariableDecl variable_declarator_id =
    IDENTIFIER dims.d?                       {: return new VariableDecl(IDENTIFIER, d, new Opt()); :}
  ;
Expr variable_initializer =
    expression.e                               {: return e; :}
  | array_initializer.a                        {: return a; :}
  ;
MethodDecl method_declaration =
    method_header.m method_body.b              {: m.setBlockOpt(b); return m; :}
  ;
      
MethodDecl method_header =
    modifiers.m? type.t IDENTIFIER LPAREN formal_parameter_list.l? RPAREN dims.d? throws.tl?
    {: return new MethodDecl(new Modifiers(m), t.addArrayDims(d), IDENTIFIER, l, tl, new Opt()); :}
  | modifiers.m? VOID   IDENTIFIER LPAREN formal_parameter_list.l? RPAREN throws.tl?
    {: return new MethodDecl(new Modifiers(m), new PrimitiveTypeAccess("void"), IDENTIFIER, l, tl, new Opt()); :}
  ;
                                                                
List formal_parameter_list =
    formal_parameter.f                                  {: return new List().add(f); :}
  | formal_parameter_list.l COMMA formal_parameter.f    {: return l.add(f); :}
  ;
ParameterDeclaration formal_parameter =
  modifiers.m? type.t IDENTIFIER dims.d?     {: return new ParameterDeclaration(new Modifiers(m), t.addArrayDims(d), IDENTIFIER); :}
  ;
List throws =
    THROWS class_type_list.l                   {: return l; :}
  ;
List class_type_list =
    class_type.c                               {: return new List().add(c); :}
  | class_type_list.l COMMA class_type.c       {: return l.add(c); :}
  ;
Opt method_body =
    block.b                                    {: return new Opt(b); :}
  | SEMICOLON                                  {: return new Opt(); :}
  ;
StaticInitializer static_initializer =
    STATIC block.b                             {: return new StaticInitializer(b); :}
  ;
InstanceInitializer instance_initializer =
    block.b                                    {: return new InstanceInitializer(b); :}
  ;
ConstructorDecl constructor_declaration =
    modifiers.m? IDENTIFIER LPAREN formal_parameter_list.pl? RPAREN throws.tl? constructor_body.b
    {: b.setModifiers(new Modifiers(m)); b.setID(IDENTIFIER); b.setParameterList(pl); b.setExceptionList(tl); return b; :}
 ;
ConstructorDecl constructor_body =
		LBRACE explicit_constructor_invocation.c? block_statements.l? RBRACE
    {: return new ConstructorDecl(new Modifiers(), "", new List(), new List(), c, new Block(l)); :}
	;
ExprStmt explicit_constructor_invocation =
    THIS LPAREN argument_list.l? RPAREN SEMICOLON 
    {: ConstructorAccess c = new ConstructorAccess("this", l);
       c.setStart(THIS.getStart());
       c.setEnd(RPAREN.getEnd());
       return new ExprStmt(c); :}
  | SUPER LPAREN argument_list.l? RPAREN SEMICOLON 
    {: SuperConstructorAccess c = new SuperConstructorAccess("super", l);
       c.setStart(SUPER.getStart());
       c.setEnd(RPAREN.getEnd());
       return new ExprStmt(c); :}
  | primary.p DOT SUPER LPAREN argument_list.l? RPAREN SEMICOLON
    {: SuperConstructorAccess c = new SuperConstructorAccess("super", l);
       c.setStart(SUPER.getStart());
       c.setEnd(RPAREN.getEnd());
       return new ExprStmt(p.qualifiesAccess(c)); :}
  | name.n DOT SUPER LPAREN argument_list.l? RPAREN SEMICOLON
    {: SuperConstructorAccess c = new SuperConstructorAccess("super", l);
       c.setStart(SUPER.getStart());
       c.setEnd(RPAREN.getEnd());
       return new ExprStmt(n.qualifiesAccess(c)); :}
  ;
InterfaceDecl interface_declaration =
  modifiers.m? INTERFACE IDENTIFIER extends_interfaces.i? interface_body.b {: return new InterfaceDecl(new Modifiers(m), IDENTIFIER, i, b); :}
  ;
List extends_interfaces =
    EXTENDS interface_type.i                    {: return new List().add(i); :}
  | extends_interfaces.l COMMA interface_type.i {: return l.add(i); :}
  ;
    
List interface_body =
    LBRACE interface_member_declarations.i? RBRACE  {: return i; :}
  ;   
List interface_member_declarations =
    interface_member_declaration.i                                  {: return new List().add(i); :}
  | interface_member_declarations.l interface_member_declaration.i  {: return l.add(i); :}
  ;
BodyDecl interface_member_declaration =
    constant_declaration.c                     {: return c; :}
  | abstract_method_declaration.a              {: return a; :}
  | class_declaration.c                        {: return new MemberClassDecl(c); :}
  | interface_declaration.i                    {: return new MemberInterfaceDecl(i); :}
  | SEMICOLON                                  {: return new StaticInitializer(new Block()); :}
  ;
BodyDecl constant_declaration =
    field_declaration.f                        {: return f; :}
  ;
BodyDecl abstract_method_declaration =
    method_header.m SEMICOLON                  {: return m; :}
  ;
ArrayInit array_initializer =
    LBRACE variable_initializers.v? COMMA? RBRACE   {: return new ArrayInit(v); :}
  ;
List variable_initializers =
    variable_initializer.v                                {: return new List().add(v); :}
  | variable_initializers.l COMMA variable_initializer.v  {: return l.add(v); :}
  ;
Block block =
    LBRACE block_statements.l? RBRACE {: return new Block(l); :}
  ;
List block_statements =
    block_statement.b                     {: return new List().add(b); :}
  | block_statements.l block_statement.b  {: return l.add(b); :}
  ;
Stmt block_statement =
    local_variable_declaration_statement.l  {: return l; :}
  | class_declaration.c                     {: return new LocalClassDeclStmt(c); :}
  | statement.s                             {: return s; :}
  ;
VarDeclStmt local_variable_declaration_statement =
    local_variable_declaration.l SEMICOLON  {: return l; :}
  ;
VarDeclStmt local_variable_declaration =
  modifiers.m? type.t variable_declarators.l {: return new VarDeclStmt(new Modifiers(m), t, l); :}
  ;
Stmt statement =
    statement_without_trailing_substatement.s  {: return s; :}
  | labeled_statement.l                        {: return l; :}
  | if_then_statement.i                        {: return i; :}
  | if_then_else_statement.i                   {: return i; :}
  | while_statement.w                          {: return w; :}
  | for_statement.f                            {: return f; :}
  ;
Stmt statement_without_trailing_substatement =
    block.b                                    {: return b; :}
  | empty_statement.e                          {: return e; :}
  | expression_statement.e                     {: return e; :}
  | switch_statement.s                         {: return s; :}
  | do_statement.d                             {: return d; :}
  | break_statement.b                          {: return b; :}
  | continue_statement.c                       {: return c; :}
  | return_statement.r                         {: return r; :}
  | synchronized_statement.s                   {: return s; :}
  | throw_statement.t                          {: return t; :}
  | try_statement.t                            {: return t; :}
  | assert_statement.a                         {: return a; :}
  ;
Stmt statement_no_short_if =
    statement_without_trailing_substatement.s  {: return s; :}
  | labeled_statement_no_short_if.l            {: return l; :}
  | if_then_else_statement_no_short_if.i       {: return i; :}
  | while_statement_no_short_if.w              {: return w; :}
  | for_statement_no_short_if.f                {: return f; :}
  ;
IfStmt if_then_statement =
    IF LPAREN expression.e RPAREN statement.s  {: return new IfStmt(e, s, new Opt()); :}
  ;
IfStmt if_then_else_statement =
    IF LPAREN expression.e RPAREN statement_no_short_if.t ELSE statement.els {: return new IfStmt(e, t, new Opt(els)); :}
  ;
IfStmt if_then_else_statement_no_short_if =
    IF LPAREN expression.e RPAREN statement_no_short_if.t ELSE statement_no_short_if.els {: return new IfStmt(e, t, new Opt(els)); :}
  ;
EmptyStmt empty_statement =
    SEMICOLON                                  {: return new EmptyStmt(); :}
  ;
LabeledStmt labeled_statement =
    IDENTIFIER.id COLON statement.s            {: return new LabeledStmt(id, s); :}
  ;
LabeledStmt labeled_statement_no_short_if =
    IDENTIFIER.id COLON statement_no_short_if.s {: return new LabeledStmt(id, s); :}
  ;
ExprStmt expression_statement =
    statement_expression.e SEMICOLON           {: return e; :}
  ;
ExprStmt statement_expression =
    assignment.a                               {: return new ExprStmt(a); :}
  | preincrement_expression.e                  {: return new ExprStmt(e); :}
  | predecrement_expression.e                  {: return new ExprStmt(e); :}
  | postincrement_expression.e                 {: return new ExprStmt(e); :}
  | postdecrement_expression.e                 {: return new ExprStmt(e); :}
  | method_invocation.i                        {: return new ExprStmt(i); :}
  | class_instance_creation_expression.e       {: return new ExprStmt(e); :}
  ;
SwitchStmt switch_statement =
    SWITCH LPAREN expression.e RPAREN switch_block.l {: return new SwitchStmt(e, l); :}
  ;
Block switch_block =
    LBRACE switch_block_statement_groups.l switch_labels.s RBRACE 
                        {: for(int ii = 0; ii < s.getNumChildNoTransform(); ii++) l.add(s.getChildNoTransform(ii)); return new Block(l); :}
  | LBRACE switch_block_statement_groups.l RBRACE   {: return new Block(l); :}
  | LBRACE switch_labels.l RBRACE              {: return new Block(l); :}
  | LBRACE RBRACE                              {: return new Block(new List()); :}
  ;
List switch_block_statement_groups =
    switch_block_statement_group.g             {: return g; :}
  | switch_block_statement_groups.l switch_block_statement_group.g 
      {: for(int ii = 0; ii < g.getNumChildNoTransform(); ii++)
           l.add(g.getChildNoTransform(ii));
         return l; :}
  ;
List switch_block_statement_group =
    switch_labels.l block_statements.bl 
    {:  for(int ii = 0; ii < bl.getNumChildNoTransform(); ii++)
          l.add(bl.getChildNoTransform(ii));
          return l; :}
  ;
List switch_labels =
    switch_label.s                             {: return new List().add(s); :}
  | switch_labels.l switch_label.s             {: return l.add(s); :}
  ;
Case switch_label =
    CASE constant_expression.e COLON           {: return new ConstCase(e); :}
  | DEFAULT COLON                              {: return new DefaultCase(); :}
  ;
WhileStmt while_statement =
    WHILE LPAREN expression.e RPAREN statement.s {: return new WhileStmt(e, s); :}
  ;
WhileStmt while_statement_no_short_if =
    WHILE LPAREN expression.e RPAREN statement_no_short_if.s {: return new WhileStmt(e, s); :}
  ;
DoStmt do_statement =
    DO statement.s WHILE LPAREN expression.e RPAREN SEMICOLON {: return new DoStmt(s, e); :}
  ;
ForStmt for_statement =
    FOR LPAREN for_init.i? SEMICOLON expression.e? SEMICOLON for_update.u? RPAREN statement.s {: return new ForStmt(i, e, u, s); :}
  ;
ForStmt for_statement_no_short_if =
    FOR LPAREN for_init.i? SEMICOLON expression.e? SEMICOLON for_update.u? RPAREN statement_no_short_if.s {: return new ForStmt(i, e, u, s); :}
  ;
List for_init =
    statement_expression_list.l        {: return l; :}
  | local_variable_declaration.d       {: return new List().add(d); :};
List for_update =
    statement_expression_list.l        {: return l; :}
  ;
List statement_expression_list =
    statement_expression.e                                   {: return new List().add(e); :}
  | statement_expression_list.l COMMA statement_expression.e {: return l.add(e); :}
  ;
BreakStmt break_statement =
    BREAK IDENTIFIER.id SEMICOLON              {: return new BreakStmt(id); :}
  | BREAK               SEMICOLON              {: return new BreakStmt(""); :}
  ; 
ContinueStmt continue_statement =
    CONTINUE IDENTIFIER.id SEMICOLON           {: return new ContinueStmt(id); :}
  | CONTINUE               SEMICOLON           {: return new ContinueStmt(""); :}
  ;
ReturnStmt return_statement =
    RETURN expression.e? SEMICOLON              {: return new ReturnStmt(e); :}
  ;
ThrowStmt throw_statement =
    THROW expression.e SEMICOLON               {: return new ThrowStmt(e); :}
  ;
SynchronizedStmt synchronized_statement =
    SYNCHRONIZED LPAREN expression.e RPAREN block.b {: return new SynchronizedStmt(e, b); :}
  ;
TryStmt try_statement =
    TRY block.b catches.c                        {: return new TryStmt(b, c, new Opt()); :}
  | TRY block.b            finally.f             {: return new TryStmt(b, new List(), new Opt(f)); :}
  | TRY block.b catches.c  finally.f             {: return new TryStmt(b, c, new Opt(f)); :}
  ;
List catches =
    catch_clause.c                             {: return new List().add(c); :}
  | catches.l catch_clause.c                   {: return l.add(c); :}
  ;
CatchClause catch_clause =
    CATCH LPAREN formal_parameter.p RPAREN block.b {: return new CatchClause(p, b); :}
  ;
Block finally =
    FINALLY block.b {: return b; :}
  ;
AssertStmt assert_statement =
    ASSERT expression.e                    SEMICOLON {: return new AssertStmt(e, new Opt()); :}
  | ASSERT expression.e COLON expression.s SEMICOLON {: return new AssertStmt(e, new Opt(s)); :}
  ;
Expr primary =
    primary_no_new_array.p                     {: return p; :}
  | array_creation_init.a                      {: return a; :}
  | array_creation_uninit.a                    {: return a; :}
  ;

ClassAccess class_literal =
  CLASS {: return new ClassAccess(); :}
  ;

Expr primary_no_new_array =
    literal.l                                  {: return l; :}
  | primitive_type.n dims.d? DOT class_literal.c       {: return n.addArrayDims(d).qualifiesAccess(c); :}
  | name.n dims.d? DOT class_literal.c                 {: return n.addArrayDims(d).qualifiesAccess(c); :}
  | VOID DOT class_literal.c                   {: PrimitiveTypeAccess v = new PrimitiveTypeAccess("void");
                                                  v.setStart(VOID.getStart());
                                                  v.setEnd(VOID.getEnd());
                                                  return v.qualifiesAccess(c); :}
  | THIS                                       {: return new ThisAccess("this"); :}
  | name.n DOT THIS                            {: ThisAccess t = new ThisAccess("this");
                                                  t.setStart(THIS.getStart()); t.setEnd(THIS.getEnd());
                                                  return n.qualifiesAccess(t); :}
  | LPAREN expression.e RPAREN                 {: return new ParExpr(e); :}
  | LPAREN name.n RPAREN                       {: return new ParExpr(n); :}
  | class_instance_creation_expression.c       {: return c; :}
  | field_access.f                             {: return f; :}
  | method_invocation.m                        {: return m; :}
  | array_access.a                             {: return a; :}
  ;
Expr class_instance_creation_expression =
    NEW class_or_interface_type.t LPAREN argument_list.l? RPAREN 
    {: return new ClassInstanceExpr(t, l, new Opt()); :}
  | primary.n DOT NEW simple_name.id LPAREN argument_list.l? RPAREN
    {: ClassInstanceExpr e = new ClassInstanceExpr(id, l, new Opt());
       e.setStart(NEW.getStart());
       e.setEnd(RPAREN.getEnd());
       return n.qualifiesAccess(e); :}
  | name.n DOT NEW simple_name.id LPAREN argument_list.l? RPAREN
    {: ClassInstanceExpr e = new ClassInstanceExpr(id, l, new Opt());
       e.setStart(NEW.getStart());
       e.setEnd(RPAREN.getEnd());
       return n.qualifiesAccess(e); :}
  | NEW class_or_interface_type.t LPAREN argument_list.l? RPAREN subclass_body.b 
    {: return new ClassInstanceExpr(t, l, b); :}
  | primary.n DOT NEW simple_name.id LPAREN argument_list.l? RPAREN subclass_body.b
    {: ClassInstanceExpr e = new ClassInstanceExpr(id, l, b);
       e.setStart(NEW.getStart());
       e.setEnd(b.getEnd());
       return n.qualifiesAccess(e); :}
  | name.n DOT NEW simple_name.id LPAREN argument_list.l? RPAREN subclass_body.b
    {: ClassInstanceExpr e = new ClassInstanceExpr(id, l, b);
       e.setStart(NEW.getStart());
       e.setEnd(b.getEnd());
       return n.qualifiesAccess(e); :}
  ;
Opt subclass_body =
    class_body.b                               {: return new Opt(new AnonymousDecl(new Modifiers(), "Anonymous", b)); :}
  ;

List argument_list =
    expression.e                               {: return new List().add(e); :}
  | argument_list.l COMMA expression.e         {: return l.add(e); :}
  ;

Expr array_creation_uninit =
    NEW primitive_type.t dim_exprs.d           {: return new ArrayCreationExpr(t.addArrayDims(d), new Opt()); :}
  | NEW primitive_type.t dim_exprs.d dims.e    {: return new ArrayCreationExpr(t.addArrayDims(d).addArrayDims(e), new Opt()); :}
  | NEW class_or_interface_type.t dim_exprs.d  {: return new ArrayCreationExpr(t.addArrayDims(d), new Opt()); :}
  | NEW class_or_interface_type.t dim_exprs.d dims.e {: return new ArrayCreationExpr(t.addArrayDims(d).addArrayDims(e), new Opt()); :}
  ;
Expr array_creation_init =
    NEW primitive_type.t dims.d array_initializer.i           {: return new ArrayCreationExpr(t.addArrayDims(d), new Opt(i)); :}
  | NEW class_or_interface_type.t dims.d array_initializer.i  {: return new ArrayCreationExpr(t.addArrayDims(d), new Opt(i)); :}
  ;
List dim_exprs =
    dim_expr.e                                 {: return new List().add(e); :}
  | dim_exprs.l dim_expr.e                     {: return l.add(e); :}
  ;
Dims dim_expr =
    LBRACK expression.e RBRACK                 {: return new Dims(new Opt(e)); :}
  ;
List dims =
    LBRACK RBRACK                              {: return new List().add(new Dims(new Opt())); :}
  | dims.l LBRACK RBRACK                       {: return l.add(new Dims(new Opt())); :}
  ;

Access field_access =
    primary.p DOT simple_name.id                {: return p.qualifiesAccess(id); :}
  | SUPER DOT simple_name.id 
    {: SuperAccess s = new SuperAccess("super");
       s.setStart(SUPER.getStart());
       s.setEnd(SUPER.getEnd());
       return s.qualifiesAccess(id); :}
  | name.n DOT SUPER DOT simple_name.id
    {: SuperAccess s = new SuperAccess("super");
       s.setStart(SUPER.getStart());
       s.setEnd(SUPER.getEnd());
       return n.qualifiesAccess(s).qualifiesAccess(id); :}
  ;
Access method_invocation =
      name.n LPAREN argument_list.l? RPAREN {: 
                                                             if(n instanceof AbstractDot) {    
                                                               AbstractDot d = (AbstractDot)n; 
                                                               ParseName pn = (ParseName)d.extractLast();
                                                               MethodAccess m = new MethodAccess(pn.getID(), l);
                                                               m.setStart(n.getStart()); // add location information
                                                               m.setEnd(RPAREN.getEnd()); // add location information
                                                               d.replaceLast(m);
                                                               return d;
                                                             }
                                                             else {
                                                               ParseName pn = (ParseName)n;
                                                               return new MethodAccess(pn.getID(), l);
                                                             }
                                                               :}
   | primary.p DOT IDENTIFIER LPAREN argument_list.l? RPAREN 
     {: MethodAccess m = new MethodAccess(IDENTIFIER, l);
        m.setStart(IDENTIFIER.getStart()); // add location information
        m.setEnd(RPAREN.getEnd()); // add location information
        return p.qualifiesAccess(m); :}
   | SUPER DOT IDENTIFIER LPAREN argument_list.l? RPAREN
     {: SuperAccess s = new SuperAccess("super");
        s.setStart(SUPER.getStart());
        s.setEnd(SUPER.getEnd());
        MethodAccess m = new MethodAccess(IDENTIFIER, l);
        m.setStart(IDENTIFIER.getStart());
        m.setEnd(RPAREN.getEnd());
        return s.qualifiesAccess(m); :}
   | name.n DOT SUPER DOT IDENTIFIER LPAREN argument_list.l? RPAREN
     {: SuperAccess s = new SuperAccess("super");
        s.setStart(SUPER.getStart());
        s.setEnd(SUPER.getEnd());
        MethodAccess m = new MethodAccess(IDENTIFIER, l);
        m.setStart(IDENTIFIER.getStart());
        m.setEnd(RPAREN.getEnd());
        return n.qualifiesAccess(s).qualifiesAccess(m); :}
   ;
Access array_access =
    name.n LBRACK expression.e RBRACK                 {: ArrayAccess a = new ArrayAccess(e);
                                                         a.setStart(LBRACK.getStart());
                                                         a.setEnd(RBRACK.getEnd());
                                                         return n.qualifiesAccess(a); :}
  | primary_no_new_array.p LBRACK expression.e RBRACK {: ArrayAccess a = new ArrayAccess(e);
                                                         a.setStart(LBRACK.getStart());
                                                         a.setEnd(RBRACK.getEnd());
                                                         return p.qualifiesAccess(a); :}
/*  | array_creation_init.i LBRACK expression.e RBRACK  {: ArrayAccess a = new ArrayAccess(e);
                                                         a.setStart(LBRACK.getStart());
                                                         a.setEnd(RBRACK.getEnd());
                                                         return i.qualifiesAccess(a); :}
                                                      */
  ;
Expr postfix_expression =
    primary.p                                  {: return p; :}
  | name.n                                     {: return n; :}
  | postincrement_expression.e                 {: return e; :}
  | postdecrement_expression.e                 {: return e; :}
  ;
Expr postincrement_expression =
    postfix_expression.e PLUSPLUS              {: return new PostIncExpr(e); :}
  ;
Expr postdecrement_expression =
    postfix_expression.e MINUSMINUS            {: return new PostDecExpr(e); :}
  ;
Expr unary_expression =
    preincrement_expression.e                  {: return e; :}
  | predecrement_expression.e                  {: return e; :}
  | PLUS unary_expression.e                    {: return new PlusExpr(e); :}
  | MINUS unary_expression.e                   {: return new MinusExpr(e); :}
  | unary_expression_not_plus_minus.e          {: return e; :}
  ;
Expr preincrement_expression =
    PLUSPLUS unary_expression.e                {: return new PreIncExpr(e); :}
  ;
Expr predecrement_expression =
    MINUSMINUS unary_expression.e              {: return new PreDecExpr(e); :}
  ;
Expr unary_expression_not_plus_minus =
    postfix_expression.e                       {: return e; :}
  | COMP unary_expression.e                    {: return new BitNotExpr(e); :}
  | NOT unary_expression.e                     {: return new LogNotExpr(e); :}
  | cast_expression.e                          {: return e; :}
  ;
Expr cast_expression =
    LPAREN primitive_type.t dims.d? RPAREN unary_expression.e      {: return new CastExpr(t.addArrayDims(d), e); :}
  | LPAREN name.n dims.d? RPAREN unary_expression_not_plus_minus.e {: return new CastExpr(n.addArrayDims(d), e); :}
  ;
Expr multiplicative_expression =
    unary_expression.e                                     {: return e; :}
  | multiplicative_expression.e1 MULT unary_expression.e2  {: return new MulExpr(e1, e2); :}
  | multiplicative_expression.e1 DIV unary_expression.e2   {: return new DivExpr(e1, e2); :}
  | multiplicative_expression.e1 MOD unary_expression.e2   {: return new ModExpr(e1, e2); :}
  ;
Expr additive_expression =
    multiplicative_expression.e                                {: return e; :}
  | additive_expression.e1 PLUS multiplicative_expression.e2   {: return new AddExpr(e1, e2); :}
  | additive_expression.e1 MINUS multiplicative_expression.e2  {: return new SubExpr(e1, e2); :}
  ;
Expr shift_expression =
    additive_expression.e                               {: return e; :}
  | shift_expression.e1 LSHIFT additive_expression.e2   {: return new LShiftExpr(e1, e2); :}
  | shift_expression.e1 RSHIFT additive_expression.e2   {: return new RShiftExpr(e1, e2); :}
  | shift_expression.e1 URSHIFT additive_expression.e2  {: return new URShiftExpr(e1, e2); :}
  ;
Expr relational_expression =
    shift_expression.e                                  {: return e; :}
  | relational_expression.e1 LT shift_expression.e2     {: return new LTExpr(e1, e2); :}
  | relational_expression.e1 GT shift_expression.e2     {: return new GTExpr(e1, e2); :}
  | relational_expression.e1 LTEQ shift_expression.e2   {: return new LEExpr(e1, e2); :}
  | relational_expression.e1 GTEQ shift_expression.e2   {: return new GEExpr(e1, e2); :}
  | relational_expression.e INSTANCEOF reference_type.t {: return new InstanceOfExpr(e, t); :}
  ;
Expr equality_expression =
    relational_expression.e                               {: return e; :}
  | equality_expression.e1 EQEQ relational_expression.e2  {: return new EQExpr(e1, e2); :}
  | equality_expression.e1 NOTEQ relational_expression.e2 {: return new NEExpr(e1, e2); :}
  ;
Expr and_expression =
    equality_expression.e                               {: return e; :}
  | and_expression.e1 AND equality_expression.e2        {: return new AndBitwiseExpr(e1, e2); :}
  ;
Expr exclusive_or_expression =
    and_expression.e                                    {: return e; :}
  | exclusive_or_expression.e1 XOR and_expression.e2    {: return new XorBitwiseExpr(e1, e2); :}
  ;
Expr inclusive_or_expression =
    exclusive_or_expression.e                                {: return e; :}
  | inclusive_or_expression.e1 OR exclusive_or_expression.e2 {: return new OrBitwiseExpr(e1, e2); :}
  ;
Expr conditional_and_expression =
    inclusive_or_expression.e                                       {: return e; :}
  | conditional_and_expression.e1 ANDAND inclusive_or_expression.e2 {: return new AndLogicalExpr(e1, e2); :}
  ;
Expr conditional_or_expression =
    conditional_and_expression.e                                    {: return e; :}
  | conditional_or_expression.e1 OROR conditional_and_expression.e2 {: return new OrLogicalExpr(e1, e2); :}
  ;
Expr conditional_expression =
    conditional_or_expression.c                                                        {: return c; :}
  | conditional_or_expression.c QUESTION expression.e1 COLON conditional_expression.e2 {: return new ConditionalExpr(c, e1, e2); :}
  ;
Expr assignment_expression =
    conditional_expression.c {: return c; :}
  | assignment.a {: return a; :}
  ;
Expr assignment =
    postfix_expression.dest EQ assignment_expression.source {: return new AssignSimpleExpr(dest, source); :}
  | postfix_expression.dest MULTEQ assignment_expression.source {: return new AssignMulExpr(dest, source); :}
  | postfix_expression.dest DIVEQ assignment_expression.source {: return new AssignDivExpr(dest, source); :}
  | postfix_expression.dest MODEQ assignment_expression.source {: return new AssignModExpr(dest, source); :}
  | postfix_expression.dest PLUSEQ assignment_expression.source {: return new AssignPlusExpr(dest, source); :}
  | postfix_expression.dest MINUSEQ assignment_expression.source {: return new AssignMinusExpr(dest, source); :}
  | postfix_expression.dest LSHIFTEQ assignment_expression.source {: return new AssignLShiftExpr(dest, source); :}
  | postfix_expression.dest RSHIFTEQ assignment_expression.source {: return new AssignRShiftExpr(dest, source); :}
  | postfix_expression.dest URSHIFTEQ assignment_expression.source {: return new AssignURShiftExpr(dest, source); :}
  | postfix_expression.dest ANDEQ assignment_expression.source {: return new AssignAndExpr(dest, source); :}
  | postfix_expression.dest XOREQ assignment_expression.source {: return new AssignXorExpr(dest, source); :}
  | postfix_expression.dest OREQ assignment_expression.source {: return new AssignOrExpr(dest, source); :}
  ;
Expr expression =
    assignment_expression.a                    {: return a; :}
  ;
Expr constant_expression =
    expression.e                               {: return e; :}
  ;
BodyDecl class_body_declaration =
    error SEMICOLON {: return new InstanceInitializer(new Block()); :}
  | error LBRACE {: return new InstanceInitializer(new Block()); :}
  ;

Block block =
    error RBRACE {: return new Block(new List()); :}
  ;

Stmt statement =
    error SEMICOLON {: return new EmptyStmt(); :}
  ;
TypeDecl type_declaration =
  annotation_type_declaration.i {:  return i;  :}
  ;
  
BodyDecl interface_member_declaration =
  annotation_type_declaration.i {:  return new MemberInterfaceDecl(i);  :}
  ;

BodyDecl class_member_declaration =
  annotation_type_declaration.i {:  return new MemberInterfaceDecl(i);  :}
  ;

// a comment
AnnotationDecl annotation_type_declaration =
  modifiers.m? AT INTERFACE IDENTIFIER annotation_type_body.b 
  {:  return new AnnotationDecl(new Modifiers(m), IDENTIFIER, b); :}
  ;

List annotation_type_body =
  LBRACE annotation_type_element_declarations.i? RBRACE {: return i; :}
  ;

List annotation_type_element_declarations =
     annotation_type_element_declaration.i {:  return new List().add(i); :}
  |  annotation_type_element_declarations.l annotation_type_element_declaration.i {:  return l.add(i);  :};

BodyDecl annotation_type_element_declaration =
    modifiers.m? type.t IDENTIFIER LPAREN RPAREN default_value? SEMICOLON
    {: return new AnnotationMethodDecl(new Modifiers(m), t, IDENTIFIER, new List(), new List(), new Opt(), default_value); :}
  | constant_declaration
  | class_declaration {: return new MemberClassDecl(class_declaration); :}
  | interface_declaration {: return new MemberInterfaceDecl(interface_declaration); :}
  | enum_declaration {: return new MemberClassDecl(enum_declaration); :}
  | annotation_type_declaration {: return new MemberInterfaceDecl(annotation_type_declaration); :}
  | SEMICOLON {: return new StaticInitializer(new Block()); :}
  ;

ElementValue default_value =
  DEFAULT element_value {: return element_value; :}
  ;


Modifier modifier =
  annotation
  ;

Annotation annotation =
    normal_annotation
  | marker_annotation
  | single_element_annotation
  ;

Modifier normal_annotation =
  AT type LPAREN element_value_pairs? RPAREN {: return new Annotation("annotation", type, element_value_pairs); :}
  ;

List element_value_pairs =
    element_value_pair {: return new List().add(element_value_pair); :}
  | element_value_pairs COMMA element_value_pair {: return element_value_pairs.add(element_value_pair); :}
  ;

ElementValuePair element_value_pair =
  IDENTIFIER EQ element_value {: return new ElementValuePair(IDENTIFIER, element_value); :}
  ;

ElementValue element_value =
  conditional_expression              {: return new ElementConstantValue(conditional_expression); :}
  | annotation                        {: return new ElementAnnotationValue(annotation); :}
  | element_value_array_initializer.e {: return e; :}
  ;

ElementArrayValue element_value_array_initializer =
  LBRACE element_values? COMMA? RBRACE {: return new ElementArrayValue(element_values); :}
  ;

List element_values =
    element_value {: return new List().add(element_value); :}
  | element_values COMMA element_value {: return element_values.add(element_value); :}
  ;
  
Modifier marker_annotation =
  AT type {: return new Annotation("annotation", type, new List()); :}
  ;
  
Modifier single_element_annotation =
  AT type LPAREN element_value RPAREN {: return new Annotation("annotation", type, new List().add(new ElementValuePair("value", element_value))); :}
  ;
  

CompilationUnit compilation_unit =
  modifiers.a package_declaration.p import_declarations.i? type_declarations.t?
    {: return new AnnotatedCompilationUnit(p.getID(), i, t, new Modifiers(a)); :}
  ;
Stmt statement = 
  enhanced_for_statement.f                             {: return f; :}
  ; 

Stmt statement_no_short_if = 
	enhanced_for_statement_no_short_if.f                 {: return f; :}
	;

Stmt enhanced_for_statement =
	FOR LPAREN enhanced_for_parameter.p COLON expression.e RPAREN statement.s
	{:  return new EnhancedForStmt(p, e, s);  :}
	;

Stmt enhanced_for_statement_no_short_if =
	FOR LPAREN enhanced_for_parameter.p COLON expression.e RPAREN statement_no_short_if.s 
	{: return new EnhancedForStmt(p, e, s);  :}
	;

VariableDeclaration enhanced_for_parameter = 
  modifiers.m? type.t IDENTIFIER dims.d?     {: return new VariableDeclaration(new Modifiers(m), t.addArrayDims(d), IDENTIFIER, new Opt()); :}
  ;

TypeDecl type_declaration =
  enum_declaration.i {:  return i;  :}
  ;

BodyDecl interface_member_declaration =
  enum_declaration.i {:  return new MemberClassDecl(i);  :}
  ;

BodyDecl class_member_declaration =
  enum_declaration.i {:  return new MemberClassDecl(i);  :}
  ;

EnumDecl enum_declaration =
  modifiers.m? ENUM IDENTIFIER.id interfaces.i? enum_body.b {: return new EnumDecl(new Modifiers(m), id, i, b); :}
  ;

List enum_body =
    LBRACE RBRACE {: return new List(); :}
  | LBRACE enum_constants RBRACE {: return enum_constants; :}
  | LBRACE COMMA RBRACE {: return new List(); :}
  | LBRACE enum_constants COMMA RBRACE {: return enum_constants; :}
  | LBRACE enum_body_declarations RBRACE {: return enum_body_declarations; :}
  | LBRACE enum_constants.c enum_body_declarations.d RBRACE
    {: for(int i = 0; i < d.getNumChildNoTransform(); i++) c.add(d.getChildNoTransform(i)); return c; :}
  | LBRACE COMMA enum_body_declarations RBRACE {: return enum_body_declarations; :}
  | LBRACE enum_constants.c COMMA enum_body_declarations.d RBRACE
    {: for(int i = 0; i < d.getNumChildNoTransform(); i++) c.add(d.getChildNoTransform(i)); return c; :}
  ;

List enum_constants =
    enum_constant {: return new List().add(enum_constant); :}
  | enum_constants COMMA enum_constant {: return enum_constants.add(enum_constant); :}
  ;

BodyDecl enum_constant =
  annotations? IDENTIFIER.id arguments? class_body? 
    {: return new EnumConstant(new Modifiers(annotations), id, arguments, class_body); :}
  ;

List arguments =
  LPAREN argument_list RPAREN {: return argument_list; :}
  ;

List annotations =
    annotation             {: return new List().add(annotation); :}
  | annotations annotation {: return annotations.add(annotation); :}
  ;

List enum_body_declarations =
  SEMICOLON class_body_declarations? {: return class_body_declarations; :}
  ;
ExprStmt explicit_constructor_invocation =
		type_arguments.a THIS LPAREN argument_list.l? RPAREN SEMICOLON 
		{:  return new ExprStmt(new ParConstructorAccess("this", l, a));  :}
	|	type_arguments.a SUPER LPAREN argument_list.l? RPAREN SEMICOLON 
		{:  return new ExprStmt(new ParSuperConstructorAccess("super", l, a));  :}
	|	primary.p DOT type_arguments.a SUPER LPAREN argument_list.l? RPAREN SEMICOLON 
		{:  return new ExprStmt(p.qualifiesAccess(new ParSuperConstructorAccess("super", l, a))); :}
	|	name.n DOT type_arguments.a SUPER LPAREN argument_list.l? RPAREN SEMICOLON 
		{:  return new ExprStmt(n.qualifiesAccess(new ParSuperConstructorAccess("super", l, a))); :}
	;
	
Access method_invocation =
		primary.p DOT type_arguments.a IDENTIFIER LPAREN argument_list.l? RPAREN 
		{: return p.qualifiesAccess(new ParMethodAccess(IDENTIFIER, l, a));  :}
	|	name.n DOT type_arguments.a IDENTIFIER LPAREN argument_list.l? RPAREN 
		{: return n.qualifiesAccess(new ParMethodAccess(IDENTIFIER, l, a));  :}
	|	SUPER DOT type_arguments.a IDENTIFIER LPAREN argument_list.l? RPAREN 
		{: return new SuperAccess("super").qualifiesAccess(
		                    new ParMethodAccess(IDENTIFIER, l, a));  :}
	|	name.n DOT.d1 SUPER DOT.d2 type_arguments.a IDENTIFIER LPAREN argument_list.l? RPAREN 
		{: return n.qualifiesAccess(new SuperAccess("super")).qualifiesAccess(
                            new ParMethodAccess(IDENTIFIER, l, a));  :}
	;

MethodDecl method_header =
	  modifiers.m? LT type_parameter_list_1.l type.t IDENTIFIER LPAREN formal_parameter_list.p? RPAREN dims.d? throws.tl?
    {: return new GenericMethodDecl(new Modifiers(m), t.addArrayDims(d), IDENTIFIER, p, tl, new Opt(), l); :}
	| modifiers.m? LT type_parameter_list_1.l VOID IDENTIFIER LPAREN formal_parameter_list.p? RPAREN throws.tl?
    {: return new GenericMethodDecl(new Modifiers(m), new PrimitiveTypeAccess("void"), IDENTIFIER, p, tl, new Opt(), l); :}
  ;

ConstructorDecl constructor_declaration =
	  modifiers.m? LT type_parameter_list_1.l IDENTIFIER LPAREN formal_parameter_list.pl? RPAREN throws.tl? 
		LBRACE explicit_constructor_invocation.c? block_statements.bl? RBRACE
    {: return new GenericConstructorDecl(new Modifiers(m), IDENTIFIER, pl, tl, c, new Block(bl), l); :}
  ;
ClassDecl class_declaration =
	modifiers.m? CLASS IDENTIFIER type_parameters.p super.s? interfaces.i? class_body.b 
		{:  return new GenericClassDecl(new Modifiers(m), IDENTIFIER, s, i, b, p);  :}
	;

InterfaceDecl interface_declaration =
	modifiers.m? INTERFACE IDENTIFIER type_parameters.p extends_interfaces.i? interface_body.b 
		{:  return new GenericInterfaceDecl(new Modifiers(m), IDENTIFIER, i, b, p);  :}
	;

Access class_or_interface =
    name.n {: return n; :}
  | class_or_interface.n LT type_argument_list_1.l DOT name.end {: return new ParTypeAccess(n, l).qualifiesAccess(end); :}
  ;

Access class_or_interface_type :=
    class_or_interface.n {: return n; :}
  | class_or_interface.n LT type_argument_list_1.l {: return new ParTypeAccess(n, l); :}
	;
Access array_type =
    class_or_interface.t LT type_argument_list_1.l DOT name.n dims.d 
    {: return new ParTypeAccess(t, l).qualifiesAccess(n).addArrayDims(d); :}
	|	class_or_interface.t LT type_argument_list_1.l dims.d 
		{: return new ParTypeAccess(t, l).addArrayDims(d); :}
	;

List type_arguments =
		LT type_argument_list_1.l {:  return l;  :}
	;
      
Access wildcard =
		QUESTION                             {: return new Wildcard(); :}
	|	QUESTION EXTENDS reference_type.t    {: return new WildcardExtends(t); :}
    |	QUESTION SUPER reference_type.t    {: return new WildcardSuper(t); :}
    ;
   
Access wildcard_1 =
		QUESTION GT                          {: return new Wildcard(); :}
	|	QUESTION EXTENDS reference_type_1.t  {: return new WildcardExtends(t); :}
	|	QUESTION SUPER reference_type_1.t    {: return new WildcardSuper(t); :}
	;
	
Access wildcard_2 =
		QUESTION RSHIFT                      {: return new Wildcard(); :}
	|	QUESTION EXTENDS reference_type_2.t  {: return new WildcardExtends(t); :}
	|	QUESTION SUPER reference_type_2.t    {: return new WildcardSuper(t); :}
	;
	
Access wildcard_3 =
		QUESTION URSHIFT                     {: return new Wildcard(); :}
	|	QUESTION EXTENDS reference_type_3.t  {: return new WildcardExtends(t); :}
	|	QUESTION SUPER reference_type_3.t    {: return new WildcardSuper(t); :}
	;

Expr class_instance_creation_expression :=
    NEW class_or_interface_type.t LPAREN argument_list.l? RPAREN subclass_body.b?
    {: return new ClassInstanceExpr(t, l, b); :}
  |	NEW type_arguments.a class_or_interface_type.t LPAREN argument_list.l? RPAREN subclass_body.b?
		{:  return new ParClassInstanceExpr(t, l, b, a); :}
	|	primary.n DOT NEW simple_name.id LPAREN argument_list.l? RPAREN subclass_body.b?
    {:  ClassInstanceExpr e = new ClassInstanceExpr(id, l, b); 
        e.setStart(NEW.getStart());
        e.setEnd(RPAREN.getEnd());
        return n.qualifiesAccess(e);
    :}
	|	primary.n DOT NEW simple_name.id type_arguments.a LPAREN argument_list.l? RPAREN subclass_body.b?
    {:  ClassInstanceExpr e = new ClassInstanceExpr(new ParTypeAccess(id, a), l, b); 
        e.setStart(NEW.getStart());
        e.setEnd(RPAREN.getEnd());
        return n.qualifiesAccess(e);
    :}
	|	primary.n DOT NEW type_arguments.ca simple_name.id LPAREN argument_list.l? RPAREN subclass_body.b?
		{:  return n.qualifiesAccess(new ParClassInstanceExpr(id, l, b, ca)); :}
	|	primary.n DOT NEW type_arguments.ca simple_name.id type_arguments.ta LPAREN argument_list.l? RPAREN subclass_body.b?
		{:  return n.qualifiesAccess(new ParClassInstanceExpr(new ParTypeAccess(id, ta), l, b, ca)); :}
	|	name.n DOT NEW simple_name.id LPAREN argument_list.l? RPAREN subclass_body.b?
    {:  ClassInstanceExpr e = new ClassInstanceExpr(id, l, b); 
        e.setStart(NEW.getStart());
        e.setEnd(RPAREN.getEnd());
        return n.qualifiesAccess(e);
    :}
	|	name.n DOT NEW simple_name.id type_arguments.a LPAREN argument_list.l? RPAREN subclass_body.b?
    {:  ClassInstanceExpr e = new ClassInstanceExpr(new ParTypeAccess(id, a), l, b); 
        e.setStart(NEW.getStart());
        e.setEnd(RPAREN.getEnd());
        return n.qualifiesAccess(e);
    :}
	|	name.n DOT NEW type_arguments.ca simple_name.id LPAREN argument_list.l? RPAREN subclass_body.b?
		{:  return n.qualifiesAccess(new ParClassInstanceExpr(id, l, b, ca)); :}
	|	name.n DOT NEW type_arguments.ca simple_name.id type_arguments.ta LPAREN argument_list.l? RPAREN subclass_body.b?
		{:  return n.qualifiesAccess(new ParClassInstanceExpr(new ParTypeAccess(id, ta), l, b, ca)); :}
	;

List type_argument_list =
		type_argument.a {:  return new List().add(a);  :}
	|	type_argument_list.l COMMA type_argument.a {:  return l.add(a);  :}
	;
	
List type_argument_list_1 =
		type_argument_1.a {:  return new List().add(a);  :}
	|	type_argument_list.l COMMA type_argument_1.a {:  return l.add(a);  :}
	;
	
List type_argument_list_2 =
		type_argument_2.a {:  return new List().add(a);  :}
	|	type_argument_list.l COMMA type_argument_2.a {:  return l.add(a);  :}
	;
	
List type_argument_list_3 =
		type_argument_3.a {:  return new List().add(a);  :}
	|	type_argument_list.l COMMA type_argument_3.a {:  return l.add(a);  :}
	;
	
Access type_argument =
		reference_type.t {:  return t;  :}
	|	wildcard.w {: return w; :}
	;
	
Access type_argument_1 =
		reference_type_1.t {:  return t;  :}
	|	wildcard_1.w {: return w; :}
	;
	
Access type_argument_2 =
		reference_type_2.t {:  return t;  :}
	|	wildcard_2.w {: return w; :}
	;
	
Access type_argument_3 =
		reference_type_3.t {:  return t;  :}
	|	wildcard_3.w {: return w; :}
	;
  
Access reference_type_1 =
		reference_type.t GT {:  return t;  :}
	|	class_or_interface.t LT type_argument_list_2.l {:  return new ParTypeAccess(t, l);  :}
	;
	
Access reference_type_2 =
		reference_type.t RSHIFT {:  return t;  :}
	|	class_or_interface.t LT type_argument_list_3.l {:  return new ParTypeAccess(t, l);  :}
	;
	
Access reference_type_3 =
		reference_type.t URSHIFT {:  return t;  :}
	;
Expr cast_expression =
		LPAREN name.n LT type_argument_list_1.a dims.d? RPAREN unary_expression_not_plus_minus.e 
		{:  return new CastExpr(new ParTypeAccess(n, a).addArrayDims(d), e);  :}
	|	LPAREN name.n LT type_argument_list_1.a DOT class_or_interface_type.t dims.d? RPAREN unary_expression_not_plus_minus.e 
		{:  return new CastExpr(new ParTypeAccess(n, a).qualifiesAccess(t).addArrayDims(d), e);  :}
  ;

List type_parameters =
		LT type_parameter_list_1.l {:  return l;  :}
	;
	
List type_parameter_list =
		type_parameter_list.l COMMA type_parameter.p {:  return l.add(p);  :}
	|	type_parameter.p {:  return new List().add(p);  :}
	;
	
List type_parameter_list_1 =
		type_parameter_1.p {:  return new List().add(p);  :}
	|	type_parameter_list.l COMMA type_parameter_1.p {:  return l.add(p);  :}
	;
	
TypeVariable type_parameter =
		IDENTIFIER              {:  return new TypeVariable(new Modifiers(), IDENTIFIER, new List(), new List());  :}
	|	IDENTIFIER type_bound.l {:  return new TypeVariable(new Modifiers(), IDENTIFIER, new List(), l); :}
	;
	
TypeVariable type_parameter_1 =
		IDENTIFIER GT             {:  return new TypeVariable(new Modifiers(), IDENTIFIER, new List(), new List());  :}
  |	IDENTIFIER type_bound_1.l {:  return new TypeVariable(new Modifiers(), IDENTIFIER, new List(), l);  :}
	;
	
List type_bound =
		EXTENDS reference_type.t {:  return new List().add(t);  :}
	|	EXTENDS reference_type.t additional_bound_list.l {:  l.insertChild(t,0); return l; :}
    ;
    
List type_bound_1 =
		EXTENDS reference_type_1.t {:  return new List().add(t);  :}
	|	EXTENDS reference_type.t additional_bound_list_1.l {:  l.insertChild(t,0); return l; :}
    ;
    
List additional_bound_list =
		additional_bound.b additional_bound_list.l {:  l.insertChild(b,0); return l; :}
	|	additional_bound.b {:  return new List().add(b);  :}
    ;
    
List additional_bound_list_1 =
		additional_bound.b additional_bound_list_1.l {:  l.insertChild(b,0); return l; :}
	|	additional_bound_1.b {:  return new List().add(b);  :}
    ;
    
Access additional_bound =
		AND interface_type.t {:  return t;  :}
	;
	
Access additional_bound_1 =
		AND reference_type_1.t {:  return t;  :}
	;

ImportDecl import_declaration =
      single_static_import_declaration.s {:  return s;  :}
    |  static_import_on_demand_declaration.t {:  return t;  :}
    ;

ImportDecl single_static_import_declaration =
      IMPORT STATIC name.n DOT IDENTIFIER SEMICOLON {: return new SingleStaticImportDecl(n, IDENTIFIER);  :};

ImportDecl static_import_on_demand_declaration =
      IMPORT STATIC name.n DOT MULT SEMICOLON {: return new StaticImportOnDemandDecl(n);  :};
ParameterDeclaration formal_parameter =
    modifiers.m? type.t ELLIPSIS IDENTIFIER dims.d? 
    {: return new VariableArityParameterDeclaration(new Modifiers(m), t.addArrayDims(d), IDENTIFIER); :}  ;

Expr primary_no_new_array :=
    literal.l                                  {: return l; :}
  | primitive_type.n dims.d? DOT class_literal.c {: return n.addArrayDims(d).qualifiesAccess(c); :}
  | name.n dims.d? DOT class_literal.c          {: return n.addArrayDims(d).qualifiesAccess(c); :}
  | VOID DOT class_literal.c                   {: PrimitiveTypeAccess v = new PrimitiveTypeAccess("void");
                                                  v.setStart(VOID.getStart());
                                                  v.setEnd(VOID.getEnd());
                                                  return v.qualifiesAccess(c); :}
  | THIS                                       {: return new ThisAccess("this"); :}
  | name.n DOT THIS                            {: ThisAccess t = new ThisAccess("this");
                                                  t.setStart(THIS.getStart()); t.setEnd(THIS.getEnd());
                                                  return n.qualifiesAccess(t); :}
  | LPAREN expression_nn.e RPAREN                 {: return new ParExpr(e); :}
  | LPAREN name.n RPAREN                       {: return new ParExpr(n); :}
  | class_instance_creation_expression.c       {: return c; :}
  | field_access.f                             {: return f; :}
  | method_invocation.m                        {: return m; :}
  | array_access.a                             {: return a; :}
  ;


Expr postfix_expression_nn =
    primary.p                                  {: return p; :}
  | postincrement_expression.e                 {: return e; :}
  | postdecrement_expression.e                 {: return e; :}
  ;
Expr unary_expression_nn =
    preincrement_expression.e                  {: return e; :}
  | predecrement_expression.e                  {: return e; :}
  | PLUS unary_expression.e                    {: return new PlusExpr(e); :}
  | MINUS unary_expression.e                   {: return new MinusExpr(e); :}
  | unary_expression_not_plus_minus_nn.e          {: return e; :}
  ;
Expr unary_expression_not_plus_minus_nn =
    postfix_expression_nn.e                       {: return e; :}
  | COMP unary_expression.e                    {: return new BitNotExpr(e); :}
  | NOT unary_expression.e                     {: return new LogNotExpr(e); :}
  | cast_expression.e                          {: return e; :}
  ;
Expr multiplicative_expression_nn =
    unary_expression_nn.e                                     {: return e; :}
  | name.e1 MULT unary_expression.e2  {: return new MulExpr(e1, e2); :}
  | multiplicative_expression_nn.e1 MULT unary_expression.e2  {: return new MulExpr(e1, e2); :}
  | name.e1 DIV unary_expression.e2   {: return new DivExpr(e1, e2); :}
  | multiplicative_expression_nn.e1 DIV unary_expression.e2   {: return new DivExpr(e1, e2); :}
  | name.e1 MOD unary_expression.e2   {: return new ModExpr(e1, e2); :}
  | multiplicative_expression_nn.e1 MOD unary_expression.e2   {: return new ModExpr(e1, e2); :}
  ;
Expr additive_expression_nn =
    multiplicative_expression_nn.e                                {: return e; :}
  | name.e1 PLUS multiplicative_expression.e2   {: return new AddExpr(e1, e2); :}
  | additive_expression_nn.e1 PLUS multiplicative_expression.e2   {: return new AddExpr(e1, e2); :}
  | name.e1 MINUS multiplicative_expression.e2  {: return new SubExpr(e1, e2); :}
  | additive_expression_nn.e1 MINUS multiplicative_expression.e2  {: return new SubExpr(e1, e2); :}
  ;
Expr shift_expression_nn =
    additive_expression_nn.e                               {: return e; :}
  | name.e1 LSHIFT additive_expression.e2   {: return new LShiftExpr(e1, e2); :}
  | shift_expression_nn.e1 LSHIFT additive_expression.e2   {: return new LShiftExpr(e1, e2); :}
  | name.e1 RSHIFT additive_expression.e2   {: return new RShiftExpr(e1, e2); :}
  | shift_expression_nn.e1 RSHIFT additive_expression.e2   {: return new RShiftExpr(e1, e2); :}
  | name.e1 URSHIFT additive_expression.e2  {: return new URShiftExpr(e1, e2); :}
  | shift_expression_nn.e1 URSHIFT additive_expression.e2  {: return new URShiftExpr(e1, e2); :}
  ;
Expr relational_expression_nn =
    shift_expression_nn.e                                  {: return e; :}
  | name.e1 LT shift_expression.e2     {: return new LTExpr(e1, e2); :}
  | shift_expression_nn.e1 LT shift_expression.e2     {: return new LTExpr(e1, e2); :}
  | name.e1 GT shift_expression.e2     {: return new GTExpr(e1, e2); :}
  | shift_expression_nn.e1 GT shift_expression.e2     {: return new GTExpr(e1, e2); :}
  | name.e1 LTEQ shift_expression.e2   {: return new LEExpr(e1, e2); :}
  | relational_expression_nn.e1 LTEQ shift_expression.e2   {: return new LEExpr(e1, e2); :}
  | name.e1 GTEQ shift_expression.e2   {: return new GEExpr(e1, e2); :}
  | relational_expression_nn.e1 GTEQ shift_expression.e2   {: return new GEExpr(e1, e2); :}
  | name.e INSTANCEOF reference_type.t {: return new InstanceOfExpr(e, t); :}
  | relational_expression_nn.e INSTANCEOF reference_type.t {: return new InstanceOfExpr(e, t); :}
  ;
Expr equality_expression_nn =
    relational_expression_nn.e                               {: return e; :}
  | name.e1 EQEQ relational_expression.e2  {: return new EQExpr(e1, e2); :}
  | equality_expression_nn.e1 EQEQ relational_expression.e2  {: return new EQExpr(e1, e2); :}
  | name.e1 NOTEQ relational_expression.e2 {: return new NEExpr(e1, e2); :}
  | equality_expression_nn.e1 NOTEQ relational_expression.e2 {: return new NEExpr(e1, e2); :}
  ;
Expr and_expression_nn =
    equality_expression_nn.e                               {: return e; :}
  | name.e1 AND equality_expression.e2        {: return new AndBitwiseExpr(e1, e2); :}
  | and_expression_nn.e1 AND equality_expression.e2        {: return new AndBitwiseExpr(e1, e2); :}
  ;
Expr exclusive_or_expression_nn =
    and_expression_nn.e                                    {: return e; :}
  | name.e1 XOR and_expression.e2    {: return new XorBitwiseExpr(e1, e2); :}
  | exclusive_or_expression_nn.e1 XOR and_expression.e2    {: return new XorBitwiseExpr(e1, e2); :}
  ;
Expr inclusive_or_expression_nn =
    exclusive_or_expression_nn.e                                {: return e; :}
  | name.e1 OR exclusive_or_expression.e2 {: return new OrBitwiseExpr(e1, e2); :}
  | inclusive_or_expression_nn.e1 OR exclusive_or_expression.e2 {: return new OrBitwiseExpr(e1, e2); :}
  ;
Expr conditional_and_expression_nn =
    inclusive_or_expression_nn.e                                       {: return e; :}
  | name.e1 ANDAND inclusive_or_expression.e2 {: return new AndLogicalExpr(e1, e2); :}
  | conditional_and_expression_nn.e1 ANDAND inclusive_or_expression.e2 {: return new AndLogicalExpr(e1, e2); :}
  ;
Expr conditional_or_expression_nn =
    conditional_and_expression_nn.e                                    {: return e; :}
  | name.e1 OROR conditional_and_expression.e2 {: return new OrLogicalExpr(e1, e2); :}
  | conditional_or_expression_nn.e1 OROR conditional_and_expression.e2 {: return new OrLogicalExpr(e1, e2); :}
  ;
Expr conditional_expression_nn =
    conditional_or_expression_nn.c                                                        {: return c; :}
  | name.c QUESTION expression.e1 COLON conditional_expression.e2 {: return new ConditionalExpr(c, e1, e2); :}
  | conditional_or_expression_nn.c QUESTION expression.e1 COLON conditional_expression.e2 {: return new ConditionalExpr(c, e1, e2); :}
  ;
Expr assignment_expression_nn =
    conditional_expression_nn.c {: return c; :}
  | assignment.a {: return a; :}
  ;

Expr expression_nn =
    assignment_expression_nn
  ;

/* abc - The AspectBench Compiler
 * Copyright (C) 2008 Pavel Avgustinov
 * Copyright (C) 2008 Torbjorn Ekman
 * Copyright (C) 2008 Julian Tibble
 *
 * This compiler is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This compiler is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this compiler, in the file LESSER-GPL;
 * if not, write to the Free Software Foundation, Inc.,
 * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */


/* ------------------------- POINTCUT EXPRESSIONS ---------------------- */

PointcutExpr pointcut_expr = 
      or_pointcut_expr.a
        {: return a; :}
   |  pointcut_expr.a ANDAND or_pointcut_expr.b
        {:
           return new AndPointcutExpr(a, b);
        :} 
   ;

PointcutExpr or_pointcut_expr =
      unary_pointcut_expr.a 
        {: 
           return a;
        :}
   |  or_pointcut_expr.a OROR unary_pointcut_expr.b 
        {: 
           return new OrPointcutExpr(a, b);
        :}
   ;

PointcutExpr unary_pointcut_expr =
      basic_pointcut_expr.a
        {: //ParserTrace.parserTrace("unary_pointcut_expr is a basic_pointcut_expr");
           return a;
        :}
   |  NOT unary_pointcut_expr.a
        {: //ParserTrace.parserTrace("! unary_pointcut_expr");
           return new NegPointcutExpr(a);
        :}
   ;

PointcutExpr basic_pointcut_expr =
     LPAREN pointcut_expr.a RPAREN
       {: //ParserTrace.parserTrace("basic_pointcut_expr is ( pointcut_expr )");
          return a;
       :}
   | PC_CALL.x LPAREN method_constructor_pattern.a RPAREN.y
       {: //ParserTrace.parserTrace("CALL pointcut");
          return new CallPointcutExpr(a);
       :}
   | PC_EXECUTION.x LPAREN method_constructor_pattern.a RPAREN.y
       {: //ParserTrace.parserTrace("EXECUTION pointcut");
          return new ExecutionPointcutExpr(a);
       :}
   | PC_INITIALIZATION.x LPAREN constructor_pattern.a RPAREN.y
       {: //ParserTrace.parserTrace("INITIALIZATION pointcut");
          return new InitializationPointcutExpr(a);
       :}
   | PC_PREINITIALIZATION.x LPAREN constructor_pattern.a RPAREN.y
       {: //ParserTrace.parserTrace("PREINITIALIZATION pointcut");
          return new PreInitializationPointcutExpr(a);
       :}
   | PC_STATICINITIALIZATION.x LPAREN classname_pattern_expr.a RPAREN.y
       {: //ParserTrace.parserTrace("STATICINITIALIZATION pointcut");
          return new StaticInitializationPointcutExpr(a);
       :}
   | PC_GET.x LPAREN field_pattern.a RPAREN.y
       {: //ParserTrace.parserTrace("GET pointcut");
          return new GetPointcutExpr(a);
       :} 
   | PC_SET.x LPAREN field_pattern.a RPAREN.y
       {: //ParserTrace.parserTrace("SET pointcut");
          return new SetPointcutExpr(a);
       :}
   | PC_HANDLER.x LPAREN classname_pattern_expr.a RPAREN.y
     /* verify that this really can take any type_pattern */
       {: //ParserTrace.parserTrace("HANDLER pointcut");
          return new HandlerPointcutExpr(a);
       :}
   | PC_ADVICEEXECUTION.a LPAREN RPAREN.y
       {: //ParserTrace.parserTrace("ADVICEEXECUTION pointcut");
          return new AdviceExecutionPointcutExpr();
       :}
   | PC_WITHIN.x LPAREN classname_pattern_expr.a RPAREN.y
       {: //ParserTrace.parserTrace("WITHIN pointcut on pattern");
          return new WithinPointcutExpr(a);
       :}
   | PC_WITHINCODE.x LPAREN method_constructor_pattern.a RPAREN.y
       {: //ParserTrace.parserTrace("WITHINCODE pointcut on method_constructor_pattern");
          return new WithinCodePointcutExpr(a);
       :}
   | PC_CFLOW.x LPAREN pointcut_expr.a RPAREN.y
       {: //ParserTrace.parserTrace("CFLOW pointcut");
          return new CflowPointcutExpr(a);
       :}
   | PC_CFLOWBELOW.x LPAREN pointcut_expr.a RPAREN.y
       {: //ParserTrace.parserTrace("CFLOWBELOW pointcut");
          return new CflowBelowPointcutExpr(a);
       :}
   | PC_IF.x LPAREN expression.a RPAREN.y
       {: //ParserTrace.parserTrace("IF pointcut");
       
          return new IfPointcutExpr(a);
       :}
   // following two rules, ajc only allows * or a fully-defined type/id
   | PC_THIS.x LPAREN type_id_star.a RPAREN.y 
       {: //ParserTrace.parserTrace("THIS pointcut");
          return new ThisPointcutExpr(a);
       :}
   | PC_TARGET.x LPAREN type_id_star.a RPAREN.y 
       {: //ParserTrace.parserTrace("TARGET pointcut");
          return new TargetPointcutExpr(a);
       :}
   // for args, ajc only allows each arg to be * .. or fully-defined type/id
   | PC_ARGS.x LPAREN type_id_star_list.a? RPAREN.y
       {: //ParserTrace.parserTrace("ARGS pointcut");
          return new ArgsPointcutExpr(a);
       :}   
   // for named pointcuts, ajc allows only * or fully-defined type/id
    |  name.a LPAREN type_id_star_list.b? RPAREN.y
       {:
          Access pc_access;
          if (a instanceof AbstractDot) {
            AbstractDot dot = (AbstractDot) a;
            ParseName pn = (ParseName) dot.extractLast();
            dot.replaceLast(new PointcutAccess(pn.getID()));
            pc_access = dot;
          } else {
            ParseName pn = (ParseName) a;
            pc_access = new PointcutAccess(pn.getID());
          }
          return new NamedPointcutExpr(pc_access, b);
       :}
  ;




/* ------------------- NAME PATTERNS ---------------------------------- */

NamePattern name_pattern =
      simple_name_pattern.a
        {: return a;
        :}
   |  name_pattern.a DOT simple_name_pattern.b
        {: return new DotNamePattern(a, b);
        :}
   |  name_pattern.a PC_DOTDOT.d simple_name_pattern.b
        {: 
           return new DotDotNamePattern(a, b);
        :}
   ;

SimpleNamePattern simple_name_pattern = 
     MULT.m
        {: //ParserTrace.parserTrace("name_pattern is a star: ");
           return new SimpleNamePattern("*");
        :}
   | IDENTIFIERPATTERN.a
        {: //ParserTrace.parserTrace("name_pattern is simple name pattern: " + a);
           return new SimpleNamePattern(a);
        :}
   | IDENTIFIER
        {: //ParserTrace.parserTrace("name_pattern is identifer: " + IDENTIFIER.value);
           return new SimpleNamePattern(IDENTIFIER);
        :}
   | ASPECT.a
     {: //ParserTrace.parserTrace("aspectj_reserved_identifier: " + a);
        return new SimpleNamePattern(a.toString());
     :}
   | PC_ADVICEEXECUTION.a
     {: //ParserTrace.parserTrace("aspectj_reserved_identifier: " + a);
        return new SimpleNamePattern(a.toString());
     :}
   | PC_ARGS.a
     {: //ParserTrace.parserTrace("aspectj_reserved_identifier: " + a);
        return new SimpleNamePattern(a.toString());
     :}
   | PC_CALL.a
     {: //ParserTrace.parserTrace("aspectj_reserved_identifier: " + a);
        return new SimpleNamePattern(a.toString());
     :}
   | PC_CFLOW.a
     {: //ParserTrace.parserTrace("aspectj_reserved_identifier: " + a);
        return new SimpleNamePattern(a.toString());
     :}
   | PC_CFLOWBELOW.a
     {: //ParserTrace.parserTrace("aspectj_reserved_identifier: " + a);
        return new SimpleNamePattern(a.toString());
     :}
   | PC_ERROR.a
     {: //ParserTrace.parserTrace("aspectj_reserved_identifier: " + a);
        return new SimpleNamePattern(a.toString());
     :}
   | PC_EXECUTION.a
     {: //ParserTrace.parserTrace("aspectj_reserved_identifier: " + a);
        return new SimpleNamePattern(a.toString());
     :}
   | PC_GET.a
     {: //ParserTrace.parserTrace("aspectj_reserved_identifier: " + a);
        return new SimpleNamePattern(a.toString());
     :}
   | PC_HANDLER.a
     {: //ParserTrace.parserTrace("aspectj_reserved_identifier: " + a);
        return new SimpleNamePattern(a.toString());
     :}
   | PC_INITIALIZATION.a
     {: //ParserTrace.parserTrace("aspectj_reserved_identifier: " + a);
        return new SimpleNamePattern(a.toString());
     :}
   | PC_PARENTS.a
     {: //ParserTrace.parserTrace("aspectj_reserved_identifier: " + a);
        return new SimpleNamePattern(a.toString());
     :}
   | PC_PRECEDENCE.a
     {: //ParserTrace.parserTrace("aspectj_reserved_identifier: " + a);
        return new SimpleNamePattern(a.toString());
     :}
   | PC_PREINITIALIZATION.a
     {: //ParserTrace.parserTrace("aspectj_reserved_identifier: " + a);
        return new SimpleNamePattern(a.toString());
     :}
   | PC_RETURNING.a
     {: //ParserTrace.parserTrace("aspectj_reserved_identifier: " + a);
        return new SimpleNamePattern(a.toString());
     :}
   | PC_SET.a
     {: //ParserTrace.parserTrace("aspectj_reserved_identifier: " + a);
        return new SimpleNamePattern(a.toString());
     :}
   | PC_SOFT.a
     {: //ParserTrace.parserTrace("aspectj_reserved_identifier: " + a);
        return new SimpleNamePattern(a.toString());
     :}
   | PC_STATICINITIALIZATION.a
     {: //ParserTrace.parserTrace("aspectj_reserved_identifier: " + a);
        return new SimpleNamePattern(a.toString());
     :}
   | PC_TARGET.a
     {: //ParserTrace.parserTrace("aspectj_reserved_identifier: " + a);
        return new SimpleNamePattern(a.toString());
     :}
   | PC_THROWING.a
     {: //ParserTrace.parserTrace("aspectj_reserved_identifier: " + a);
        return new SimpleNamePattern(a.toString());
     :}
   | PC_WARNING.a
     {: //ParserTrace.parserTrace("aspectj_reserved_identifier: " + a);
        return new SimpleNamePattern(a.toString());
     :}
   | PC_WITHINCODE.a
     {: //ParserTrace.parserTrace("aspectj_reserved_identifier: " + a);
        return new SimpleNamePattern(a.toString());
     :}
   ;


NamePattern classtype_dot_id =
     simple_name_pattern.b
        {: //ParserTrace.parserTrace("classtype_dot_id is simple_name_pattern: ");
	   return b;
        :}
  |  name_pattern.a DOT simple_name_pattern.b 
        {: //ParserTrace.parserTrace("classtype_dot_id is np . simple_name_pattern");
           return new DotNamePattern(a, b);
        :}
  |  name_pattern.a PC_PLUS.p DOT simple_name_pattern.b 
        {: //ParserTrace.parserTrace("classtype_dot_id is np + . simple_name_pattern");
           return new DotNamePattern(new SubtypeNamePattern(a), b);
        :}
  |  name_pattern.a PC_DOTDOT.d simple_name_pattern.b 
        {: //ParserTrace.parserTrace("classtype_dot_id is np . simple_name_pattern");
           return new DotDotNamePattern(a, b);
        :}
  |  LPAREN.x type_pattern_expr.a RPAREN.y DOT simple_name_pattern.b
        /* must check it is a class pattern expr */
       {: //ParserTrace.parserTrace("(tpe) . new");
          return new TypeDotNamePattern(a, b);
       :}
  ;

NamePattern classtype_dot_new =
     NEW.a
        {: //ParserTrace.parserTrace("classtype_dot_new is NEW: ");
	   return new DotNamePattern(new SimpleNamePattern("*"),
	                             new SimpleNamePattern("<init>"));
        :}
  |  name_pattern.a DOT NEW.y 
        {: //ParserTrace.parserTrace("classtype_dot_new is np . NEW");
           return new DotNamePattern(a, new SimpleNamePattern("<init>"));
        :}
  |  name_pattern.a PC_PLUS.p DOT NEW.y 
        {: //ParserTrace.parserTrace("classtype_dot_new is np + . NEW");
           return new DotNamePattern(new SubtypeNamePattern(a), new SimpleNamePattern("<init>"));
        :}
  |  name_pattern.a PC_DOTDOT.d NEW.y 
        {: //ParserTrace.parserTrace("classtype_dot_new is np .. NEW");
           return new DotDotNamePattern(a, new SimpleNamePattern("<init>"));
        :}
  |  LPAREN.x type_pattern_expr.a RPAREN DOT NEW.y
        /* must check it is a class pattern expr */
       {: //ParserTrace.parserTrace("(tpe) . new");
          return new TypeDotNamePattern(a, new SimpleNamePattern("<init>"));
       :}
  ;


/* ------------------- TYPE PATTERNS ----------------------------------- */


Pattern type_pattern_expr = 
      or_type_pattern_expr.a
        {: //ParserTrace.parserTrace("type_pattern_expr is an or_type_pattern_expr");
           return a;
        :}
   |  type_pattern_expr.a PC_ANDAND or_type_pattern_expr.b
        {: //ParserTrace.parserTrace("type_pattern_expr && or_type_pattern_expr");
	   return new AndPattern(a, b);
        :} 
   ;

Pattern or_type_pattern_expr =
      unary_type_pattern_expr.a 
        {: //ParserTrace.parserTrace("or_type_pattern_expr is a unary_type_pattern_expr");
           return a;
        :}
   |  or_type_pattern_expr.a PC_OROR unary_type_pattern_expr.b 
        {: //ParserTrace.parserTrace("or_type_pattern_expr || unary_type_pattern_expr");
           return new OrPattern(a, b);
        :}
   ;

Pattern unary_type_pattern_expr =
      basic_type_pattern.a
        {: //ParserTrace.parserTrace("unary_type_pattern_expr is a  basic_type_pattern");
           return a;
        :}
   |  NOT.a unary_type_pattern_expr.b 
        {: //ParserTrace.parserTrace("! unary_type_pattern_expr");
           return new NegPattern(b);
        :}
   ;

/* check that VOID is not in patterns for formals, ok for 
       patterns for return types */
NamePattern basic_type_pattern =
     VOID.a
       {: //ParserTrace.parserTrace("VOID type");
          return new ExplicitTypeNamePattern(new TypeAccess("void"));
       :}
  |  base_type_pattern.a
       {: //ParserTrace.parserTrace("basic_type_pattern is a reference_type_pattern");
          return a;
       :} 
  |  base_type_pattern.a dims.b
       {: //ParserTrace.parserTrace("basic_type_pattern is just a primitive_type");
          return new ArraytypeNamePattern(a, b);
       :}
  |  LPAREN.lp type_pattern_expr.a RPAREN.rp
       {: //ParserTrace.parserTrace("basic_type_pattern is a ( type_pattern_expr )");
          return a;
       :}
  ;

NamePattern base_type_pattern =
     primitive_type.a
       {: //ParserTrace.parserTrace("basic_type_pattern is just a primitive_type");
          return new ExplicitTypeNamePattern(a);
       :}
  |  name_pattern.a 
       {: //ParserTrace.parserTrace("reference_type_pattern is a name_pattern");
	  return a;
       :}
  |  name_pattern.a PC_PLUS.p 
       {: //ParserTrace.parserTrace("reference_type_pattern is name_pattern +");
          return new SubtypeNamePattern(a);
       :}
  ;

/* ------------------ CLASSNAME PATTERNS ------------------------------- */



Pattern classname_pattern_expr = 
      and_classname_pattern_expr.a
        {: //ParserTrace.parserTrace("classname_pattern_expr is an and_classname_pattern_expr");
           return a;
        :}
   |  classname_pattern_expr.a PC_OROR and_classname_pattern_expr.b
        {: //ParserTrace.parserTrace("classname_pattern_expr || and_classname_pattern_expr");
           return new OrPattern(a, b);
        :} 
   ;

Pattern and_classname_pattern_expr =
      unary_classname_pattern_expr.a 
        {: //ParserTrace.parserTrace("and_classname_pattern_expr is a unary_classname_pattern_expr");
           return a;
        :}
   |  and_classname_pattern_expr.a PC_ANDAND unary_classname_pattern_expr.b 
        {: //ParserTrace.parserTrace("and_classname_pattern_expr && unary_classname_pattern_expr");
           return new AndPattern(a, b);
        :}
   ;

Pattern unary_classname_pattern_expr =
      basic_classname_pattern.a
        {: //ParserTrace.parserTrace("unary_classname_pattern_expr is a  basic_classname_pattern");
           return a;
        :}
   |  NOT.x unary_classname_pattern_expr.a 
        {: //ParserTrace.parserTrace("! unary_classname_pattern_expr");
           return new NegPattern(a);
        :}
   ;

Pattern basic_classname_pattern =
     name_pattern.a 
        {: //ParserTrace.parserTrace("classname_type_pattern is a name_pattern");
	   return a;
        :}
  |  name_pattern.a PC_PLUS.p 
        {: //ParserTrace.parserTrace("classname_type_pattern is name_pattern +");
           return new SubtypeNamePattern(a);
        :}
  |  LPAREN.lp classname_pattern_expr.a RPAREN.rp
        {: //ParserTrace.parserTrace("basic_classname_pattern is a ( classname_pattern_expr )");
           return a;
        :}
  ;


NamePattern classname_pattern_expr_nobang = 
      and_classname_pattern_expr_nobang.a
        {: //ParserTrace.parserTrace("classname_pattern_expr_nobang is an and_classname_pattern_expr");
           return a;
        :}
   |  classname_pattern_expr_nobang.a PC_OROR and_classname_pattern_expr.b
        {: //ParserTrace.parserTrace("classname_pattern_expr_nobang || and_classname_pattern_expr");
           return new OrPattern(a, b);
        :} 
   ;

NamePattern and_classname_pattern_expr_nobang =
      basic_classname_pattern.a 
        {: //ParserTrace.parserTrace("and_classname_pattern_expr_nobang is a basic_classname_pattern");
           return a;
        :}
   |  and_classname_pattern_expr_nobang.a PC_ANDAND unary_classname_pattern_expr.b 
        {: //ParserTrace.parserTrace("and_classname_pattern_expr_nobang && unary_classname_pattern_expr");
           return new AndPattern(a, b);
        :}
   ;

/* ----------------------- MODIFIER PATTERNS ---------------------------- */

List modifier_pattern_expr =
     modifier.a
       {: //ParserTrace.parserTrace("first modifier " + a);
	  return new List().add(new ModifierPattern(a));
       :}
  |  NOT.b modifier.a
       {: //ParserTrace.parserTrace("first modifier is NOT " + a);
	  return new List().add(new NegModifierPattern(a));
       :}
  |  modifier_pattern_expr.a modifier.b
       {: //ParserTrace.parserTrace("another modifier is " + b);
          return a.add(new ModifierPattern(b));
       :}
  |  modifier_pattern_expr.a NOT.c modifier.b
       {: //ParserTrace.parserTrace("another modifier is NOT" + b);
          return a.add(new NegModifierPattern(b));
       :}
  ;


/* -------------- METHOD, CONSTRUCTOR and FIELD PATTERNS ----------------- */

List throws_pattern_list_opt =
     // epsilon
       {: //ParserTrace.parserTrace("no throws patterns");
          return new List(); 
       :}
  |  THROWS throws_pattern_list.a
       {: //ParserTrace.parserTrace("has throws patterns");
          return a;
       :}
  ;

List throws_pattern_list =
     throws_pattern.a
        {: //ParserTrace.parserTrace("First throws pattern in the list.");
           return new List().add(a); 
        :}
    |  throws_pattern_list.a COMMA throws_pattern.b
        {: //ParserTrace.parserTrace("Another throws parameter");
	   return a.add(b);
        :}
    ;

NamePattern throws_pattern =
     classname_pattern_expr_nobang.a
       {: //ParserTrace.parserTrace("throws pattern is " + a);
	  return a;
       :}
  |  NOT.b classname_pattern_expr.a
       {: //ParserTrace.parserTrace("throws pattern is NOT " + a);
          return new UniversalNegPattern(a);
       :}
;

MemberPattern method_constructor_pattern =
     method_pattern.a
       {: //ParserTrace.parserTrace("method_constructor is method");
          return a;
       :}
  |  constructor_pattern.a
       {: //ParserTrace.parserTrace("method_constructor is constructor");
          return a;
       :}
  ;

MethodPattern method_pattern =
     modifier_pattern_expr.a  
       type_pattern_expr.b 
       classtype_dot_id.c
       LPAREN.lp formal_pattern_list.d? RPAREN.rp 
       throws_pattern_list_opt.e
        {: //ParserTrace.parserTrace("method_pattern with modifiers");
           return new MethodPattern(a, b, c, d, e);
        :}
  |  type_pattern_expr.b classtype_dot_id.c
       LPAREN.lp formal_pattern_list.d? RPAREN.rp 
       throws_pattern_list_opt.e
        {: //ParserTrace.parserTrace("method_pattern no modifiers");
           return new MethodPattern(new List(), b, c, d, e);
        :}
  ;

ConstructorPattern constructor_pattern =
     modifier_pattern_expr.a  
       classtype_dot_new.b
       LPAREN.lp formal_pattern_list.c? RPAREN.rp 
       throws_pattern_list_opt.d
        {: //ParserTrace.parserTrace("constructor_pattern with modifiers");
           return new ConstructorPattern(a, b, c, d);
        :}
  |    classtype_dot_new.b
       LPAREN.lp formal_pattern_list.c? RPAREN.rp 
       throws_pattern_list_opt.d
        {: //ParserTrace.parserTrace("constructor_pattern no modifiers");
           return new ConstructorPattern(new List(), b, c, d);
        :}
  ;

FieldPattern field_pattern =
     modifier_pattern_expr.a  type_pattern_expr.b classtype_dot_id.c
// should be regular_variable_pattern 
       {: //ParserTrace.parserTrace("field pattern with modifiers");
          return new FieldPattern(a, b, c);
       :}
  |  type_pattern_expr.b classtype_dot_id.c
       {: //ParserTrace.parserTrace("field pattern without modifiers");
          return new FieldPattern(new List(), b, c);
       :}
  ;

/* -------------------- FORMAL PARAMETER LIST PATTERNS --------------*/

List formal_pattern_list =
     formal_pattern.a
        {: //ParserTrace.parserTrace("First formal pattern in the list.");
           return new List().add(a); 
        :}
    |  formal_pattern_list.a COMMA formal_pattern.b
        {: //ParserTrace.parserTrace("Another formal parameter");
	   return a.add(b);
        :}
    ;

FormalPattern formal_pattern =
       PC_DOTDOT.a 
         {: //ParserTrace.parserTrace("DOT DOT formal pattern");
            return new WildcardFormalPattern();
         :}
    |  DOT DOT.a
         {: //ParserTrace.parserTrace("DOT DOT formal pattern - separate dots");
            return new WildcardFormalPattern();
         :}
    |  type_pattern_expr.a 
         {: //ParserTrace.parserTrace("A type pattern formal pattern");
            return new ConcreteFormalPattern(a);
         :}
    ;
    
/* -------------------- POINTCUT PARAMETER LIST PATTERNS --------------*/

List type_id_star_list =
     type_id_star.a
        {: //ParserTrace.parserTrace("First pointcut parameter in the list.");
           return new List().add(a);
        :}
    |  type_id_star_list.a COMMA type_id_star.b
        {: //ParserTrace.parserTrace("Another pointcut parameter");
	   return a.add(b);
        :}
    ;

// there should be three alternatives here: star, type, and identifier
// disambiguation between type and identifier happens in the type-checker
BindingPattern type_id_star =
       PC_MULT.a 
         {: //ParserTrace.parserTrace("Star pointcut parameter");
            return new StarBindingPattern();
         :}
    |  PC_DOTDOT.a 
         {: //ParserTrace.parserTrace("DotDot pointcut parameter");
            return new DotDotBindingPattern();
         :}
    |  type.a 
         {: //ParserTrace.parserTrace("A type pointcut parameter");
            return new NameBindingPattern(new ExplicitTypeNamePattern(a));
         :}
    |  type.a PC_PLUS
         {: //ParserTrace.parserTrace("A type pointcut parameter with a plus");
            return new NameBindingPattern(new ExplicitTypeNamePattern(a));
         :}
    ;



//---------------------------------------------------------------------------------------------
// import layer LayerX;
//---------------------------------------------------------------------------------------------

//ImportDecl import_declaration =
//   single_layer_import_declaration.s           
//   {: return s; :};
   
//ImportDecl single_layer_import_declaration =    
//    IMPORT LAYER name.n SEMICOLON  
//	{:	return new LayerImportDecl(n);	:};
	 
//---------------------------------------------------------------------------------------------
// LayerDecl
// --------------
// layer LayerX { 
//    public void pckg.Classname.foo(){ ...}
//    public void pckg.Classname.bar(){ ...}  }
// }
//---------------------------------------------------------------------------------------------
ClassDecl class_declaration = 
    layer_declaration.c  {: return c; :};
	
LayerDecl layer_declaration =   
  modifiers.m LAYER IDENTIFIER subject_declaration.subject? super.s? layer_body.body  
  {: return new LayerDecl(/*implements*/new List(), new Modifiers(m), IDENTIFIER, subject, s, body); :};

List subject_declaration =   
   FORSUBJECT class_type_list.i 
   {: return i; :};   
  
//List implicit_activation =
//    LAYER_ACTIVATION class_type_list.i 
//    {: return i; :};
//
//List implicit_deactivation =
//    	LAYER_DEACTIVATION class_type_list.i  {: return i; :};
    


// OpenLayerDecl
BodyDecl class_body_declaration =
  open_layer_declaration.d 
  {: return d; :};

OpenLayerDecl open_layer_declaration = 
	LAYER type.t layer_body.b 
  {: return new OpenLayerDecl(t, b); :}; 

 
List layer_body =
	LBRACE  layer_body_declarations.c? RBRACE     
    {: return c; :} ;
    
List layer_body_declarations =
    layer_body_declaration.c                           
    {: return new List().add(c); :}
    | layer_body_declarations.l layer_body_declaration .c 
    {: return l.add(c); :} ;
    
BodyDecl layer_body_declaration =
    partial_method_declaration.c 	{: return c; :}
	| method_declaration.c 			{: return c; :}
    | field_declaration.c 				{: return c; :} 
    | constructor_declaration.c    	{: return c; :};
    
PartialMethodDecl partial_method_declaration =
    partial_method_header.m method_body.b              
    {: m.setBlockOpt(b); return m; :} ;

PartialMethodDecl partial_method_header =
	  modifiers.m? type.retType name_pattern.pattern LPAREN formal_parameter_list.params? RPAREN throws.exceptions?
	  {: return new PartialMethodDecl(new Modifiers(m), retType, "", params, exceptions, new Opt(),  pattern); :};
	  
PartialMethodDecl partial_method_header =
	  modifiers.m? VOID name_pattern.pattern LPAREN formal_parameter_list.params? RPAREN  throws.exceptions?	  
	  {: return new PartialMethodDecl(new Modifiers(m), new PrimitiveTypeAccess("void"), "", params, exceptions, new Opt(),  pattern); :};
    
 Modifier modifier =
        BEFORE                                	{: return new Modifier("before"); :}
      | AFTER                                  {: return new Modifier("after");  :}
      | ACTIVE 								{: return new Modifier("staticactive");  :}
      ;     
    
//---------------------------------------------------------------------------------------------
// partial method definitions within layer-in-class
//---------------------------------------------------------------------------------------------
//MethodDecl method_header =
//  modifiers.m? type.t IDENTIFIER.i LPAREN formal_parameter_list.l? RPAREN dims.d? throws.tl?
//  {: return new LocalPartialMethodDecl(new Modifiers(m.add(new Modifier("before"))), t.addArrayDims(d), i, l, tl, new Opt()); :};

//MethodDecl method_header =
//  BEFORE modifiers.m? VOID IDENTIFIER.i LPAREN formal_parameter_list.l? RPAREN dims.d? throws.tl?
//  {: return new LocalPartialMethodDecl("before", new Modifiers(m), new PrimitiveTypeAccess("void"), i, l, tl, new Opt()); :};

//MethodDecl method_header =
//  AFTER modifiers.m? VOID IDENTIFIER.i LPAREN formal_parameter_list.l? RPAREN dims.d? throws.tl?
//  {: return new LocalPartialMethodDecl("after", new Modifiers(m),new PrimitiveTypeAccess("void"),  i, l, tl, new Opt()); :};
//
//MethodDecl method_header =
//  AFTER modifiers.m? type.t IDENTIFIER.i LPAREN formal_parameter_list.l? RPAREN dims.d? throws.tl?
//  {: return new LocalPartialMethodDecl("after", new Modifiers(m),t.addArrayDims(d),  i, l, tl, new Opt()); :};

//---------------------------------------------------------------------------------------------
// partial method definitions within class-in-layer
//---------------------------------------------------------------------------------------------

  
//MethodDecl partial_method_header =
//  modifiers.m? VOID name_pattern.i LPAREN formal_parameter_list.params? RPAREN dims.d? throws.tl?
//  {: return new FQPartialMethodDecl(new PrimitiveTypeAccess("void"),"", new Modifiers(m), i, l, tl, new Opt()); :};
  
//MethodDecl partial_method_header =
//  modifiers.m? type.t name_pattern.pattern LPAREN formal_parameter_list.params? RPAREN throws.exceptions?  
//  {: return new FQPartialMethodDecl("", new Modifiers(m), t, pattern, params, exceptions, new Opt()); :};


//MethodDecl partial_method_header =
//  AFTER modifiers.m? VOID name_pattern.i LPAREN formal_parameter_list.params? RPAREN dims.d? throws.tl?
//  {: return new FQPartialMethodDecl(new PrimitiveTypeAccess("void"),"after","", new Modifiers(m),  i, l, tl, new Opt()); :};

//MethodDecl partial_method_header =
//  AFTER modifiers.m? type.t name_pattern.pattern LPAREN formal_parameter_list.params? RPAREN throws.exceptions?
//  {: return new FQPartialMethodDecl("", new Modifiers(m.add(new Modifier("after"))), t, pattern, params, exceptions, new Opt()); :};
  
//---------------------------------------------------------------------------------------------
//  proceed(....)
//---------------------------------------------------------------------------------------------
Access method_invocation = 
		PROCEED LPAREN argument_list.l? RPAREN 
		{: return new ProceedExpr(l); :}
	|	SUPER_PROCEED LPAREN argument_list.l? RPAREN 
		{: return new SuperProceedExpr(l); :};

//---------------------------------------------------------------------------------------------
// with(LayerX){ <statements> }
//---------------------------------------------------------------------------------------------
Stmt block_statement = 
  LAYER_ACTIVATION LPAREN  argument_list.p  RPAREN statement_no_short_if.s
  {: return new LayerActivation(p, new Block(new List<Stmt>().add(s)), true); :};


//Stmt block_statement = 
//  LAYER_ACTIVATION LPAREN  argument_list.p  RPAREN block.b
//  {: return new LayerActivation(p, b, true); :};

//---------------------------------------------------------------------------------------------
// without(LayerX){ <statements> }
//---------------------------------------------------------------------------------------------
//Stmt block_statement = 
//  LAYER_DEACTIVATION LPAREN  argument_list.p  RPAREN block.b   
//  {: return new LayerActivation(p, b, false); :};
  
Stmt block_statement = 
  LAYER_DEACTIVATION LPAREN  argument_list.p  RPAREN statement_no_short_if.s
  {: return new LayerActivation(p, new Block(new List<Stmt>().add(s)), false); :};  


//---------------------------------------------------------------------------------------------
//  <Object> with (LayerX);
//---------------------------------------------------------------------------------------------
Expr object_access :=
   primary_no_new_array.e {: return e; :} |
   name.e {: return e; :};

Stmt statement = 
  object_access.e LAYER_ACTIVATION LPAREN  argument_list.a  RPAREN SEMICOLON
  {: return new ObjectSpecificLayerActivation(e, a, true); :};  
    
//---------------------------------------------------------------------------------------------
//  <Object> without (LayerX);
//---------------------------------------------------------------------------------------------
Stmt statement = 
  object_access.e LAYER_DEACTIVATION LPAREN  argument_list.a  RPAREN SEMICOLON
  {: return new ObjectSpecificLayerActivation(e, a, false); :};
  
//---------------------------------------------------------------------------------------------
//  <Object> without;
//---------------------------------------------------------------------------------------------
Stmt statement = 
  object_access.e LAYER_DEACTIVATION SEMICOLON
  {: return new ObjectSpecificLayerActivation(e, new List(), false); :};    

//---------------------------------------------------------------------------------------------
// Context
// --------------
// context <ID> { 
//    <context_constraint>*

//    <members>*,methods*,...
// }
//---------------------------------------------------------------------------------------------

TypeDecl type_declaration = 
    context_declaration.c  
    {: return c; :};

// TODO several body decl and  
/*
ContextDecl context_declaration =   
  modifiers.m? CONTEXT IDENTIFIER LBRACE
    context_constraint.first_constraint
  RBRACE   
  {: return new ContextDecl(new Modifiers(m), new Opt(), new List(), new List(), IDENTIFIER, new List().add(first_constraint)); :} 
  | modifiers.m? CONTEXT IDENTIFIER LBRACE
    class_body_declaration.first_body*
    context_constraint.first_constraint
  RBRACE   
  {: return new ContextDecl(new Modifiers(m), new Opt(), new List(), new List().add(first_body), IDENTIFIER, new List().add(first_constraint)); :} 
  | modifiers.m? CONTEXT IDENTIFIER LBRACE
    class_body_declaration.first_body
    context_constraint.first_constraint
    addidional_context_body_block.additional_body
  RBRACE   
  {: for(Object currentDecl : first_body)
       additional_body.getBodyElelemtListNoTransform().add(new BodyDecl().add(currentDecl));
     additional_body.getConstraintListNoTransform().add(first_constraint); 
     return new ContextDecl(new Modifiers(m), new Opt(), new List(), additional_body.getBodyElelemtListNoTransform(), IDENTIFIER, additional_body.getConstraintListNoTransform()); :}; 
*/
ContextDecl context_declaration =   
  modifiers.m? CONTEXT IDENTIFIER LBRACE
    addidional_context_body_block.additional_body
  RBRACE   
  {: return new ContextDecl(new Modifiers(m), new Opt(), new List(), additional_body.getBodyElelemtListNoTransform(), IDENTIFIER, additional_body.getConstraintListNoTransform()); :} 
;

ContextBodyBlock addidional_context_body_block =
    context_constraint.last_constraint                   
    {: return new ContextBodyBlock(new List(), new List().add(last_constraint), new List()); :}
    | class_body_declaration.last_bodydecl
    {: return new ContextBodyBlock(new List(), new List(), new List().add(last_bodydecl)); :}
	| context_constraint.next_constraint addidional_context_body_block.additional_body
    {: additional_body.getConstraintListNoTransform().add(next_constraint); return additional_body; :}
	| class_body_declaration.next_bodydecl addidional_context_body_block.additional_body 
    {: additional_body.getBodyElelemtListNoTransform().add(next_bodydecl); return additional_body; :}
 ;
    
/*List context_body =
    LBRACE context_body_declarations.c? RBRACE    
    {: return c; :} ;

List context_body_declarations =
    declarative_composition_declaration.c                           
    {: return new List().add(c); :}
    | declarative_composition_declaration.c class_body_declarations.l 
    {: return l.add(c); :} ;
*/


//---------------------------------------------------------------------------------------------
// <pointcut_expr> { [ with(LayerX); | without(LayerY); ] }
//---------------------------------------------------------------------------------------------
ContextConstraint context_constraint =
  pointcut_expr.p dla_block.s
  {: return new ContextConstraint(p, s); :};
  
LayerActivationBlock dla_block = 
  COLON dla_composition_statements.s SEMICOLON   
  {: return new LayerActivationBlock(new List(), s); :};
  
List dla_composition_statements = 
     dla_composition_statement.s                           
     {: return new List().add(s); :}
   | dla_composition_statements.l COMMA dla_composition_statement.s 
     {: return l.add(s); :} ;  
  
DLALayerActivation dla_composition_statement =
     LAYER_ACTIVATION LPAREN  argument_list.a  RPAREN 
     {: return new DLALayerActivation(a, true); :}
   | LAYER_DEACTIVATION LPAREN  argument_list.a  RPAREN 
     {: return new DLALayerActivation(a, false); :} ;     
     
//---------------------------------------------------------------------------------------------
// fancy stuff
//---------------------------------------------------------------------------------------------     
IfStmt if_then_statement =
    UNLESS LPAREN expression.e RPAREN statement.s  
    {: return new IfStmt(new LogNotExpr(e), s, new Opt()); :}
  ;

IfStmt if_then_else_statement =
    UNLESS LPAREN expression.e RPAREN statement_no_short_if.t ELSE statement.els 
    {: return new IfStmt(new LogNotExpr(e), t, new Opt(els)); :}
  ;
  
IfStmt if_then_else_statement_no_short_if =
    UNLESS LPAREN expression.e RPAREN statement_no_short_if.t ELSE statement_no_short_if.els 
    {: return new IfStmt(new LogNotExpr(e), t, new Opt(els)); :}
  ;    

Stmt statement = 
     statement_expression.s UNLESS expression.e SEMICOLON 
    {: return new IfStmt(new LogNotExpr(e), s, new Opt()); :}
  ;
  
Stmt statement = 
     statement_expression.s IF expression.e SEMICOLON 
    {: return new IfStmt(e, s, new Opt()); :}
  ;   
      
Expr primary_no_new_array =
	THIS_LAYER 
	{: return new ThisLayerAccess("thislayer"); :}  ;
  
//  Access field_access =
//	  SUPER_LAYER simple_name.id 
//	  {: SuperLayerAccess s = new SuperLayerAccess("super");
//	       s.setStart(SUPER_LAYER.getStart());
//	       s.setEnd(SUPER_LAYER.getEnd());
//	       return s.qualifiesAccess(id); :}
//	 |  name.n DOT SUPER_LAYER DOT simple_name.id
//	    {: SuperLayerAccess s = new SuperLayerAccess("super");
//     		s.setStart(SUPER_LAYER.getStart());
//     		s.setEnd(SUPER_LAYER.getEnd());
// 			return n.qualifiesAccess(s).qualifiesAccess(id); :}
//;


//Access method_invocation =
//	SUPER_LAYER DOT IDENTIFIER LPAREN argument_list.l? RPAREN
//	     {: SuperLayerAccess s = new SuperLayerAccess("super");
//	        s.setStart(SUPER_LAYER.getStart());
//	        s.setEnd(SUPER_LAYER.getEnd());
//	        MethodAccess m = new MethodAccess(IDENTIFIER, l);
//	        m.setStart(IDENTIFIER.getStart());
//	        m.setEnd(RPAREN.getEnd());
//	        return s.qualifiesAccess(m); :}
//	  |
//	  SUPER_LAYER DOT field_access.n DOT IDENTIFIER LPAREN argument_list.l? RPAREN
//	     {: SuperLayerAccess s = new SuperLayerAccess("super");
//	        s.setStart(SUPER_LAYER.getStart());
//	        s.setEnd(SUPER_LAYER.getEnd());
//	        MethodAccess m = new MethodAccess(IDENTIFIER, l);
//	        m.setStart(IDENTIFIER.getStart());
//	        m.setEnd(RPAREN.getEnd());
//	        return n.qualifiesAccess(s).qualifiesAccess(m); :}
//	   ;
   	 
	
  